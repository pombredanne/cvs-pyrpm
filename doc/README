PyRPM
=====

// This document contains asciidoc (http://www.methods.co.nz/asciidoc/) data
// and you should probably read the corresponding .html page.


Overview
--------

PyRPM is an experimental project to look at rpm package management. It is
a python module and a collection of scripts that provide similar functionality
as rpm, yum and co. It is written from ground up and is implemented only in
python. It mainly deals with rpm packages, the rpm database `rpmdb` in
`/var/lib/rpm`, comps.xml files and yum repositories (called repo data).

The reason for this project was to have a codebase with which we can test and
verify rpm, rpmdb and yum itself and experiment with new features and
implementations very quickly. Python is Red Hat's in-house defacto standard,
so using python to do rapid prototyping was only logical.

The code itself is still very small and modular. We're
constantly looking to improve the code, make it more production ready and 
remove duplicate functionality. Results from this project back to rpm and co
are very important for us to improve the current available Linux tools and
not rush with only adding another project for this.
Next to working on good algorithms and sane implementations, most code is
backed up with verify and testing scripts.


Warning
-------

The PyRPM project is by no means meant to be a full replacement of rpm or yum.
In its current state we feel confident that in general it won't break
anything, but the code isn't production quality yet.

The check scripts can be safely used as they won't modify anything on your
system, so feel free to use them at your convenience.

We personally have been using the yum replacement very extensively and even
used it to update our own systems, but that's not even remotely a guarantee
that it will work on your machine. It has only been run by a few people until
now.

Using it to set up buildroots on the other hand should be very safe as this
all happens in a very contained environment (sandbox principle).

Please let us know of any problems you encounter, if possible with some
reproducible testcases so we can figure out what might have happend.


Installation
------------

The newest source code is available from
link:http://people.redhat.com/laroche/pyrpm/[].
We will setup a more permanent project place, mailinglist and wiki later on.

The easiest way to install PyRPM is by compiling the src.rpm and installing
that. Python 2.3 or newer is required. In addition to standard python modules
PyRPM depends on:

 - libxml2-python to read xml files like the repo data from yum. Available from
   link:http://xmlsoft.org/[].
 - pysqlite (which is installed as python-sqlite on Fedora Core) and sqlite
   from link:http://pysqlite.org/[] and link:http://sqlite.org/[]
 - urlgrabber to download files via http and ftp
   from link:http://linux.duke.edu/projects/urlgrabber/[]

All the above are part of the Fedora Core 4 or newer, you might have to add
them yourself to older releases.


Pointers to related projects
----------------------------

rpm is available from link:http://www.rpm.org/[] and
link:http://www.wraptastic.org/[].
Mailinglist at link:https://listman.redhat.com/mailman/listinfo/rpm-list[].
The binary rpm format is described at
link:http://www.rpm.org/max-rpm/s1-rpm-file-format-rpm-file-format.html[].

yum is available from link:http://linux.duke.edu/projects/yum/[]
with the development mailinglist at
link:https://lists.linux.duke.edu/mailman/listinfo/yum-devel/[].

The new metadata for yum repositories (also named repodata) is discussed at
link:http://linux.duke.edu/projects/metadata/[].
It also includes the
link:http://linux.duke.edu/projects/metadata/generate/[createrepo] tool.

urlgrabber is available from
link:http://linux.duke.edu/projects/urlgrabber[].

repoview is available from
link:http://linux.duke.edu/projects/mini/repoview/[].

rpmlint is checking for packaging errors. It is available at
link:http://people.mandriva.com/%7eflepied/projects/rpmlint/[http://people.mandriva.com/~flepied/projects/rpmlint/].

Smart is written in python and combines several different binary
packaging formats within one packaging tool. It is available at
link:http://smartpm.org/[].

up2date and rhnlib are the client software for
link:http://rhn.redhat.com/[Red Hat Network] and can be downloaded from
link:http://download.fedora.redhat.com/pub/fedora/linux/core/development/SRPMS/[].

Anaconda is the Red Hat installation tool and can be downloaded at
link:http://elvis.redhat.com/anaconda/[],
link:http://fedora.redhat.com/projects/anaconda-installer/[] and
link:http://fedora.linux.duke.edu/wiki/Anaconda[].

Conary has looked at rpm history and defines a new distribution format that
enables rollbacks and easier customization on the client side. Available at
link:http://www.rpath.com/[] and link:http://wiki.conary.com/[].

apt4rpm is adapting the Debian packaging tool to also work with rpm packages.
Available from link:http://apt4rpm.sourceforge.net/[].

deltarpm is working on reducing the network traffic for rpm based updates.
Available at link:ftp://ftp.suse.com/pub/projects/deltarpm/[].

FAI (Fully Automatic Installation) for Debian. Available from
link:http://www.informatik.uni-koeln.de/fai/[].

OpenPKG cross-platform rpm-based software packaging, available at
link:http://www.openpkg.org/[].

Rebuild rpm packages and manage build roots via mach, available from
link:http://thomas.apestaart.org/projects/mach/[] and further info
at link:http://fedoraproject.org/wiki/UsingMach[].
Fedora Extras is using link:http://fedoraproject.org/wiki/Projects/Plague[].

Fedora Core Live CDs at link:http://fedoraproject.org/wiki/LiveCD[]
and link:http://fedoraproject.org/wiki/DerivedDistributions[].

Here should be a link on how rpm packages for Fedora Extras are checked
to make them real nice, stable and conforming to Red Hat and comunity
standards.


Developer Notes
---------------

Use `pychecker` or `pylint` to improve code quality, 4 space indents and
no tabs. Most scripts support giving `\--hotshot` as first option to run
them with the hotshot python profiler.
Send patches to link:mailto:laroche@redhat.com[Florian La Roche],
link:mailto:pknirsch@redhat.com[Phil Knirsch] and
link:mailto:twoerner@redhat.com[Thomas Woerner].
`oldpyrpm.py` has some TODO items listed in the source.


General Notes about the Rpm Format
----------------------------------

For RPM there are nowadays several "formats" in which you can find information
about rpm packages. The most typical one is of course the binary rpm header
which is part of every binart rpm package. A typical binary rpm package looks
like this:

+------+-----------+--------+-------------+
| Lead | Signature | Header | Gziped CPIO +
+------+-----------+--------+-------------+

The lead has a fixed size of 96 bytes and contains some very basic information
about the binary rpm. It can also generally be used to determine if a file is
a binary rpm or not (using file e.g.) as it contains some very specific to
easily identify them.

The signature and the header are stored as rpm header structures. Rpm header
structures look like this:

+-------+---------+-----------+-----------+-----------+
| Magic | IndexNr | StoreSize | Indexdata | Storedata |
+-------+---------+-----------+-----------+-----------+

The Magic is a hardcoded value, IndexNr the number of index entries and
StoreSize the size in bytes of the store data.

Indexdata consists of IndexNr index entries each of which is 16 bytes. Each
index entry looks like this:

+-----+------+--------+-------+
| Tag | Type | Offset | Count |
+-----+------+--------+-------+

Tag specifies which tag this entry is about. Type specifies the type of the
tage. Offset specifies at which offset in the Storedata the data begins for
this tag. Count has various size meanings depending on the type.

Storedata finally contains the real tag information. As mentioned in the
previous paragraph by using an index entry from the Indexdata you can find
and parse all data relevant to a specifc tag. The format depends of course
on the type of the tag.

More detailed information about the binary rpm format can be found here:
link:http://www.rpm.org/max-rpm/s1-rpm-file-format-rpm-file-format.html[]

The rpm binary format can be partially found in the rpmdb as well. The file
/var/lib/rpm/Packages contains the complete headers of the orignal binary
rpms in a rpm header structure format without the 8 byte magic and with
some additional installation revelvant indexes appended.

Another nowadays common format for reduced rpm header data is the repo metadata
format used by yum. It is a split up and reduced version of the orignal
rpm header information using XML. It is mainly useful to determine and resolve
dependencies of rpm packages. More information about the metadata can be found
here:

link:http://linux.duke.edu/projects/metadata/[]

Other less common storage formats include databases like SQLite or MySQL which
e.g yum uses to convert the repodata format to a more usable form locally.

Apart from that rpm itself extracts quite a bit of the information from rpm
binary headers and writes them in various db4 files in /var/lib/rpm. For a
very detailed and in depth description of the format take a look at the
README.rpmdb file coming with pyrpm.


Notes about the Repo-Metadata
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following things should be noted about the repo metadata. yum is using
the repodata only within the resolver part to determine a set of rpms that
should be updated and/or installed. Then the complete rpm headers are
downloaded and another dependency check from librpm is run in addition to
determining the ordering of rpm packages.

Here a few limitations you should be aware of if you want to work with the
repodata for more than the resolver or understand the limits of the
resolver:

 - Repodata has evolved over time. Until now no version information has been
   added to the created data, this might make sense for future changes.
 - Even if no epoch is specified in the rpm header, the metadata will
   specify this as "0". That's the correct way for version and dependency
   checks.
 - Dependency information is often specified like `bash >= 3.0` and consists
   of a (name, flag, version) triple. The flag part is specified as integer
   within the rpm header and is only partially copied over into the repodata.
   Installation ordering of rpm packages is not possible with the current
   available data (or only based on reduced data). Future repodata could make
   the data more complete or just copy the integer into the output to provide
   it as exact copy.
   (Repo data adds a "pre" flag if the RPMSENSE_PREREQ flag is set. That
   information is actually not complete to identify install prereq versus
   an erase prereq.)
 - The `primary.xml.gz` file contains a subset of the included files. See
   below for a discussion on the limits of that.


Huge Dependency Data
~~~~~~~~~~~~~~~~~~~~

The data eating up RAM in rpm headers are descriptions, changelogs and
filelists.

The dependency data we operate with is extremely huge. In addition to the
`Provides:` data which contains shared libs, rpm versions and explicitely
listed ones in .spec files, dependency data can also use any filerequires
like e.g. `Requires: /usr/bin/foo` to reference any file in any other rpm
package. That means we potentially have to look at a filelist of all rpm
packages. That data is extremely huge as the current Fedora Core
development tree contains more than 350000 files.

As the dependency data is worked with on each client to update the machine,
it must be a goal to reduce this data to a smaller subset.

The current repo metadata has a fixed file regex of
`^(.\*bin/.\*|/etc/.\*|/usr/lib/sendmail)$` and a directory regex of
`^(.\*bin/.\*|/etc/.\*)$`. That regex specifies the data given in the
`repodata/primary.xml.gz` file and you have to fallback to the complete
filelists available in `repodata/filelists.xml.gz` if any dependency
request is done outside of that data. (The regex gives a deterministic way
to know when to load the full filelist.) The regex used to be pretty
complete for Fedora Core in the past, but additional filerequires are
present in newer Fedora Core and Fedora Extra rpm packages which require
a reload of the complete lists.

In addition to the completeness problems above, it was also noted that
the regex lists contain 100 times more data than actually being used in
current repositories. Conary is thus maintaining explicit lists of
possible file requires. Maybe new ways to add autogenerated, small filelists
can be worked out that would work for most comon usage cases, also with
the fallback to the complete lists like yum / createrepo implement right
now.


Storing Complete Dep Graphs
~~~~~~~~~~~~~~~~~~~~~~~~~~~

It would also be possible to store dependency graphs that contain data for
the resolver to select the right rpm packages plus the orderer to specify
the right sequence to install them. But many machines do have further
packages installed outside of that package set, so this would then mostly
be used for new installs. Optimizing the general update path for running
machines should be more important than improving the install path for
new installs, so this is currently no goal, but would very well be possible
todo.


Is Python the right language?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python is a very good scripting language. Very nice for fast prototyping
and implementing new features. We currently see limits if too much data
needs to be processed. This is happening with parsing xml data as well
as with the huge amount of dependency data in rpm packages.

To a lesser degree also a few python modules could see improvements:

 - gzip decompression should offer a filetype object with .read().
   The current hacks in the class PyGZIP should go away.
 - bsddb access seems very slow (reading rpmdb)
 - bzip2 decompression does not have streaming support



Detailed tool descriptions
--------------------------

In order to understand what each of the tools really does this section describes
the behaviour of the tools in more detail for each tool.
Please also look at `tests/test10` to see actual tests we invoke ourselves from
time to time.


4.1 pyrpmcheck
--------------

There are currently 4 basic tests in pyrpmcheck. The first checks for all
packages if any two dirs differ in user/group/mode. The second check looks for
duplicate provides, meaning if 2 rpms provide the same thing. The third test
looks for dangling symlinks, that is, symlinks that point to nowhere. The
last check simply checks if any package names appear in the various given dirs.
This check is only useful for FC and FC-Extras, as there should be no overlap
there.

Check some common problems with packages and interdependancies for
Fedora Core Devel:
-----------------------
pyrpmcheck /mirror/fedora/development/i386/Fedora/RPMS
-----------------------


4.2 pyrpmcheckrepo
------------------

This tool should actually be renamed (and will so soon) to pyrpmcheckinstall as
that's what it does. What the tool does it to simulate an installation (just
like you could do with `pyrpmyum \--test`) and then simulates an update to the
second set of rpms or repository. A typical test would be to use a FC-3
or FC-4 yum.conf repo as a install base and then use a FC-devel repo or
rpm tree as the update tree. The nice thing about the simulation is that it
doesn't actually perform the installation and so doesn't need any diskspace.
Additionally you can use the (undocumented ;)) option `\--arch` where you can
specify any arch you like. The host arch doesn't matter for the simulation
as the whole code "thinks" it runs under arch. So simulated installs and
updates for all kinds of archs can be performed this way on one single machine.

Check if an update from Fedora Core 4 to Fedora Core Devel works or what
problems come up:
-----------------------
pyrpmcheckrepo -r /mnt/foo install /mirror/fedora/4/i386/os/Fedora/RPMS update /mirror/fedora/development/i386/Fedora/RPMS
-----------------------


4.3 pyrpmcreaterepo
-------------------

Here we've take the code from the original createrepo and replaced the rpmlib
based access to rpm headers with our code. This code is not complete until now.


4.4 pyrpmdbconvert
------------------

Nothing written yet. This supports changing over from the current rpmdb to
e.g. a sqlite database.


4.5 pyrpmdbverify
-----------------

This tool actually really reads all DB4 files in /var/lib/rpm (or, if you
use the `\--dbpath` option, in that directory) and tries to cross check the entries
with the rpm header that is found in /var/lib/rpm/Packages. The README.rpmdb
contains a lot more detail about the structure of rpmdb. Simply put we check
if for every entry in every file there is a corresponding entry in Packages
and vice versa. There are some exceptions and special cases, but all known ones
are handled correctly. The one check that is very unreliable is the SHA1 header
checksum tests as this test has to rely on a very specific ordering of the
rpm binary header and about the tags that appear in the original rpm. If those
assupmtions don't hold this checksum can't be computed correctly.

Link to a page with more information on rpmdb repair information is available at
link:http://www.rpm.org/hintskinks/repairdb/[].

Check the rpmdb of the current system with internal cross checks
-----------------------
pyrpmdbverify
-----------------------

Same, but this time we use external rpms to verify against, too
-----------------------
pyrpmdbverify /mirror/fedora/development/i386/Fedora/RPMS
-----------------------


4.6 pyrpminstall
----------------

Simply put this tool allows you to install, update and erase rpms just like
you would with rpm itself. It supports most of the common options from rpm
and is mostly using the same syntax, too. As it's "only" rpm though there is
no depresolver in this tool, so if you have any missing dependencies you'll
have to fiddle them out yourself, just as you had to do with rpm.


4.7 pyrpmkickstart
------------------

Nothing written yet.


4.8 pyrpmrandomizer
-------------------

This is our main stresstest tool. With it you can run literally thousands of
update and erase operations in a buildroot and after several days scan the
output for any problems. It works simply by alternating between trying to
randomly install one rpm package (including needed dependent rpms) and
randomly removing one package. There are several special
options which help circumvent some strange problems. The first is `\--servicehack`
which simply changes `/sbin/service` to "exit 0" as especially some of the
postuninstall scripts really misbehave otherwise and you don't need any
services started or stopped in a buildroot anyway for testing. The second is
the `\--autoerase` option which I'll describe a little more in detail for
pyrpmyum.

Run 10000 install and erase operations in the /mnt/build/test buildroot and
save the resulting output in /tmp/stresstest
-----------------------
pyrpmrandomizer --servicehack -y -v -c fc3-updates-i386.conf -r /mnt/build/test 10000 >&/tmp/stresstest
-----------------------


4.9 pyrpmrebuilddb
------------------

Ever had to use `rpm \--rebuilddb`? Well, here is our version of it. It tries to
do the same thing as rpm where it takes /var/lib/rpm/Packages and rebuilds the
database with that information. The default path for the new db is ./rpmdb
so that your original one won't be overwritten.
Currently `/var/lib/rpm/Pubkeys` is not yet rebuild.


4.10 pyrpmspecinfo
------------------

As we often have to work with specfiles, too, we've written a small tool with
which we can extrace the different sections from a specfile in order to use
that info via pipe in other tools.


4.11 pyrpmyum
-------------

Our main workhorse and real puppy. This tool, as the name already suggests is
basically a yum replacement of sorts. It uses the same command line options as
yum and uses the same config files, too. It contains a complete depresolver
and allows complex installs, updates and erases from systems. We have used it
to install FC1 and then step by step update to FC1-updates, FC2, FC2-updates,
FC3, FC3-updates and finally FC4. Some of the updates need the `\--autoerase`
option though because some dependencies just can't be met and packages need
to be removed in order to fulfill them. The autoerase option tries exactly
that by semi-intelligently selecting the package that needs to be removed in
order for the update to work properly without user intervention. For the
described update chain only about 6-7 packages were deleted up to FC3, and all
of them would have to be removed manually anyway. But a word of warning here:
The autoerase option might run amok if things go really wrong or you try to
update to a completely broken tree and would then try to remove almost all of
your packages. This has never happend for real trees for us, but just imagine
a broken repository and things could go really wrong. That's why this option
isn't directly listed in the help and should only be used for a `\--test` run
or without the -y option where you get listed separately from the "normal"
transaction the packages that pyrpmyum would autoerase for you.

Install a full Fedora Core Development tree in `/mnt/build/fc-devel-i386`
buildroot:
-----------------------
pyrpmyum -y -v -c fc-devel-i386.conf -r /mnt/build/fc-devel-i386 install "*"
-----------------------

Update kdebase in `/mnt/build/fc-devel-i386` buildroot to latest version,
resolving all dependancies:
-----------------------
pyrpmyum -y -v -c fc-devel-i386.conf -r /mnt/build/fc-devel-i386 update kdebase
-----------------------

Same, only if we get some unresolvable problems try to remove packages that
don't fit automatically:
-----------------------
pyrpmyum -y -v --autoerase -c fc-devel-i386.conf -r /mnt/build/fc-devel-i386 update kdebase
-----------------------

Make a dry-run of the above command to be sure that not everything gets
automatically deleted :)
-----------------------
pyrpmyum -y -v --test --autoerase -c fc-devel-i386.conf -r /mnt/build/fc-devel-i386 update kdebase
-----------------------

Remove glibc and all depending packages from our buildroot :)
-----------------------
pyrpmyum -y -v -c fc-devel-i386.conf -r /mnt/build/fc-devel-i386 remove glibc
-----------------------


4.12 oldpyrpm.py
----------------

This script does not depend on the rest of the pyrpm module, but is all
copied into one file. It is not as complete as the new pyrpm code, but
can still be used for many use cases. oldpyrpm.py only depends on
python-2.2 or newer and you can use parts of it even if one of the addon
python modules are not available. Also feel free to check the script for
more hidden usage cases.


Diffing Source Rpms
~~~~~~~~~~~~~~~~~~~

You can list the changes between two source packages. If you specify
`\--explode` it tries to also show the changes within `\*.tar.gz` files
if they have changed.
-----------------------
oldpyrpm.py [--explode] --diff 1.src.rpm 2.src.rpm
-----------------------


Extracting Rpm Data
~~~~~~~~~~~~~~~~~~~

You can extract source or normal binary packages. This always overwrites
existing files and does not start any scripts in binary packages, so it
is often only used for source packages:
-----------------------
oldpyrpm.py [--buildroot=/chroot] --extract *.rpm
-----------------------


Excluded Arch Checking
~~~~~~~~~~~~~~~~~~~~~~

You can check source rpm packages and mark the ones which are excluded from
building on certain architectures.
-----------------------
oldpyrpm.py --checkarch /mirror/fedora/development/SRPMS
-----------------------


Checking rpmdb in /var/lib/rpm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can check the rpm database `rpmdb`. The complete information that rpm
needs is included in `/var/lib/rpm/Packages` and the opengpg data in
`/var/lib/rpm/Pubkeys`. All other db4 files in the rpmdb directory contain
duplicate data from `Packages` to speed up information lookup.

This is how the rpmdb is being checked:

 - Verify all data from `/var/lib/rpm/Packages` is the same as in all other
   db4 files (two-way check).
 - Most of the rpm header data does have a sha1 checksum. For most newer rpm
   packages in rpmdb we can try to verify that sha1 to be correct.
 - If scripts fail often duplicate rpm packages stay installed. Apart from
   kernel packages and a few other special packages, you get a warning about
   all duplicated packages.
 - Check all dependency information for `Requires:`, `Provides:`,
   `Conflicts:` and `Obsoletes:` is correctly matching up and if the
   installed rpm packages do have any fileconflicts.
 - If you specify a yum configuration file, all installed files are checked
   against the yum repositories. Which rpm packages do not match, which
   installed packages are not available in one of the repos. You can specify
   more than on yum config file by repeating the `-c` option.
 - If no repodata is read in, only the rpmdb files are accessed by all checks
   and all tests can run as non-root user. Also the check code automatically
   detects the endianess of the db4 files and looks at the kernel packages
   to switch over to some other arch setting. So copying over rpmdb files from
   other machines and checking them is real easy.
 - The check can be run on any architecture for any other architecture with
   automatic detection of the right endian setting as well as automatic
   arch setting by looking at the installed kernels. So you can copy the
   rpmdb files onto a central server to check them all.
 - Check if only packages with the correct architecture are installed. Make
   sure no arch-dependant rpm and a noarch package are installed at the
   same time.
 - `-q` and `\--quiet` output less progress information. `-v` or `\--verbose`
   add more output information. `\--rpmdbpath /var/lib/rpm/` can specify the
   directory which contains the database files.
 - For special setups you might want to specify `\--releasever 4`,
   `\--arch i686` or `\--buildroot /mnt/build` (buildroot is actually only
   used to read the yum config files.

Example usages to check your rpm database `rpmdb`:
-----------------------
oldpyrpm.py [--verbose|-v|--quiet|-q] [--rpmdbpath=/var/lib/rpm/] --checkrpmdb
oldpyrpm.py -c /etc/yum.conf --checkrpmdb
-----------------------


Createrepo
~~~~~~~~~~

You can generate repo metadata like `createrepo` does. You need to copy the
`comps.xml` file yourself into the repodata directory if you need one.
Also xml pretty printing is hardcoded (`-p` option for upstream createrepo).
Createrepo files are compatibel with the output from createrepo-0.4.3.
-----------------------
cp comps.xml /mirror/fedora/development/i386/repodata/comps.xml
oldpyrpm.py --createrepo /mirror/fedora/development/i386/
-----------------------


Package Verification
~~~~~~~~~~~~~~~~~~~~

Per default `oldpyrpm.py` is only reading in rpm packages and doing some
sanity checks on them. It can read in rpm packages from Red Hat Linux 5.2
and newer. The `pyrpmyum` code only works on RHEL3 or newer due to how
missing epoch are treated in dependency information.
Here some options that can be useful:

 - If you specify a directory, automatically all files in that dir are read.
 - `\--nodigest` skips verifying the md5 checksum of the header and payload
   data and the sha1 checksum of the header data.
 - `\--nopayload` skips reading in the cpio data of all files
   (called `payload`).
 - Add `-c /etc/yum.conf` to read in yum repositories.
 - `\--strict` is adding checks which are only useful for the Fedora Core
   development tree.
 - `\--verbose` or `-v` increases output logging information. This is nearly
   unused in the current code, so doesn't really change anything.
 - `\--quiet` or `-q` sets the verbose level to 0.
 - Specify a certain architecture via `\--arch i686`. Default value is detected
   via uname(2).
 - To override the release version information add `\--releasever 4`.
   The default is the version number of the installed redhat-release or
   fedora-release package (used rpm packages can be specified via
   `\--distroverpkg="redhat-release fedora-release"`).
 - `-y` to never prompt for yes/no questions. This is unused until now.
 - `\--noverify` is skipping the special debug tests and then mainly all
   rpm packages are only read in. If also `\--small` is specified, not all
   rpm tags are read in, only the ones in `importanttags`.
 - Specify a cache directory to hold data from yum repopsitories via
   `\--cachedir ~/.pyrpm/cache/`.
 - Dependency and fileconflict checking is done if either `\--strict` or
   `\--checkdeps` is added.

Example usages:
-----------------------
oldpyrpm.py --strict --nodigest --nopayload /mirror/fedora/development/i386/Fedora/RPMS
oldpyrpm.py --strict --nodigest --nopayload /mirror/fedora/development/SRPMS
find /mirror/ -name "*.rpm" -type f -print0 2>/dev/null | xargs -0 oldpyrpm.py --nodigest --nopayload
locate '*.rpm' | xargs oldpyrpm.py --nodigest --nopayload
-----------------------

Only read in the needed rpm tags and do dependency checking without further
debug checks. This shows the full speed of the current implementation and
finishes in under 14 seconds for FC-development on some laptop:
-----------------------
time oldpyrpm.py --checkdeps --small --nodigest --nopayload --noverify /mirror/fedora/development/i386/Fedora/RPMS
-----------------------

