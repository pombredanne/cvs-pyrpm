#!/usr/bin/python
#
# rpmtree.py
#
# list dependency tree
#
# (c) 2004 Thomas Woerner <twoerner@redhat.com>
#
# version 2005-01-13-01

import sys, os, pyrpmlib
from rpmconstants import *
from cpio import *
from hashlist import HashList

# ----------------------------------------------------------------------------

def evr_split(evr):
    i = 0
    p = evr.find(":") # epoch
    if p != -1:
        epoch = evr[:p]
        i = p+1
    else:
        epoch = "0"
    p = evr.find("-", i) # version
    if p != -1:
        version = evr[i:p]
        release = evr[p+1:]
    else:
        version = evr[i:]
        release = ""
    return (epoch, version, release)

# ----------------------------------------------------------------------------

def xislower(chr): return (chr >= 'a' and chr <= 'z')
def xisupper(chr): return (chr >= 'A' and chr <= 'Z')
def xisalpha(chr): return (xislower(chr) or xisupper(chr))
def xisdigit(chr): return (chr >= '0' and chr <= '9')
def xisalnum(chr): return (xisalpha(chr) or xisdigit(chr))

# ----------------------------------------------------------------------------

def compare(str1, str2):
    if str1 == "" and str2 == "": return 0;
    elif str1 == "" and str2 != "": return -1;
    elif str1 != "" and str2 == "": return 1;
    elif str1 == str2: return 0;

    i1 = i2 = 0
    while i1 < len(str1) and i2 < len(str2):
        # remove leading separators
        while i1 < len(str1) and not xisalnum(str1[i1]): i1 += 1
        while i2 < len(str2) and not xisalnum(str2[i2]): i2 += 1
        j1 = i1
        j2 = i2

        # search for numbers and comprare them
        while j1 < len(str1) and xisdigit(str1[j1]): j1 += 1
        while j2 < len(str2) and xisdigit(str2[j2]): j2 += 1
        if j1 > i1 or j2 > i1:
            if j1 == i1: return -1
            if j2 == i2: return 1
            if j1-i1 < j2-i2: return -1
            if j1-i1 > j2-i2: return 1
            while i1 < j1 and i2 < j2:
                if int(str1[i1]) < int(str2[i2]): return -1
                if int(str1[i1]) > int(str2[i2]): return 1
                i1 += 1
                i2 += 1
            # found right side 
            if i1 == len(str1): return -1
            if i2 == len(str2): return 1
        if i2 == len(str2): return -1

        # search for alphas and compare them
        while j1 < len(str1) and xisalpha(str1[j1]): j1 += 1
        while j2 < len(str2) and xisalpha(str2[j2]): j2 += 1
        if j1 > i1 or j2 > i1:
            if j1 == i1: return -1
            if j2 == i2: return 1
            if str1[i1:j1] < str2[i2:j2]: return -1
            if str1[i1:j1] > str2[i2:j2]: return 1
            # found right side 
            i1 = j1
            i2 = j2

    # still no difference
    if i2 == len(str2):
        return 0
    else:
        if i1 == len(str1):
            return -1
        else:
            return 1

# ----------------------------------------------------------------------------

def labelCompare(e1, e2):
    if e2[2] == "": # no release
        e1 = (e1[0], e1[1], "")

    r = compare(e1[0], e2[0])
    if r == 0: r = compare(e1[1], e2[1])
    if r == 0: r = compare(e1[2], e2[2])
    elif ignore_epoch == 1:
        if compare(e1[1], e2[1]) == 0:
            if compare(e1[2], e2[2]) == 0:
                r = 0
    return r

# ----------------------------------------------------------------------------

def evr_compare(evr1, comp, evr2):
    res = -1
    e1 = evr_split(evr1)
    e2 = evr_split(evr2)
    r = labelCompare(e1, e2)
    if r == -1:
        if comp & RPMSENSE_LESS:
            res = 1
    elif r == 0:
        if comp & RPMSENSE_EQUAL:
            res = 1
    else: # res == 1
        if comp & RPMSENSE_GREATER:
            res = 1
    return res

# ----------------------------------------------------------------------------

def gen_evr(epoch, version, release):
    if epoch == None or epoch == "":
        return "%s-%s" % (version, release)
    else:
        return "%s:%s-%s" % (epoch, version, release)

# ----------------------------------------------------------------------------

def gen_operator(flag):
    op = ""
    if flag & RPMSENSE_LESS:
        op = "<"
    if flag & RPMSENSE_GREATER:
        op += ">"
    if flag & RPMSENSE_EQUAL:
        op += "="
    return op

# --

def gen_depstr((name, flag, version)):
    if version == "":
        return name
    return "%s %s %s" % (name, gen_operator(flag), version)

# ----------------------------------------------------------------------------

class RpmList:
    def __init__(self):
        self.clear()
    def clear(self):
        self.rpms = [ ]
        self.list = { }
    def __len__(self):
        return len(self.rpms)
    def __getitem__(self, i):
        return self.rpms[i]
    def append(self, pkg):
        if self.list.has_key(pkg["name"]):
            i = self.list[pkg["name"]]
            if str(pkg) == str(self.rpms[i]):
                return 0
#            if labelCompare((pkg["epoch"], pkg["version"], pkg["release"]),
#                            (self.rpms[i]["epoch"], self.rpms[i]["version"],
#                             self.rpms[i]["release"])) < 0:
#                return 0
            if compare(pkg["arch"], self.rpms[i]["arch"]) <= 0:
                return 0           
            old = self.rpms.pop(i)
            print "Replacing '%s' with '%s'" % (old.getNEVRA(), pkg.getNEVRA())
        else:
            i = len(self.rpms)
        self.list[pkg["name"]] = i
        self.rpms.insert(i, pkg)
        return 1

# ----------------------------------------------------------------------------

class Provides:
    def __init__(self):
        self.clear()
    def clear(self):
        self.p_provide = { }
    def append(self, name, flag, version, rpm):
        if not self.p_provide.has_key(name):
            self.p_provide[name] = [ ]
        self.p_provide[name].append((flag, version, rpm))
    def search(self, name, flag, version):
        if not self.p_provide.has_key(name):
            return [ ]

        ret = [ ]
        for p in self.p_provide[name]:
            if version == "":
                ret.append(p[2])
            else:
                if evr_compare(p[1], flag, version) == 1 and \
                       evr_compare(p[1], p[0], version) == 1:
                    ret.append(p[2])
                if evr_compare(gen_evr(p[2]["epoch"], p[2]["version"],
                                       p[2]["release"]), flag, version) == 1:
                    ret.append(p[2])
        return ret

# ----------------------------------------------------------------------------

class Filenames:
    def __init__(self):
        self.clear()
    def clear(self):
        self.provide = { }
        self.multi = [ ]
    def append(self, name, rpm):
        if not self.provide.has_key(name):
            self.provide[name] = [ ]
        else:
            self.multi.append(name)
        self.provide[name].append(rpm)
    def search(self, name):
        if not self.provide.has_key(name):
            return [ ]
        return self.provide[name]

# ----------------------------------------------------------------------------

def normalize(list):
    i = 0
    while i < len(list):
        j = i + 1
        while j < len(list):
            if str(list[i]) == str(list[j]):
                list.pop(j)
            else:
                j += 1
        i += 1

# ----------------------------------------------------------------------------

class Relation:
    def __init__(self):
        self.pre = HashList()
        self._post = HashList()
    def __str__(self):
        return "%d %d" % (len(self.pre), len(self._post))       

class Relations:
    def __init__(self):
        self.list = HashList()
    def __len__(self):
        return len(self.list)
    def __getitem__(self, key):
        return self.list[key]
    def append(self, pkg, pre, flag):
        if pre == pkg:
            return
        if not pkg in self.list:
            self.list[pkg] = Relation()
        if pre not in self.list[pkg].pre:
            self.list[pkg].pre[pre] = flag
        else:
            # prefer hard requirements
            if self.list[pkg].pre[pre] == 1 and flag == 2:
                self.list[pkg].pre[pre] = flag
        for (p,f) in self.list[pkg].pre:
            if p in self.list:
                if pkg not in self.list[p]._post:
                    self.list[p]._post[pkg] = 1
            else:
                self.list[p] = Relation()
                self.list[p]._post[pkg] = 1
    def remove(self, pkg):
        rel = self.list[pkg]
        for (r,f) in rel._post:
            if len(self.list[r].pre) > 0:
                del self.list[r].pre[pkg]
        del self.list[pkg]
    def has_key(self, key):
        return self.list.has_key(key)

# ----------------------------------------------------------------------------

def usage():
    print """Usage: %s [-v[v]] [-nr] [-sd] [<rpm name/package>...]

  -h  | --help                print help
  -v  | --verbose             be verbose, and more, ..
  -ie | --ignore-epoch        ignore epoch in provides and requires

This program prints a treee for package dependencies.
The asterisc in the listing is shown after dependencies, which are resolved in
a tree before. 

""" % sys.argv[0]

# ----------------------------------------------------------------------------

sout =  os.readlink("/proc/self/fd/1")
devpts = 0
if sout[0:9] == "/dev/pts/":
    devpts = 1

def progress_write(msg):
    if devpts == 1:
        sys.stdout.write("\r")
    sys.stdout.write(msg)
    if devpts == 0:
        sys.stdout.write("\n")
    sys.stdout.flush()

# ----------------------------------------------------------------------------

rpms = RpmList()

ignore_epoch = 0
verbose = 0

tags = [ "name", "epoch", "version", "release", "arch", \
         "providename", "provideflags", "provideversion", \
         "requirename", "requireflags", "requireversion", \
         "obsoletename", "obsoleteflags", "obsoleteversion", \
         "conflictname", "conflictflags", "conflictversion", \
         "filesizes", "filemodes", "filerdevs", "filemtimes", \
         "filemd5s", "filelinktos", "fileflags", "fileusername", \
         "filegroupname", "fileverifyflags", "filedevices", "fileinodes", \
         "filelangs", "dirindexes", "basenames", "dirnames", "filecolors", \
         "fileclass", "classdict", "filedependsx", "filedependsn", \
         "dependsdict" ]

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usage()
        sys.exit(0)

    for i in xrange(1, len(sys.argv)):
        if sys.argv[i] == "-h" or sys.argv[i] == "--help":
            usage()
            sys.exit(0)
        elif sys.argv[i][:2] == "-v":
            j = 1
            while j < len(sys.argv[i]) and sys.argv[i][j] == "v":
                verbose += 1
                j += 1
        elif sys.argv[i] == "--verbose":
            verbose += 1
        elif sys.argv[i] == "-ie"or sys.argv[i] == "--ignore-epoch":
            ignore_epoch = 1
        else:
            r = pyrpmlib.RpmPackage("file:/"+sys.argv[i])
            r.read(tags=tags)
            if verbose > 0:
                progress_write("Reading %d " % (len(rpms)+1))
            rpms.append(r)
    if verbose > 0 and len(rpms) > 0:
        print

    # -- processing

    provides = Provides()
    filenames = Filenames()
    
    for i in xrange(len(rpms)):
        if verbose > 0:
            progress_write("Preprocessing [%d/%d] " % (i+1, len(rpms)))
        for p in rpms[i]["provides"]:
            provides.append(p[0], p[1], p[2], rpms[i])
        for f in rpms[i]["filenames"]:
            filenames.append(f, rpms[i])
    if verbose > 0 and len(rpms) > 0:
        print

    # -- resolving provides

    unresolved_requires = [ ]
    resolved = [ ]
    relations = Relations()
    no_relations = [ ]
    
    unresolved = 0
    old_r = old_r2 = None
    i = 0
    while i < len(rpms):
        r = rpms[i]
        if verbose > 0:
            progress_write("Resolving [%d/%d] " % (i+1, len(rpms)))
        j = 0
        for u in r["requires"]:
            (name, flag, version) = u
            if name[0:7] == "rpmlib(": # drop rpmlib requirements
                continue
            if name[0:7] == "config(": # drop config requirements
                continue
            drop = 0
            for p in r["provides"]:
                if p[0] == u[0] and (u[2] == "" or \
                                     (evr_compare(u[2], p[1], p[2]) == 1 and \
                                      evr_compare(u[2], u[1], p[2]) == 1)):
                    if verbose > 2:
                        print "%s: Dropping self requirement for %s" % \
                              (r.getNEVRA(), gen_depstr(u))
                    drop = 1
                    break
            if drop == 1:
                continue
            s = provides.search(name, flag, version)
            if name[0] == '/': # all filenames are beginning with a '/'
                s += filenames.search(u[0])
            if len(s) > 0:
                normalize(s)
                if verbose > 3:
                    if r != old_r2:
                        print "\n%s" % r.getNEVRA()
                        old_r2 = r
                    sys.stdout.write("\t%s :" % gen_depstr(u))
                    for r2 in s:
                        sys.stdout.write(" %s" % r2.getNEVRA())
                    print
                    sys.stdout.flush()
                f = 0
                if not (isErasePreReq(flag) or \
                        not (isInstallPreReq(flag) or isLegacyPreReq(flag))):
                    f += 2
                if not (isErasePreReq(flag) or \
                        (isInstallPreReq(flag) or isLegacyPreReq(flag))):
                    f += 1
                if f != 0:
                    for s2 in s:
                        relations.append(r, s2, f)
            else:
                if old_r != r:
                    print "ERROR: %s: unresolved dependency:" % r.getNEVRA()
                    old_r = r
                print "\t%s" % gen_depstr(u)
                unresolved = 1
        i += 1
    if verbose > 0 and len(rpms) > 0:
        print
    if unresolved == 1:
        sys.exit(-1)

    # -- check conflicts (conflicts and obsoletes)

    found_conflicts = 0
    i = 0
    while i < len(rpms):
        r = rpms[i]
        if verbose > 0:
            progress_write("Checking for conflicts [%d/%d] " % (i+1, len(rpms)))
        for c in r["conflicts"] + r["obsoletes"]:
            s = provides.search(c[0], c[1], c[2])
            if c[0][0] == '/': # all filenames are beginning with a '/'
                s += filenames.search(c[0])
            if len(s) > 0:
                normalize(s)
                if r in s: s.remove(r)
            if len(s) > 0:
                for r2 in s:
                    print "\nERROR: %s Conflicts for '%s' with %s" % \
                          (r.getNEVRA(), gen_depstr(c), r2.getNEVRA())
                found_conflicts = 1
        i += 1
    if verbose > 0 and len(rpms) > 0:
        print
    if found_conflicts == 1:
        sys.exit(-1)

    # -- check for file conflicts

    found = 0
    i = 0
    for f in filenames.multi:
        if verbose > 0:
            progress_write("Checking for file conflicts [%d/%d] " % (i+1, len(filenames.multi)))
        s = filenames.search(f)
        for j in xrange(len(s)):
            fi1 = s[j].getRpmFileInfo(f)
            for k in xrange(j+1, len(s)):
                fi2 = s[k].getRpmFileInfo(f)
                # ignore directories and links
                if fi1.mode & CP_IFDIR and fi2.mode & CP_IFDIR:
                    continue
                if fi1.mode & CP_IFLNK and fi2.mode & CP_IFLNK:
                    continue
                if fi1.mode != fi2.mode or fi1.mtime != fi2.mtime or \
                       fi1.filesize != fi2.filesize:
                    found = 1
                    print "\nERROR: %s: File conflict for '%s' with %s" % \
                          (s[j].getNEVRA(), f, s[k].getNEVRA())
        i += 1
    if verbose > 0 and len(filenames.multi) > 0:
        print
    if found == 1:
        sys.exit(0)

    # -- relations

#    i = 0
#    l = len(resolved)
#    while len(resolved) > 0:
#        rel = resolved.pop(0)
#        pkg = rel[0]
#        name = rel[1][0]
#        flag = rel[1][1]
#        s = rel[2]
#        if verbose > 0:
#            progress_write("Generating relations [%d/%d] " % (i+1, l))
#        if name[0:7] != "config(": # drop config requirements
#            f = 0
#            if not (isErasePreReq(flag) or not (isInstallPreReq(flag) or \
#                                                isLegacyPreReq(flag))):
#                f += 2
#            if not (isErasePreReq(flag) or (isInstallPreReq(flag) or \
#                                            isLegacyPreReq(flag))):
#                f += 1
#            if f != 0:
#                for s2 in s:
#                    relations.append(pkg, s2, f)
#        i += 1
#
#    if verbose > 0 and i > 1:
#        print

    if verbose > 2:
        print "\t==== relations (%d) ====" % len(relations)
        for (pkg, rel) in relations:
            print "\t%d %d %s" % (len(rel.pre), len(rel._post),
                                  pkg.getNEVRA())
        print "\t==== relations ===="

    # save packages which have no relations

    i = 0
    while i < len(rpms):
        r = rpms[i]
        if not relations.has_key(r):
            no_relations.append(r)
        i += 1

    # sort

    order = [ ]
    idx = 1
    while len(relations) > 0:
        next = None
        for (pkg, rel) in relations:
            if len(rel.pre) == 0:
                next = (pkg, rel)
                break
        if next != None:
            pkg = next[0]
            order.append(pkg)
            if verbose > 0:
                print "%d: %s" % (idx, pkg.getNEVRA())
                idx += 1
            relations.remove(pkg)
        else:
            if verbose > 2:
                print "-- LOOP --"
                print "\n===== remaining packages ====="
                for (pkg2, rel2) in relations:
                    print "%s" % pkg2.getNEVRA()
                    for i in xrange(len(rel2.pre)):
                        print "\t%s (%d)" % (rel2.pre[i][0].getNEVRA(),
                                             rel2.pre[i][1])
                print "===== remaining packages =====\n"

            (package, rel) = relations[0]
            loop = HashList()
            loop[package] = 0
            i = 0
            pkg = package
            p = None
            while p != package and i >= 0 and i < len(relations):
                (p,f) = relations[pkg].pre[loop[pkg]]
                if p == package:
                    break
                if loop.has_key(p):
                    package = p
                    # remove leading nodes
                    while len(loop) > 0 and loop[0][0] != package:
                        del loop[loop[0][0]]
                    break
                else:
                    loop[p] = 0
                    pkg = p
                    i += 1

            if p != package:
                print "error no loop found"
                sys.exit(0)

            if verbose > 2:
                print "\n===== loop (%d) =====" % len(loop)
                for (p,i) in loop:
                    print "%s" % p.getNEVRA()
                print "===== loop =====\n"

            found = 0
            for (p,i) in loop:
                (p2,f) = relations[p].pre[i]
                if f == 1:
                    if verbose == 2:
                        print "Removing requires for %s from %s" % \
                              (p2.getNEVRA(), p.getNEVRA())
                    del relations[p].pre[p2]
                    del relations[p2]._post[p]
                    found = 1
                    break
            if found == 0:
                (p, i) = loop[0]
                (p2,f) = relations[p].pre[i]
                if verbose == 2:
                    print "Zapping requires for %s from %s to break up hard loop" % \
                          (p2.getNEVRA(), p.getNEVRA())
                del relations[p].pre[p2]
                del relations[p2]._post[p]

    if verbose > 2:
        print "\n===== PACKAGES WITH NO RELATIONS ===="

    for r in no_relations:
        order.append(r)
        if verbose > 0:
            print "%d: %s" % (idx, r.getNEVRA())
            idx += 1

    for r in order:
        print r.source
        
    sys.exit(0)
