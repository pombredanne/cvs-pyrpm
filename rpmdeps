#!/usr/bin/python
#
# rpmtree.py
#
# list dependency tree
#
# (c) 2004 Thomas Woerner <twoerner@redhat.com>
#
# version 2005-01-13-01

import sys, os, rpm, types

# ----------------------------------------------------------------------------

def evr_split(evr):
    i = 0
    p = evr.find(":") # epoch
    if p != -1:
        epoch = evr[:p]
        if epoch == "0": epoch = ""
        i = p+1
    else:
        epoch = ""
    p = evr.find("-", i) # version
    if p != -1:
        version = evr[i:p]
        release = evr[p+1:]
    else:
        version = evr[i:]
        release = ""
    return (epoch, version, release)

# ----------------------------------------------------------------------------

def compare(str1, str2):
    if str1 == "" and str2 == "": return 0;
    elif str1 == "" and str2 != "": return -1;
    elif str1 != "" and str2 == "": return 1;
    elif str1 == str2: return 0;

    i1 = i2 = 0
    while i1 < len(str1) and i2 < len(str2):
        # remove leading separators
        while i1 < len(str1) and not str1[i1].isalnum(): i1 += 1
        while i2 < len(str2) and not str2[i2].isalnum(): i2 += 1
        j1 = i1
        j2 = i2

        # search for numbers and comprare them
        while j1 < len(str1) and str1[j1].isdigit(): j1 += 1
        while j2 < len(str2) and str2[j2].isdigit(): j2 += 1
        if j1 > i1 or j2 > i1:
            if j1 == i1: return -1
            if j2 == i2: return 1
            if j1-i1 > j2-i2: return 1
            if j1-i1 < j2-i2: return -1
            while i1 < j1 and i2 < j2:
                if int(str1[i1]) > int(str2[i2]): return 1
                if int(str1[i1]) < int(str2[i2]): return -1
                i1 += 1
                i2 += 1
            # found right side 
            if i2 == len(str2): return 0

        # search for alphas and compare them
        while j1 < len(str1) and str1[j1].isalpha(): j1 += 1
        while j2 < len(str2) and str2[j2].isalpha(): j2 += 1
        if j1 > i1 or j2 > i1:
            if j1 == i1: return -1
            if j2 == i2: return 1
            if str1[i1:j1] > str2[i2:j2]: return 1
            if str1[i1:j1] < str2[i2:j2]: return -1
            # found right side 
            if j2 == len(str2): return 0
            i1 = j1
            i2 = j2

    # still no difference
    if i2 == len(str2):
        return 0
    else:
        if i1 == len(str1):
            return -1
        else:
            return 1

def evr_compare(evr1, comp, evr2):
    res = -1

    e1 = evr_split(evr1)
    e2 = evr_split(evr2)
    if e2[2] == "": # no release
        e1 = (e1[0], e1[1], "")

    r = compare(e1[0], e2[0])
    if r == 0: r = compare(e1[1], e2[1])
    if r == 0: r = compare(e1[2], e2[2])
    elif ignore_epoch == 1:
        if compare(e1[1], e2[1]) == 0:
            if compare(e1[2], e2[2]) == 0:
                r = 0
    
    if r == -1:
        if comp == "<" or comp == "<=":
            res = 1
    elif r == 0:
        if comp == "<=" or comp == "=" or comp == ">=":
            res = 1
    else: # res == 1
        if comp == ">=" or comp == ">":
            res = 1

    return res

# ----------------------------------------------------------------------------

def gen_evr(epoch, version, release):
    if epoch == None or epoch == "":
        return "%s-%s" % (version, release)
    else:
        return "%s:%s-%s" % (epoch, version, release)

# ----------------------------------------------------------------------------

def gen_operator(flag):
    op = ""
    if flag & rpm.RPMSENSE_LESS:
        op = "<"
    if flag & rpm.RPMSENSE_GREATER:
        op += ">"
    if flag & rpm.RPMSENSE_EQUAL:
        op += "="
    return op

# ----------------------------------------------------------------------------

def hdr_str(hdr):
    if hdr[rpm.RPMTAG_EPOCH] != None:
        return "%s-%s:%s-%s.%s" % (hdr[rpm.RPMTAG_NAME], hdr[rpm.RPMTAG_EPOCH],
                                   hdr[rpm.RPMTAG_VERSION],
                                   hdr[rpm.RPMTAG_RELEASE],
                                   hdr[rpm.RPMTAG_ARCH])
    else:
        return "%s-%s-%s.%s" % (hdr[rpm.RPMTAG_NAME],
                                hdr[rpm.RPMTAG_VERSION],
                                hdr[rpm.RPMTAG_RELEASE], hdr[rpm.RPMTAG_ARCH])

# ----------------------------------------------------------------------------

def get_hdr(name):
    hdr = [ ]
    if os.path.isfile(name):
        fdno = os.open(name, os.O_RDONLY)
        try:
            h = ts.hdrFromFdno(fdno)
        except rpm.error:
            fdno = os.open(name, os.O_RDONLY)
            ts.setVSFlags(rpm._RPMVSF_NOSIGNATURES)
            try:
                h = ts.hdrFromFdno(fdno)
            except:
                pass
            else:
                hdr.append(h)
        else:
            hdr.append(h)
        os.close(fdno)
    else:
        if no_installed == 0:
            mi = ts.dbMatch("name", name)
            for h in mi:
                hdr.append(h)
    return hdr

# ----------------------------------------------------------------------------

class RPM:
    def __init__(self, name, hdr):
        self.clear()
        self.set(name, hdr)
    def clear(self):
        self.p_file = ""
        self.p_name = ""
        self.p_epoch = ""
        self.p_version = ""
        self.p_release = ""
        self.p_arch = ""
        self.p_provides = [ ]
        self.p_requires = [ ]
        self.p_resolved = [ ]
        self.p_unresolved = [ ]
        self.p_filenames = [ ]
        self.p_installed = 0
    def set(self, name, hdr):
        self.p_file = name
        self.p_name = hdr[rpm.RPMTAG_NAME]
        if hdr[rpm.RPMTAG_EPOCH] != None:
            self.p_epoch = hdr[rpm.RPMTAG_EPOCH]
        else:
            self.p_epoch = ""
        self.p_version = hdr[rpm.RPMTAG_VERSION]
        self.p_release = hdr[rpm.RPMTAG_RELEASE]
        self.p_arch = hdr[rpm.RPMTAG_ARCH]
        self.p_filenames = hdr[rpm.RPMTAG_FILENAMES]

        for i in xrange(len(hdr[rpm.RPMTAG_PROVIDES])):
            p = hdr[rpm.RPMTAG_PROVIDES][i]
            flag = gen_operator(hdr[rpm.RPMTAG_PROVIDEFLAGS][i])
            version = hdr[rpm.RPMTAG_PROVIDEVERSION][i]
            self.p_provides.append((p, flag, version))
            
        for i in xrange(len(hdr[rpm.RPMTAG_REQUIRES])):
            flag = gen_operator(hdr[rpm.RPMTAG_REQUIREFLAGS][i])
            version = hdr[rpm.RPMTAG_REQUIREVERSION][i]

            p = (hdr[rpm.RPMTAG_REQUIRES][i], flag, version)

            try:
                self.p_requires.index(p)
            except:
                pass
            else:
                continue

            self.p_requires.append(p)
            if p[0][0:6] == "rpmlib":
                continue
            self.p_unresolved.append(p)

        try:
            self.p_installed = int(int(hdr[rpm.RPMTAG_INSTALLTID]) > 0)
        except:
            self.p_installed = 0

    def __str__(self):
        if self.p_epoch != "":
            return "%s-%s:%s-%s.%s" % (self.p_name, self.p_epoch,
                                       self.p_version, self.p_release,
                                       self.p_arch)
        else:
            return "%s-%s-%s.%s" % (self.p_name, self.p_version,
                                    self.p_release, self.p_arch)

# ----------------------------------------------------------------------------

class Provides:
    def __init__(self):
        self.clear()
    def clear(self):
        self.p_provide = { }
    def append(self, name, flag, version, rpm):
        if not self.p_provide.has_key(name):
            self.p_provide[name] = [ ]
        self.p_provide[name].append((version, rpm))
    def search(self, name, flag, version):
        if not self.p_provide.has_key(name):
            return None

        ret = [ ]
        for p in self.p_provide[name]:
            if version == "":
                ret.append(p[1])
            else:
                if evr_compare(p[0], flag, version) == 1:
                    ret.append(p[1])
                if evr_compare(gen_evr(p[1].p_epoch, p[1].p_version,
                                       p[1].p_release), flag, version) == 1:
                    ret.append(p[1])
        if len(ret) > 0:
            return ret
        return None

# ----------------------------------------------------------------------------

class Filenames:
    def __init__(self):
        self.clear()
    def clear(self):
        self.p_provide = { }
    def append(self, name, rpm):
        if not self.p_provide.has_key(name):
            self.p_provide[name] = [ ]
        self.p_provide[name].append(rpm)
    def search(self, name):
        if not self.p_provide.has_key(name):
            return None
        return self.p_provide[name]

# ----------------------------------------------------------------------------

def search_installed(name, flag, version):
    ret = [ ]

    mi = ts.dbMatch(rpm.RPMTAG_PROVIDES, name)
    for h in mi:
        res = 1
        if version != "": # version requirement
            for k in xrange(len(h[rpm.RPMTAG_PROVIDES])):
                if h[rpm.RPMTAG_PROVIDES][k] != name:
                    continue
                res = evr_compare(h[rpm.RPMTAG_PROVIDEVERSION][k],
                                  flag, version)

            if res != 1:
                res = evr_compare(gen_evr(h[rpm.RPMTAG_EPOCH],
                                          h[rpm.RPMTAG_VERSION],
                                          h[rpm.RPMTAG_RELEASE]),
                                  flag, version)
        if res == 1:
            r = RPM(h[rpm.RPMTAG_NAME], h)
            rpms.append(r)
            for p in r.p_provides:
                provides.append(p[0], p[1], p[2], r)
            for f in r.p_filenames:
                filenames.append(f, r)
            ret.append(r)

    if len(ret) == 0:
        mi = ts.dbMatch(rpm.RPMTAG_BASENAMES, name)
        for h in mi:
            res = 1
            if u[2] != "": # version requirement
                res = evr_compare(gen_evr(h[rpm.RPMTAG_EPOCH],
                                          h[rpm.RPMTAG_VERSION],
                                          h[rpm.RPMTAG_RELEASE]),
                                  flag, version)
            if res == 1:
                r = RPM(h[rpm.RPMTAG_NAME], h)
                rpms.append(r)
                for p in r.p_provides:
                    provides.append(p[0], p[1], p[2], r)
                for f in r.p_filenames:
                    filenames.append(f, r)
                ret.append(r)

    if len(ret) > 0:
        return ret
    return None

# ----------------------------------------------------------------------------

def usage():
    print """Usage: %s [-v[v]] [-nr] [-sd] [<rpm name/package>...]

  -h  | --help                print help
  -v  | --verbose             be verbose, and more, ..
  -ni | --no-installed        do not check against installed packages
  -ie | --ignore-epoch        ignore epoch in provides and requires

This program prints a treee for package dependencies.
The asterisc in the listing is shown after dependencies, which are resolved in
a tree before. 

""" % sys.argv[0]

# ----------------------------------------------------------------------------

rpms = [ ]

no_installed = 0
ignore_epoch = 0
verbose = 0

#ts = rpm.ts()
ts = ts = rpm.TransactionSet("", rpm._RPMVSF_NOSIGNATURES or \
    rpm.RPMVSF_NOHDRCHK or rpm._RPMVSF_NODIGESTS or rpm.RPMVSF_NEEDPAYLOAD)
ts.setVSFlags(-1)               # disable verify

if __name__ == '__main__':
    if len(sys.argv) == 1:
        usage()
        sys.exit(0)

    list = { }
    for i in xrange(1, len(sys.argv)):
        if sys.argv[i] == "-h" or sys.argv[i] == "--help":
            usage()
            sys.exit(0)
        elif sys.argv[i][:2] == "-v":
            j = 1
            while j < len(sys.argv[i]) and sys.argv[i][j] == "v":
                verbose += 1
                j += 1
        elif sys.argv[i] == "--verbose":
            verbose += 1
        elif sys.argv[i] == "-ni"or sys.argv[i] == "--no-installed":
            no_installed = 1
        elif sys.argv[i] == "-ie"or sys.argv[i] == "--ignore-epoch":
            ignore_epoch = 1
        else:
            hdr = get_hdr(sys.argv[i])
            for j in xrange(len(hdr)):
                s = hdr_str(hdr[j])
                if not list.has_key(s):
                    list[s] = 1
                    if verbose > 0:
                        sys.stdout.write("\rReading %d" % (len(rpms)+1))
                        sys.stdout.flush()
                    rpms.append(RPM(sys.argv[i], hdr[j]))
    list = { }
    if verbose > 0 and len(rpms) > 0:
        print

    # -- processing

    if verbose == 0:
        print "Processing"

    provides = Provides()
    filenames = Filenames()

    for i in xrange(len(rpms)):
        if verbose > 0:
            sys.stdout.write("\rProcessing [%d/%d]" % (i+1, len(rpms)))
            sys.stdout.flush()
        for p in rpms[i].p_provides:
            provides.append(p[0], p[1], p[2], rpms[i])
        for f in rpms[i].p_filenames:
            filenames.append(f, rpms[i])
    if verbose > 0 and len(rpms) > 0:
        print

    # -- resolving provides

    if verbose == 0:
        print "Resolving"

    i = 0
    while i < len(rpms):
        r = rpms[i]
        if verbose > 0:
            sys.stdout.write("\rResolving [%d/%d]" % (i+1, len(rpms)))
            sys.stdout.flush()
        j = 0
        while j < len(r.p_unresolved):
            u = r.p_unresolved[j]
            s = provides.search(u[0], u[1], u[2])
            if s == None:
                s = filenames.search(u[0])
            if s == None and no_installed == 0:
                s = search_installed(u[0], u[1], u[2])
            if s != None:
                r.p_unresolved.remove(u)
                r.p_resolved.append((u, s))
            else:
                j += 1            
        i += 1
    if verbose > 0 and len(rpms) > 0:
        print

    # -- print unresolved

    unresolved = 0
    for r in rpms:
        if len(r.p_unresolved) > 0:
            print "\nERROR: %s unresolved dependencies:" % str(r)
            for u in r.p_unresolved:
                print "\t%s %s %s" % (u[0], u[1], u[2])
            unresolved = 1

    if unresolved == 1:
        sys.exit(-1)

    # -- print verbose output

    if verbose > 1:
        print
    for r in rpms:
        if verbose > 1 and len(r.p_resolved) > 0:
            name = "%s-%s-%s.%s" % (r.p_name, r.p_version, r.p_release,
                                    r.p_arch)
            if r.p_installed == 0 and verbose > 1:
                name += ": %s" % r.p_file
            print "\n%s" % name

        if verbose > 1:
            # resolved dependencies
            list = [ ]
            for j in xrange(len(r.p_resolved)):
                r2 = r.p_resolved[j]
                dep = r2[0][0]
                pkgs = ""
                if verbose > 2:
                    list = [ ]
                for rpm in r2[1]:
                    p = "%s-%s-%s.%s" % (rpm.p_name, rpm.p_version,
                                         rpm.p_release, rpm.p_arch)
                    if p not in list:
                        list.append(p)
                        if pkgs != "": pkgs += ", "
                        pkgs += p
                if verbose > 2:
                    if r2[0][2] != "":
                        dep = "%s %s %s" % (r2[0][0], r2[0][1], r2[0][2])
                    print "\t%s --> %s" % (dep, pkgs)
            if verbose == 2:
                list.sort()
                for pkg in list:
                    print "\t%s" % pkg

    if len(rpms) > 0:
        print "\n-- DONE --"
    
    sys.exit(0)
