#!/usr/bin/python
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published by
# the Free Software Foundation; version 2 only
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2004, 2005 Red Hat, Inc.
#
# Author: Phil Knirsch
#

import sys, os

PYRPMDIR = ".."
if not PYRPMDIR in sys.path:
    sys.path.append(PYRPMDIR)
from pyrpm import __version__
from pyrpm import *
from pyrpm.yum.yum  import RpmYum

def usage():
    print """
    pyrpmcheckrepo [options] install [dirs | regex] update [repo] [dirs | regex]

    The dirs and regex following the install command will be used to simulate
    the original installed system.
    The first option following the update command can be a repo, rest is the
    same as for install.

options:
    [-?, --help] [--version]
    [--quiet] [-v, --verbose] [-y]
    [-c CONFIGFILE] [--dbpath DIRECTORY] [-r, --root DIRECTORY]
    [-h, --hash] [--force] [--oldpackage] [--justdb] [--test]
    [--ignoresize] [--ignorearch] [--exactarch]
    [--noconflicts] [--fileconflicts]
    [--nodeps] [--signature]
    [--noorder] [--noscripts] [--notriggers]
    [--autoerase] [--installpkgs="pkg1 pkg2 pkg2 ..."]
    [--enablerepo=repoid|repoglob] [--disablerepo=repoid|repoglob]

Warning: Some of the options are not evaluated yet"""


def list2dict(l, fn=None):
    d = {}
    if fn:
        for e in l:
            k, v = fn(e)
            d[k] = v
    
    for e in l:
        d[e] = None
    return d

def tuples2dict(l):
    d = {}
    for k, v in l:
        d[k] = v
    return d

def addlist2dict(d, l):
    for e in l:
        d[e] = None

def diff(d1, d2):
    d = d1.copy()
    for e in d2:
        if d.has_key(e):
            del d[e]
    return d

def sum(d1, d2):
    d = d1.copy()
    d.update(d2)
    return d2

def print_results(install, installed, update, updated):
    install = tuples2dict([(p.getNEVRA(), p) for p in install])
    installed = tuples2dict([(p.getNEVRA(), p) for p in installed])
    update = tuples2dict([(p.getNEVRA(), p) for p in update])
    updated = tuples2dict([(p.getNEVRA(), p) for p in updated])

    not_installed = diff(install, installed)
    leftover = diff(installed, updated)
    not_updated = diff(update, updated)

    print "Not installed:"
    for p in not_installed:
        print "\t%s" % p
    print "Leftover:"
    for p in leftover:
        print "\t%s" % p
    print "Not installed updates:"
    for p in not_updated:
        print "\t%s" % p


#
# Main program
#
def main():
    # Our yum worker object
    yum = RpmYum(rpmconfig)

    # Disabled fileconflicts per default in yum
    rpmconfig.nofileconflicts = 1

    # Default is to be a little verbose.
    rpmconfig.verbose = -1
    rpmconfig.debug = -1
    rpmconfig.warning = -1

    # We always do run in test mode
    rpmconfig.test = 1

    # No default repo
    rpmconfig.yumconf = ['/etc/nosuchconf']

    # Don't do any diskchecks
    rpmconfig.ignoresize = 1

    # Do autoerase by default
    yum.setAutoerase(1)

    # Don't ask if we really want to do this
    yum.setConfirm(0)

    # Argument parsing
    args = parseYumOptions(sys.argv[1:], yum)
    if not args:
        usage()
        return 0

    if args[0] != "install":
        print "No install command found."
        usage()
        return 0

    for pos in xrange(len(args)):
        if args[pos] == "update":
            break
    else:
        print "No update command found."
        usage()
        return 0

    instargs = args[1:pos]
    upargs = args[pos+1:]

    if os.path.isfile(upargs[0]) and not upargs[0].endswith(".rpm"):
        rpmconfig.yumconf = [upargs[0]]
        upargs = upargs[1:]

    yum.setCommand("update")
    db = database.memorydb.RpmMemoryDB("", None)
    if yum.prepareTransaction(db) == 0:
        return 0
    if yum.runArgs(instargs) == 0:
        return 0
    if yum.runDepRes() == 0:
        return 0
    if yum.runCommand() == 0:
        return 0

    # all packages from the cmd line
    install = {}
    for repo in yum.repos:
        addlist2dict(install, repo.getPkgs())
    # the packages that really got installed
    #  some arch trans compatible or broken pkgs might be missing
    installed = yum.opresolver.getDatabase().getPkgs()
    for pkg in installed:
        # Error checking is not really necessary, what could go wrong?
        yum.pydb.addPkg(pkg, 1)

    not_installed = diff(install, installed)

    yum.opresolver = RpmResolver(rpmconfig, yum.pydb)
    yum.repos = []
    if yum.runArgs(upargs) == 0:
        return 0
    if yum.runDepRes() == 0:
        return 0
    if yum.runCommand() == 0:
        return 0
    resolver = yum.opresolver

    update = {}
    for repo in yum.repos:
        addlist2dict(update, repo.getPkgs())        

    updated = resolver.getDatabase().getPkgs()
    
    print_results(install, installed, update, updated)
    return 1

if __name__ == '__main__':
    if not run_main(main):
        sys.exit(1)

# vim:ts=4:sw=4:showmatch:expandtab
