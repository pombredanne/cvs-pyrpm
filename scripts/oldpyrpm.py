#!/usr/bin/python
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published by
# the Free Software Foundation; version 2 only
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2004, 2005 Red Hat, Inc.
#
# Author: Paul Nasrat, Florian La Roche, Phil Knirsch
#

#
# Read .rpm packages from python. Implemented completely in python without
# using the rpmlib C library. Extensive checks have been added and this
# script can be used to check the binary packages for unusual format/content.
#
# Possible options:
# "--strict" should only be used for the Fedora Core development tree
# "--nodigest" to skip sha1/md5sum check for header+payload
# "--nopayload" to not read in the compressed filedata (payload)
#
# Example usage:
# find /mirror/ -name "*.rpm" -type f -print0 2>/dev/null \
#         | xargs -0 ./oldpyrpm.py [--nodigest --nopayload]
# locate '*.rpm' | xargs ./oldpyrpm.py [--nodigest --nopayload]
# ./oldpyrpm.py --strict [--nodigest --nopayload] \
#         /mirror/fedora/development/i386/Fedora/RPMS/*.rpm
#

#
# XXX TODO:
# - evrSplit(): 'epoch = ""' would make a distinction between missing
#   and "0" epoch (change this for createrepo)
# - how to check some content for correct utf-8 encoding?
# - check for #% in spec files
# - streaming read for cpio files
# things that look less important to implement:
# - relocatable rpm packages
# - add streaming support to bzip2 compressed payload
# - lua scripting support
# possible rpm format changes:
# - Deps could be left away from src.rpms.
# - "cookie" could go away, the same info is already present.
# - "rhnplatform" could go away if it is not required.
# - Can hardlinks go into a new rpm tag? (does not gain much)
# - Can requires for the same rpm be deleted from the rpm tag header?
#   Would this disturb any other existing dep solver?
# - Improve perl autogenerated "Provides:"
#

import os, os.path, sys, md5, sha, pwd, grp, zlib, re, time
from struct import unpack

# optimized routines instead of:
#from stat import S_ISREG, S_ISLNK, S_ISDIR
def S_ISREG(mode):
    return (mode & 0170000) == 0100000
def S_ISLNK(mode):
    return (mode & 0170000) == 0120000
def S_ISDIR(mode):
    return (mode & 0170000) == 0040000


def doRead(fd, size):
    data = fd.read(size)
    if len(data) != size:
        raise IOError, "failed to read data (%d instead of %d)" \
            % (len(data), size)
    return data


# Optimized routines that use zlib to extract data, since
# "import gzip" doesn't give good data handling (old code
# can still easily be enabled to compare performance):

(FTEXT, FHCRC, FEXTRA, FNAME, FCOMMENT) = (1, 2, 4, 8, 16)
class PyGZIP:
    def __init__(self, fd):
        self.fd = fd
        self.decompobj = zlib.decompressobj(-zlib.MAX_WBITS)
        self.crcval = zlib.crc32("")
        self.length = 0
        self.buffer = []
        self.bufferlen = 0
        self.pos = 0
        self.enddata = ""
        self.header_read = 0

    def __readHeader(self):
        if self.fd.read(2) != "\037\213":
            print "Not a gzipped file"
            sys.exit(0)
        if ord(self.fd.read(1)) != 8:
            print "Unknown compression method"
            sys.exit(0)
        flag = ord(self.fd.read(1))
        self.fd.read(4+1+1) # Discard modification time, extra flags, OS byte
        if flag & FEXTRA:
            # Read & discard the extra field, if present
            xlen = ord(self.fd.read(1))
            xlen += 256 * ord(self.fd.read(1))
            self.fd.read(xlen)
        if flag & FNAME:
            # Read and discard a nul-terminated string containing the filename
            while 1:
                if self.fd.read(1) == "\000":
                    break
        if flag & FCOMMENT:
            # Read and discard a nul-terminated string containing a comment
            while 1:
                if self.fd.read(1) == "\000":
                    break
        if flag & FHCRC:
            self.fd.read(2)      # Read & discard the 16-bit header CRC
        self.decompobj = zlib.decompressobj(-zlib.MAX_WBITS)
        self.crcval = zlib.crc32("")
        self.header_read = 1

    def read(self, bytes=None):
        if not self.header_read:
            self.__readHeader()
        data = ""
        size = 2048
        while bytes == None or self.bufferlen < bytes:
            if len(data) >= 8:
                self.enddata = data[-8:]
            else:
                self.enddata = self.enddata[:8-len(data)] + data
            size = bytes - self.bufferlen
            if size > 65536:
                size = 32768
            elif size > 32768:
                size = 16384
            elif size > 16384:
                size = 8192
            elif size > 8192:
                size = 4096
            elif size > 4096:
                size = 2048
            else:
                size = 1024
            data = self.fd.read(size)
            if data == "":
            # We've read to the end of the file, so we have to take the last 8
            # bytes from the buffer containing the CRC and the file size.  The
            # decompressor is smart and knows when to stop, so feeding it
            # extra data is harmless.
                crc32 = unpack("!I", self.enddata[0:4])
                isize = unpack("!I", self.enddata[4:8])
                if crc32 != self.crcval:
                    print "CRC check failed."
                if isize != self.length:
                    print "Incorrect length of data produced"
                break
            decompdata = self.decompobj.decompress(data)
            decomplen = len(decompdata)
            self.buffer.append(decompdata)
            self.bufferlen += decomplen
            self.length += decomplen
            self.crcval = zlib.crc32(decompdata, self.crcval)
        if bytes == None or self.bufferlen <  bytes:
            decompdata = self.decompobj.flush()
            decomplen = len(decompdata)
            self.buffer.append(decompdata)
            self.bufferlen += decomplen
            self.length = self.length + decomplen
            self.crcval = zlib.crc32(decompdata, self.crcval)
        if bytes == None:
            bytes = self.length
        retdata = ""
        while bytes > 0:
            decompdata = self.buffer[0]
            decomplen = len(decompdata)
            if bytes+self.pos <= decomplen:
                tmpdata = decompdata[self.pos:bytes+self.pos]
                retdata += tmpdata
                #self.buffer[0] = decompdata[bytes:]
                self.bufferlen -= bytes
                self.pos += bytes
                break
            decomplen -= self.pos
            bytes -= decomplen
            self.bufferlen -= decomplen
            if self.pos != 0:
                retdata += decompdata[self.pos:]
            else:
                retdata += decompdata
            self.pos = 0
            self.buffer.pop(0)
        return retdata


# rpm tag types
#RPM_NULL = 0
RPM_CHAR = 1
RPM_INT8 = 2
RPM_INT16 = 3
RPM_INT32 = 4
RPM_INT64 = 5 # currently unused
RPM_STRING = 6
RPM_BIN = 7
RPM_STRING_ARRAY = 8
RPM_I18NSTRING = 9
# new types internal to this tool:
# RPM_STRING_ARRAY for app + params, otherwise a single RPM_STRING
RPM_ARGSTRING = 12
RPM_GROUP = 13

# RPMSENSEFLAGS
RPMSENSE_ANY        = 0
RPMSENSE_SERIAL     = (1 << 0)          # legacy
RPMSENSE_LESS       = (1 << 1)
RPMSENSE_GREATER    = (1 << 2)
RPMSENSE_EQUAL      = (1 << 3)
RPMSENSE_PROVIDES   = (1 << 4)          # only used internally by builds
RPMSENSE_CONFLICTS  = (1 << 5)          # only used internally by builds
RPMSENSE_PREREQ     = (1 << 6)          # legacy
RPMSENSE_OBSOLETES  = (1 << 7)          # only used internally by builds
RPMSENSE_INTERP     = (1 << 8)          # Interpreter used by scriptlet.
RPMSENSE_SCRIPT_PRE = ((1 << 9) | RPMSENSE_PREREQ)      # %pre dependency
RPMSENSE_SCRIPT_POST = ((1 << 10)|RPMSENSE_PREREQ)      # %post dependency
RPMSENSE_SCRIPT_PREUN = ((1 << 11)|RPMSENSE_PREREQ)     # %preun dependency
RPMSENSE_SCRIPT_POSTUN = ((1 << 12)|RPMSENSE_PREREQ)    # %postun dependency
RPMSENSE_SCRIPT_VERIFY = (1 << 13)      # %verify dependency
RPMSENSE_FIND_REQUIRES = (1 << 14)      # find-requires generated dependency
RPMSENSE_FIND_PROVIDES = (1 << 15)      # find-provides generated dependency
RPMSENSE_TRIGGERIN  = (1 << 16)         # %triggerin dependency
RPMSENSE_TRIGGERUN  = (1 << 17)         # %triggerun dependency
RPMSENSE_TRIGGERPOSTUN = (1 << 18)      # %triggerpostun dependency
RPMSENSE_MISSINGOK  = (1 << 19)         # suggests/enhances/recommends hint
RPMSENSE_SCRIPT_PREP = (1 << 20)        # %prep build dependency
RPMSENSE_SCRIPT_BUILD = (1 << 21)       # %build build dependency
RPMSENSE_SCRIPT_INSTALL = (1 << 22)     # %install build dependency
RPMSENSE_SCRIPT_CLEAN = (1 << 23)       # %clean build dependency
RPMSENSE_RPMLIB     = ((1 << 24) | RPMSENSE_PREREQ) # rpmlib(feature) dependency
RPMSENSE_TRIGGERPREIN = (1 << 25)       # @todo Implement %triggerprein
RPMSENSE_KEYRING    = (1 << 26)
RPMSENSE_PATCHES    = (1 << 27)
RPMSENSE_CONFIG     = (1 << 28)

RPMSENSE_SENSEMASK  = 15 # Mask to get senses: serial, less, greater, equal.

# RPM file attributes
RPMFILE_NONE        = 0
RPMFILE_CONFIG      = (1 <<  0)    # from %%config
RPMFILE_DOC         = (1 <<  1)    # from %%doc
RPMFILE_ICON        = (1 <<  2)    # from %%donotuse.
RPMFILE_MISSINGOK   = (1 <<  3)    # from %%config(missingok)
RPMFILE_NOREPLACE   = (1 <<  4)    # from %%config(noreplace)
RPMFILE_SPECFILE    = (1 <<  5)    # .spec file in source rpm
RPMFILE_GHOST       = (1 <<  6)    # from %%ghost
RPMFILE_LICENSE     = (1 <<  7)    # from %%license
RPMFILE_README      = (1 <<  8)    # from %%readme
RPMFILE_EXCLUDE     = (1 <<  9)    # from %%exclude, internal
RPMFILE_UNPATCHED   = (1 << 10)    # placeholder (SuSE)
RPMFILE_PUBKEY      = (1 << 11)    # from %%pubkey
RPMFILE_POLICY      = (1 << 12)    # from %%policy


# List of all rpm tags we care about. We mark older tags which are
# not anymore in newer rpm packages (Fedora Core development tree) as
# "legacy".
# tagname: (tag, type, how-many, flags:legacy=1,src-only=2,bin-only=4)
rpmtag = {
    # basic info
    "name": [1000, RPM_STRING, None, 0],
    "epoch": [1003, RPM_INT32, 1, 0],
    "version": [1001, RPM_STRING, None, 0],
    "release": [1002, RPM_STRING, None, 0],
    "arch": [1022, RPM_STRING, None, 0],

    # dependencies: provides, requires, obsoletes, conflicts
    "providename": [1047, RPM_STRING_ARRAY, None, 0],
    "provideflags": [1112, RPM_INT32, None, 0],
    "provideversion": [1113, RPM_STRING_ARRAY, None, 0],
    "requirename": [1049, RPM_STRING_ARRAY, None, 0],
    "requireflags": [1048, RPM_INT32, None, 0],
    "requireversion": [1050, RPM_STRING_ARRAY, None, 0],
    "obsoletename": [1090, RPM_STRING_ARRAY, None, 4],
    "obsoleteflags": [1114, RPM_INT32, None, 4],
    "obsoleteversion": [1115, RPM_STRING_ARRAY, None, 4],
    "conflictname": [1054, RPM_STRING_ARRAY, None, 0],
    "conflictflags": [1053, RPM_INT32, None, 0],
    "conflictversion": [1055, RPM_STRING_ARRAY, None, 0],
    # triggers
    "triggername": [1066, RPM_STRING_ARRAY, None, 4],
    "triggerflags": [1068, RPM_INT32, None, 4],
    "triggerversion": [1067, RPM_STRING_ARRAY, None, 4],
    "triggerscripts": [1065, RPM_STRING_ARRAY, None, 4],
    "triggerscriptprog": [1092, RPM_STRING_ARRAY, None, 4],
    "triggerindex": [1069, RPM_INT32, None, 4],

    # scripts
    "prein": [1023, RPM_STRING, None, 4],
    "preinprog": [1085, RPM_ARGSTRING, None, 4],
    "postin": [1024, RPM_STRING, None, 4],
    "postinprog": [1086, RPM_ARGSTRING, None, 4],
    "preun": [1025, RPM_STRING, None, 4],
    "preunprog": [1087, RPM_ARGSTRING, None, 4],
    "postun": [1026, RPM_STRING, None, 4],
    "postunprog": [1088, RPM_ARGSTRING, None, 4],
    "verifyscript": [1079, RPM_STRING, None, 4],
    "verifyscriptprog": [1091, RPM_ARGSTRING, None, 4],

    # addon information:
    "rpmversion": [1064, RPM_STRING, None, 0],
    "payloadformat": [1124, RPM_STRING, None, 0],   # "cpio"
    "payloadcompressor": [1125, RPM_STRING, None, 0],# "gzip" or "bzip2"
    "i18ntable": [100, RPM_STRING_ARRAY, None, 0], # list of available langs
    "summary": [1004, RPM_I18NSTRING, None, 0],
    "description": [1005, RPM_I18NSTRING, None, 0],
    "url": [1020, RPM_STRING, None, 0],
    "license": [1014, RPM_STRING, None, 0],
    "sourcerpm": [1044, RPM_STRING, None, 4], # name of src.rpm for binary rpms
    "changelogtime": [1080, RPM_INT32, None, 0],
    "changelogname": [1081, RPM_STRING_ARRAY, None, 0],
    "changelogtext": [1082, RPM_STRING_ARRAY, None, 0],
    "prefixes": [1098, RPM_STRING_ARRAY, None, 4], # relocatable rpm packages
    "optflags": [1122, RPM_STRING, None, 4], # optimization flags for gcc
    "pubkeys": [266, RPM_STRING_ARRAY, None, 4],
    "sourcepkgid": [1146, RPM_BIN, 16, 4], # md5 from srpm (header+payload)
    "immutable": [63, RPM_BIN, 16, 0], # content of this tag is unclear
    # less important information:
    "buildtime": [1006, RPM_INT32, 1, 0], # time of rpm build
    "buildhost": [1007, RPM_STRING, None, 0], # hostname where rpm was built
    "cookie": [1094, RPM_STRING, None, 0], # build host and time
    "group": [1016, RPM_GROUP, None, 0], # comps.xml is used now
    "size": [1009, RPM_INT32, 1, 0],                # sum of all file sizes
    "distribution": [1010, RPM_STRING, None, 0],
    "vendor": [1011, RPM_STRING, None, 0],
    "packager": [1015, RPM_STRING, None, 0],
    "os": [1021, RPM_STRING, None, 0],              # always "linux"
    "payloadflags": [1126, RPM_STRING, None, 0],    # "9"
    "rhnplatform": [1131, RPM_STRING, None, 4],     # == arch
    "platform": [1132, RPM_STRING, None, 0],

    # rpm source packages:
    "source": [1018, RPM_STRING_ARRAY, None, 2],
    "patch": [1019, RPM_STRING_ARRAY, None, 2],
    "buildarchs": [1089, RPM_STRING_ARRAY, None, 2],
    "excludearch": [1059, RPM_STRING_ARRAY, None, 2],
    "exclusivearch": [1061, RPM_STRING_ARRAY, None, 2],
    "exclusiveos": [1062, RPM_STRING_ARRAY, None, 2], # ["Linux"] or ["linux"]

    # information about files
    "dirindexes": [1116, RPM_INT32, None, 0],
    "dirnames": [1118, RPM_STRING_ARRAY, None, 0],
    "basenames": [1117, RPM_STRING_ARRAY, None, 0],
    "fileusername": [1039, RPM_STRING_ARRAY, None, 0],
    "filegroupname": [1040, RPM_STRING_ARRAY, None, 0],
    "filemodes": [1030, RPM_INT16, None, 0],
    "filemtimes": [1034, RPM_INT32, None, 0],
    "filedevices": [1095, RPM_INT32, None, 0],
    "fileinodes": [1096, RPM_INT32, None, 0],
    "filesizes": [1028, RPM_INT32, None, 0],
    "filemd5s": [1035, RPM_STRING_ARRAY, None, 0],
    "filerdevs": [1033, RPM_INT16, None, 0],
    "filelinktos": [1036, RPM_STRING_ARRAY, None, 0],
    "fileflags": [1037, RPM_INT32, None, 0],
    # less common used data:
    "fileverifyflags": [1045, RPM_INT32, None, 0],
    "filelangs": [1097, RPM_STRING_ARRAY, None, 0],
    "filecolors": [1140, RPM_INT32, None, 0],
    "fileclass": [1141, RPM_INT32, None, 0],
    "filedependsx": [1143, RPM_INT32, None, 0],
    "filedependsn": [1144, RPM_INT32, None, 0],
    "classdict": [1142, RPM_STRING_ARRAY, None, 0],
    "dependsdict": [1145, RPM_INT32, None, 0],
    # data from files marked with "%policy" in specfiles
    "policies": [1150, RPM_STRING_ARRAY, None, 0],
    # XXX: this tag shows up again, disable the check for now:
    "filecontexts": [1147, RPM_STRING_ARRAY, None, 0], # selinux filecontexts

    # tags not in Fedora Core development trees anymore:
    "capability": [1105, RPM_INT32, None, 1],
    "xpm": [1013, RPM_BIN, None, 1],
    "gif": [1012, RPM_BIN, None, 1],
    # bogus RHL5.2 data in XFree86-libs, ash, pdksh
    "verifyscript2": [15, RPM_STRING, None, 1],
    "nosource": [1051, RPM_INT32, None, 1],
    "nopatch": [1052, RPM_INT32, None, 1],
    "disturl": [1123, RPM_STRING, None, 1],
    "oldfilenames": [1027, RPM_STRING_ARRAY, None, 1],
    "archivesize": [1046, RPM_INT32, 1, 1], # only in /var/lib/rpm/Packages
    "triggerin": [1100, RPM_STRING, None, 5],
    "triggerun": [1101, RPM_STRING, None, 5],
    "triggerpostun": [1102, RPM_STRING, None, 5]
}
# Add a reverse mapping for all tags plus the name again.
for v in rpmtag.keys():
    rpmtag[v].append(v)
for v in rpmtag.values():
    rpmtag[v[0]] = v
    if len(v) != 5:
        raise ValueError, "rpmtag has wrong entries"
del v

# Required tags in a header.
rpmtagrequired = ("name", "version", "release", "arch", "rpmversion")

importanttags = {"name":1, "epoch":1, "version":1, "release":1,
    "arch":1, "rpmversion":1, "sourcerpm":1, "payloadcompressor":1,
    "payloadformat":1,
    "providename":1, "provideflags":1, "provideversion":1,
    "requirename":1, "requireflags":1, "requireversion":1,
    "obsoletename":1, "obsoleteflags":1, "obsoleteversion":1,
    "conflictname":1, "conflictflags":1, "conflictversion":1,
    "triggername":1, "triggerflags":1, "triggerversion":1,
    "triggerscripts":1, "triggerscriptprog":1, "triggerindex":1,
    "prein":1, "preinprog":1, "postin":1, "postinprog":1,
    "preun":1, "preunprog":1, "postun":1, "postunprog":1,
    "verifyscript":1, "verifyscriptprog":1,
    "oldfilenames":1, "dirindexes":1, "dirnames":1, "basenames":1,
    "fileusername":1, "filegroupname":1, "filemodes":1,
    "filemtimes":1, "filedevices":1, "fileinodes":1, "filesizes":1,
    "filemd5s":1, "filerdevs":1, "filelinktos":1, "fileflags":1}


# Info within the sig header.
rpmsigtag = {
    # size of gpg/dsaheader sums differ between 64/65(contains "\n")
    "dsaheader": [267, RPM_BIN, None, 0], # only about header
    "gpg": [1005, RPM_BIN, None, 0], # header+payload
    "header_signatures": [62, RPM_BIN, 16, 0], # content of this tag is unclear
    "payloadsize": [1007, RPM_INT32, 1, 0],
    "size_in_sig": [1000, RPM_INT32, 1, 0],
    "sha1header": [269, RPM_STRING, None, 0],
    "md5": [1004, RPM_BIN, 16, 0],
    # legacy entries in older rpm packages:
    "pgp": [1002, RPM_BIN, None, 1],
    "badsha1_1": [264, RPM_STRING, None, 1],
    "badsha1_2": [265, RPM_STRING, None, 1]
}
# Add a reverse mapping for all tags plus the name again.
for v in rpmsigtag.keys():
    rpmsigtag[v].append(v)
for v in rpmsigtag.values():
    rpmsigtag[v[0]] = v
    if len(v) != 5:
        raise ValueError, "rpmsigtag has wrong entries"
del v

# Required tags in a signature header.
rpmsigtagrequired = ("md5",)


# check arch names against this list
possible_archs = {"noarch":1, "i386":1, "i486":1, "i586":1, "i686":1,
    "athlon":1, "pentium3":1, "pentium4":1, "x86_64":1, "ia32e":1, "ia64":1,
    "alpha":1, "alphaev6":1, "axp":1, "sparc":1, "sparc64":1,
    "s390":1, "s390x":1, "ia64":1,
    "ppc":1, "ppc64":1, "ppc64iseries":1, "ppc64pseries":1, "ppcpseries":1,
    "ppciseries":1, "ppcmac":1, "ppc8260":1, "m68k":1,
    "arm":1, "armv4l":1, "mips":1, "mipseb":1, "mipsel":1, "hppa":1, "sh":1 }

possible_scripts = {
    None: 1,
    "/bin/sh": 1,
    "/sbin/ldconfig": 1,
    "/usr/bin/fc-cache": 1,
    "/usr/bin/scrollkeeper-update": 1,
    "/usr/sbin/build-locale-archive": 1,
    "/usr/sbin/glibc_post_upgrade": 1,
    "/usr/sbin/glibc_post_upgrade.i386": 1,
    "/usr/sbin/glibc_post_upgrade.i686": 1,
    "/usr/sbin/libgcc_post_upgrade": 1 }


# locale independend string methods
def _xisalpha(chr):
    return (chr >= 'a' and chr <= 'z') or (chr >= 'A' and chr <= 'Z')
def _xisdigit(chr):
    return chr >= '0' and chr <= '9'
def _xisalnum(chr):
    return (chr >= 'a' and chr <= 'z') or (chr >= 'A' and chr <= 'Z') \
        or (chr >= '0' and chr <= '9')

# compare two strings
def stringCompare(str1, str2):
    if str1 == str2: return 0
    lenstr1 = len(str1)
    lenstr2 = len(str2)
    if not lenstr1: return -1
    elif not lenstr2: return 1
    i1 = i2 = 0
    while i1 < lenstr1 and i2 < lenstr2:
        # remove leading separators
        while i1 < lenstr1 and not _xisalnum(str1[i1]): i1 += 1
        while i2 < lenstr2 and not _xisalnum(str2[i2]): i2 += 1
        j1 = i1
        j2 = i2
        # search for numbers and comprare them
        while j1 < lenstr1 and _xisdigit(str1[j1]): j1 += 1
        while j2 < lenstr2 and _xisdigit(str2[j2]): j2 += 1
        if j1 > i1 or j2 > i1:
            x = cmp(j1 - i1, j2 - i2)
            if x: return x
            while i1 < j1 and i2 < j2:
                x = cmp(ord(str1[i1]), ord(str2[i2]))
                if x: return x
                i1 += 1
                i2 += 1
            # found right side
            if i1 == lenstr1: return -1
            if i2 == lenstr2: return 1
        if i2 == lenstr2: return -1
        # search for alphas and compare them
        while j1 < lenstr1 and _xisalpha(str1[j1]): j1 += 1
        while j2 < lenstr2 and _xisalpha(str2[j2]): j2 += 1
        if j1 > i1 or j2 > i1:
            x = cmp(str1[i1:j1], str2[i2:j2])
            if x: return x
            # found right side
            i1 = j1
            i2 = j2
    # still no difference
    if i2 == lenstr2: return 0
    if i1 == lenstr1: return -1
    return 1


# internal EVR compare, uses stringCompare to compare epochs, versions and
# release versions
def labelCompare(e1, e2):
    if e2[2] == "": # no release
        e1 = (e1[0], e1[1], "")
    elif e1[2] == "": # no release
        e2 = (e2[0], e2[1], "")
    r = stringCompare(e1[0], e2[0])
    if r == 0:
        r = stringCompare(e1[1], e2[1])
        if r == 0:
            r = stringCompare(e1[2], e2[2])
    return r


def isCommentOnly(script):
    """Return 1 is script contains only empty lines or lines
    starting with '#'. """
    for line in script.split("\n"):
        line2 = line.strip()
        if line2 and line2[0] != "#":
            return 0
    return 1


def parseFile(filename):
    rethash = {}
    for l in open(filename, "r").readlines():
        tmp = l.split(":")
        rethash[tmp[0]] = int(tmp[2])
    return rethash

class UGid:
    """Store a list of user- and groupnames and transform them in uids/gids."""

    def __init__(self, names=None):
        self.ugid = {}
        if names:
            self.addUGids(names)

    def addUGids(self, names):
        # hack: building up a new array of names makes sure the string
        # is only stored once per uid/gid
        ids = []
        for name in names:
            if not self.ugid.has_key(name):
                self.ugid[name] = name
            ids.append(self.ugid[name])
        return ids

    def transform(self, chroot):
        pass

class Uid(UGid):
    def transform(self, chroot):
        # "uid=0" if no /etc/passwd exists at all.
        if not os.path.isfile(chroot + "/etc/passwd"):
            for uid in self.ugid.keys():
                self.ugid[uid] = 0
                if uid != "root":
                    print "warning: user %s not found, using uid 0" % uid
            return
        # Parse /etc/passwd if glibc is not yet installed.
        if chroot or not os.path.isfile(chroot + "/sbin/ldconfig"):
            uidhash = parseFile(chroot + "/etc/passwd")
            for uid in self.ugid.keys():
                if uidhash.has_key(uid):
                    self.ugid[uid] = uidhash[uid]
                else:
                    print "warning: user %s not found, using uid 0" % uid
                    self.ugid[uid] = 0
            return
        # Normal lookup of users via glibc.
        for uid in self.ugid.keys():
            if uid == "root":
                self.ugid[uid] = 0
            else:
                try:
                    self.ugid[uid] = pwd.getpwnam(uid)[2]
                except:
                    print "warning: user %s not found, using uid 0" % uid
                    self.ugid[uid] = 0

class Gid(UGid):
    def transform(self, chroot):
        # "gid=0" if no /etc/group exists at all.
        if not os.path.isfile(chroot + "/etc/group"):
            for gid in self.ugid.keys():
                self.ugid[gid] = 0
                if gid != "root":
                    print "warning: group %s not found, using gid 0" % gid
            return
        # Parse /etc/group if glibc is not yet installed.
        if chroot or not os.path.isfile(chroot + "/sbin/ldconfig"):
            gidhash = parseFile(chroot + "/etc/group")
            for gid in self.ugid.keys():
                if gidhash.has_key(gid):
                    self.ugid[gid] = gidhash[gid]
                else:
                    print "warning: group %s not found, using gid 0" % gid
                    self.ugid[gid] = 0
            return
        # Normal lookup of users via glibc.
        for gid in self.ugid.keys():
            if gid == "root":
                self.ugid[gid] = 0
            else:
                try:
                    self.ugid[gid] = grp.getgrnam(gid)[2]
                except:
                    print "warning: group %s not found, using gid 0" % gid
                    self.ugid[gid] = 0


class CPIO:
    """Read a cpio archive."""

    def __init__(self, fd, issrc, size=None, verify=None, strict=None):
        self.fd = fd
        self.issrc = issrc
        self.size = size
        self.verify = verify
        self.strict = strict

    def printErr(self, err):
        print "%s: %s" % ("cpio-header", err)

    def __readDataPad(self, size, pad=0):
        data = doRead(self.fd, size)
        pad = (4 - ((size + pad) % 4)) % 4
        doRead(self.fd, pad)
        if self.size != None:
            self.size -= size + pad
        return data

    def readEntry(self):
        # (magic, inode, mode, uid, gid, nlink, mtime, filesize,
        # devMajor, devMinor, rdevMajor, rdevMinor, namesize, checksum)
        data = doRead(self.fd, 110)
        if self.size != None:
            self.size -= 110
        # CPIO ASCII hex, expanded device numbers (070702 with CRC)
        if data[0:6] not in ("070701", "070702"):
            raise IOError, "Bad magic reading CPIO headers %s" % data[0:6]
        filename = self.__readDataPad(int(data[94:102], 16), 110).rstrip("\x00")
        if filename == "TRAILER!!!":
            return None
        if filename.startswith("./"):
            filename = filename[1:]
        if not self.issrc and not filename.startswith("/"):
            filename = "%s%s" % ("/", filename)
        if filename.endswith("/") and len(filename) > 1:
            filename = filename[:-1]
        if self.verify:
            # printconf-0.3.61-4.1.i386.rpm is an example where paths are
            # stored like: /usr/share/printconf/tests/../mf.magic
            # This makes te normapth() check fail and also gives trouble
            # for the algorithm finding hardlinks as the files are also
            # included with their normal path. So same dev/inode pairs
            # can be hardlinks or they can be wrongly packaged rpms.
            if self.strict and filename != os.path.normpath(filename):
                self.printErr("failed: normpath(%s)" % filename)
        # Do not even parse the below items, data should always be used
        # from rpm tags as too many items in the cpio header have been broken
        # in older rpm packages. Maybe leave it for the strict case, delete
        # it otherwise.
        # (name, inode, mode, nlink, mtime, filesize, dev, rdev)
        return [filename, int(data[6:14], 16), int(data[14:22], 16),
            int(data[38:46], 16), int(data[46:54], 16), int(data[54:62], 16),
            int(data[62:70], 16) * 256 + int(data[70:78], 16),
            int(data[78:86], 16) * 256 + int(data[86:94], 16)]

    def readCpio(self, func, filenamehash, devinode):
        files = []
        while 1:
            filedata = self.readEntry()
            if filedata == None:
                if self.size != None and self.size != 0:
                    self.printErr("failed cpiosize check")
                return files
            files.append(filedata)
            # XXX reading the data should be done with streaming
            # It will then move into verifyCpio()
            data = self.__readDataPad(filedata[5])
            func(filedata, data, filenamehash, devinode)
        return None

class HdrIndex:
    def __init__(self):
        self.hash = {}
        self.__len__ = self.hash.__len__
        self.__getitem__ = self.hash.get
        self.__setitem__ = self.hash.__setitem__
        self.__contains__ = self.hash.__contains__
        self.has_key = self.hash.has_key
        self.__repr__ = self.hash.__repr__

    def getOne(self, key):
        value = self[key]
        if value != None:
            return value[0]
        return value

# limit: does not support all RHL5.x and earlier rpms if verify is enabled
class ReadRpm:
    """Read (Linux) rpm packages."""

    def __init__(self, filename, verify=None, fd=None, strict=1, nodigest=None):
        self.filename = filename
        self.issrc = 0
        if filename.endswith(".src.rpm") or filename.endswith(".nosrc.rpm"):
            self.issrc = 1
        self.verify = verify # enable/disable more data checking
        self.fd = fd # filedescriptor
        # 1 == check if old tags are included, 0 allows all tags
        # 1 is good for Fedora Core development trees
        self.strict = strict
        self.nodigest = nodigest
        # Further data posibly created later on:
        #self.leaddata = first 96 bytes of lead data
        #self.sigdata = binary blob of signature header
        #self.sig = signature header parsed as HdrIndex()
        #self.sigdatasize = size of signature header
        #self.hdrdata = binary blob of header data
        #self.hdr = header parsed as HdrIndex()
        #self.hdrdatasize = size of header

    def printErr(self, err):
        print "%s: %s" % (self.filename, err)

    def raiseErr(self, err):
        raise ValueError, "%s: %s" % (self.filename, err)

    def __openFd(self, offset=None):
        if not self.fd:
            try:
                self.fd = open(self.filename, "ro")
            except:
                self.printErr("could not open file")
                return 1
            if offset:
                self.fd.seek(offset, 1)
        return None

    def closeFd(self):
        self.fd = None

    def __verifyLead(self, leaddata):
        (magic, major, minor, rpmtype, arch, name, osnum, sigtype) = \
            unpack("!4scchh66shh16x", leaddata)
        failed = None
        if major not in ("\x03", "\x04") or minor != "\x00" or \
            sigtype != 5 or rpmtype not in (0, 1):
            failed = 1
        # 21 == darwin
        if osnum not in (1, 21, 255, 256):
            failed = 1
        name = name.rstrip("\x00")
        if self.strict:
            if os.path.basename(self.filename)[:len(name)] != name:
                failed = 1
        if failed:
            print major, minor, rpmtype, arch, name, osnum, sigtype
            self.printErr("wrong data in rpm lead")

    def __verifyTag(self, index, fmt, hdrtags):
        (tag, ttype, offset, count) = index
        if not hdrtags.has_key(tag):
            self.printErr("hdrtags has no tag %d" % tag)
        else:
            t = hdrtags[tag]
            if t[1] != None and t[1] != ttype:
                if t[1] == RPM_ARGSTRING and \
                    (ttype == RPM_STRING or ttype == RPM_STRING_ARRAY):
                    pass    # special exception case
                elif t[1] == RPM_GROUP and \
                    (ttype == RPM_STRING or ttype == RPM_I18NSTRING):
                    pass    # exception for RPMTAG_GROUP
                else:
                    self.printErr("tag %d has wrong type %d" % (tag, ttype))
            if t[2] != None and t[2] != count:
                self.printErr("tag %d has wrong count %d" % (tag, count))
            if (t[3] & 1) and self.strict:
                self.printErr("tag %d is old" % tag)
            if self.issrc:
                if (t[3] & 4):
                    self.printErr("tag %d should be for binary rpms" % tag)
            else:
                if (t[3] & 2):
                    self.printErr("tag %d should be for src rpms" % tag)
        if count == 0:
            self.raiseErr("zero length tag")
        if ttype < 1 or ttype > 9:
            self.raiseErr("unknown rpmtype %d" % ttype)
        if ttype == RPM_INT32:
            count = count * 4
        elif ttype == RPM_STRING_ARRAY or ttype == RPM_I18NSTRING:
            size = 0
            for _ in xrange(count):
                end = fmt.index("\x00", offset) + 1
                size += end - offset
                offset = end
            count = size
        elif ttype == RPM_STRING:
            if count != 1:
                self.raiseErr("tag string count wrong")
            count = fmt.index("\x00", offset) - offset + 1
        elif ttype == RPM_CHAR or ttype == RPM_INT8:
            pass
        elif ttype == RPM_INT16:
            count = count * 2
        elif ttype == RPM_INT64:
            count = count * 8
        elif ttype == RPM_BIN:
            pass
        else:
            self.raiseErr("unknown tag header")
        return count

    def __verifyIndex(self, fmt, fmt2, indexNo, storeSize, hdrtags):
        checkSize = 0
        for i in xrange(0, indexNo * 16, 16):
            index = unpack("!iiii", fmt[i:i + 16])
            ttype = index[1]
            # alignment for some types of data
            if ttype == RPM_INT16:
                checkSize += (2 - (checkSize % 2)) % 2
            elif ttype == RPM_INT32:
                checkSize += (4 - (checkSize % 4)) % 4
            elif ttype == RPM_INT64:
                checkSize += (8 - (checkSize % 8)) % 8
            checkSize += self.__verifyTag(index, fmt2, hdrtags)
        if checkSize != storeSize:
            # XXX: add a check for very old rpm versions here, seems this
            # is triggered for a few RHL5.x rpm packages
            self.printErr("storeSize/checkSize is %d/%d" % (storeSize,
                checkSize))

    def __readIndex(self, pad, hdrtags):
        data = doRead(self.fd, 16)
        (magic, indexNo, storeSize) = unpack("!8sii", data)
        if magic != "\x8e\xad\xe8\x01\x00\x00\x00\x00" or indexNo < 1:
            self.raiseErr("bad index magic")
        fmt = doRead(self.fd, 16 * indexNo)
        fmt2 = doRead(self.fd, storeSize)
        padfmt = ""
        if pad != 1:
            padfmt = doRead(self.fd, (pad - (storeSize % pad)) % pad)
        if self.verify:
            self.__verifyIndex(fmt, fmt2, indexNo, storeSize, hdrtags)
        return (indexNo, storeSize, data, fmt, fmt2, 16 + len(fmt) + \
            len(fmt2) + len(padfmt))

    def __parseIndex(self, indexNo, fmt, fmt2, dorpmtag):
        hdr = HdrIndex()
        if len(dorpmtag) == 0:
            return hdr
        for i in xrange(0, indexNo * 16, 16):
            (tag, ttype, offset, count) = unpack("!4i", fmt[i:i + 16])
            if not dorpmtag.has_key(tag):
                continue
            nametag = dorpmtag[tag][4]
            if ttype == RPM_STRING_ARRAY or ttype == RPM_I18NSTRING:
                data = []
                for _ in xrange(count):
                    end = fmt2.index("\x00", offset)
                    data.append(fmt2[offset:end])
                    offset = end + 1
            elif ttype == RPM_STRING:
                data = fmt2[offset:fmt2.index("\x00", offset)]
            elif ttype == RPM_INT32:
                data = unpack("!%dI" % count, fmt2[offset:offset + count * 4])
            elif ttype == RPM_CHAR:
                data = unpack("!%dc" % count, fmt2[offset:offset + count])
            elif ttype == RPM_INT8:
                data = unpack("!%dB" % count, fmt2[offset:offset + count])
            elif ttype == RPM_INT16:
                data = unpack("!%dH" % count, fmt2[offset:offset + count * 2])
            elif ttype == RPM_INT64:
                data = unpack("!%dQ" % count, fmt2[offset:offset + count * 8])
            elif ttype == RPM_BIN:
                data = fmt2[offset:offset + count]
            else:
                self.raiseErr("unknown tag header")
                data = None
            # ignore duplicate entries as long as they are identical
            if hdr.has_key(nametag):
                if hdr[nametag] != data:
                    self.printErr("tag %d included twice" % tag)
            else:
                hdr[nametag] = data
        return hdr

    def readHeader(self, sigtags, hdrtags, keepdata=None):
        if self.__openFd():
            return 1
        leaddata = doRead(self.fd, 96)
        if leaddata[:4] != "\xed\xab\xee\xdb":
            self.printErr("no rpm magic found")
            return 1
        if self.verify:
            self.__verifyLead(leaddata)
        sigdata = self.__readIndex(8, sigtags)
        self.sigdatasize = sigdata[5]
        hdrdata = self.__readIndex(1, hdrtags)
        self.hdrdatasize = hdrdata[5]
        if keepdata:
            self.leaddata = leaddata
            self.sigdata = sigdata
            self.hdrdata = hdrdata

        if not sigtags and not hdrtags:
            return None

        if self.verify or sigtags:
            (sigindexNo, sigstoreSize, sigdata2, sigfmt, sigfmt2, size) = \
                sigdata
            self.sig = self.__parseIndex(sigindexNo, sigfmt, sigfmt2, sigtags)
        (hdrindexNo, hdrstoreSize, hdrdata2, hdrfmt, hdrfmt2, size) = hdrdata
        self.hdr = self.__parseIndex(hdrindexNo, hdrfmt, hdrfmt2, hdrtags)
        self.__getitem__ = self.hdr.__getitem__
        self.__setitem__ = self.hdr.__setitem__
        self.__contains__ = self.hdr.__contains__
        self.has_key = self.hdr.has_key
        self.__repr__ = self.hdr.__repr__
        if self.verify:
            self.__doVerify()
        return None

    def verifyCpio(self, filedata, data, filenamehash, devinode):
        # Overall result is that apart from the filename information
        # we should not depend on any data from the cpio header.
        # Data is also stored in rpm tags and the cpio header has
        # been broken in enough details to ignore it.
        (filename, inode, mode, nlink, mtime, filesize, dev, rdev) = filedata
        i = filenamehash.get(filename)
        if i == None:
            self.printErr("cpio file %s not in rpm header" % filename)
            return
        del filenamehash[filename]
        isreg = S_ISREG(mode)
        if isreg and inode != self["fileinodes"][i]:
            self.printErr("wrong fileinode for %s" % filename)
        if self.strict and mode != self["filemodes"][i]:
            self.printErr("wrong filemode for %s" % filename)
        # uid/gid are ignored from cpio
        # device/inode are only set correctly for regular files
        di = devinode.get((dev, inode))
        if di == None:
            pass
            # nlink is only set correctly for hardlinks, so disable this check:
            #if nlink != 1:
            #    self.printErr("wrong number of hardlinks")
        else:
            # Search for "normpath" to read why hardlinks might not
            # be hardlinks, but only double stored files with "/../"
            # stored in their filename. Broken packages out there...
            if self.strict and nlink != len(di):
                self.printErr("wrong number of hardlinks %s, %d / %d" % \
                    (filename, nlink, len(di)))
            # This case also happens e.g. in RHL6.2: procps-2.0.6-5.i386.rpm
            # where nlinks is greater than the number of actual hardlinks.
            #elif nlink > len(di):
            #   self.printErr("wrong number of hardlinks %s, %d / %d" % \
            #       (filename, nlink, len(di)))
        if mtime != self["filemtimes"][i]:
            self.printErr("wrong filemtimes for %s" % filename)
        if filesize != self["filesizes"][i] and \
            not (filesize == 0 and nlink > 1):
            self.printErr("wrong filesize for %s" % filename)
        if isreg and dev != self["filedevices"][i]:
            self.printErr("wrong filedevice for %s" % filename)
        if self.strict and rdev != self["filerdevs"][i]:
            self.printErr("wrong filerdevs for %s" % filename)
        if S_ISLNK(mode):
            if data.rstrip("\x00") != self["filelinktos"][i]:
                self.printErr("wrong filelinkto for %s" % filename)
        elif isreg:
            if not (filesize == 0 and nlink > 1):
                ctx = md5.new()
                ctx.update(data)
                if ctx.hexdigest() != self["filemd5s"][i]:
                    self.printErr("wrong filemd5s for %s" % filename)

    def getFilenames(self):
        basenames = self["basenames"]
        if basenames != None:
            dirnames = self["dirnames"]
            return [ "%s%s" % (dirnames[d], b)
                     for (d, b) in zip(self["dirindexes"], basenames) ]
        else:
            oldfilenames = self["oldfilenames"]
            if oldfilenames != None:
                return oldfilenames
        return []

    def readPayload(self, func):
        self.__openFd(96 + self.sigdatasize + self.hdrdatasize)
        devinode = {}     # this will contain possibly hardlinked files
        filenamehash = {} # full filename of all files
        filenames = self.getFilenames()
        if filenames:
            for (fn, flag, mode, dev, inode, i) in zip(filenames,
                self["fileflags"], self["filemodes"], self["filedevices"],
                self["fileinodes"], xrange(len(self["fileinodes"]))):
                if flag & (RPMFILE_GHOST | RPMFILE_EXCLUDE):
                    continue
                filenamehash[fn] = i
                if S_ISREG(mode):
                    #di = (dev, inode)
                    #if not devinode.has_key(di):
                    #    devinode[di] = []
                    #devinode[di].append(i)
                    devinode.setdefault((dev, inode), []).append(i)
        for di in devinode.keys():
            if len(devinode[di]) <= 1:
                del devinode[di]
        # sanity check hardlinks
        if self.verify:
            for hardlinks in devinode.values():
                j = hardlinks[0]
                mode = self["filemodes"][j]
                mtime = self["filemtimes"][j]
                size = self["filesizes"][j]
                md5 = self["filemd5s"][j]
                for j in hardlinks[1:]:
                    # dev/inode are already guaranteed to be the same
                    if self["filemodes"][j] != mode:
                        self.raiseErr("modes differ for hardlink")
                    if self["filemtimes"][j] != mtime:
                        self.raiseErr("mtimes differ for hardlink")
                    if self["filesizes"][j] != size:
                        self.raiseErr("sizes differ for hardlink")
                    if self["filemd5s"][j] != md5:
                        self.raiseErr("md5s differ for hardlink")
        cpiosize = None
        if self.verify:
            cpiosize = self.sig.getOne("payloadsize")
            archivesize = self.hdr.getOne("archivesize")
            if archivesize != None:
                if cpiosize == None:
                    cpiosize = archivesize
                elif cpiosize != archivesize:
                    self.printErr("wrong archive size")
        if self["payloadcompressor"] == "bzip2":
            import bz2, cStringIO
            payload = self.fd.read()
            fd = cStringIO.StringIO(bz2.decompress(payload))
        elif self["payloadcompressor"] in [None, "gzip"]:
            fd = PyGZIP(self.fd)
            #import gzip
            #fd = gzip.GzipFile(fileobj=self.fd)
        else:
            self.printErr("unknown payload compression")
            return
        if self["payloadformat"] not in [None, "cpio"]:
            self.printErr("unknown payload format")
            # XXX: handel drpm data format
            return
        c = CPIO(fd, self.issrc, cpiosize, self.verify, self.strict)
        cpiodata = c.readCpio(func, filenamehash, devinode)
        if cpiodata == None:
            self.raiseErr("Error reading CPIO payload")
        for filename in filenamehash.iterkeys():
            self.printErr("file not in cpio: %s" % filename)

    def getSpecfile(self, filenames=None):
        fileflags = self["fileflags"]
        for i in xrange(len(fileflags)):
            if fileflags[i] & RPMFILE_SPECFILE:
                return i
        if filenames == None:
            filenames = self.getFilenames()
        for i in xrange(len(filenames)):
            if filenames[i].endswith(".spec"):
                return i
        return None

    def getNVR(self):
        return "%s-%s-%s" % (self["name"], self["version"], self["release"])

    def getNA(self):
        return "%s.%s" % (self["name"], self["arch"])

    def getEVR(self):
        e = self["epoch"]
        if e != None:
            return "%d:%s-%s" % (e[0], self["version"], self["release"])
        return "%s-%s" % (self["version"], self["release"])

    def getArch(self):
        if self.issrc:
            return "src"
        return self["arch"]

    def getFilename(self):
        return "%s-%s-%s.%s.rpm" % (self["name"], self["version"],
            self["release"], self.getArch())

    def __verifyDeps(self, name, flags, version):
        n = self[name]
        f = self[flags]
        v = self[version]
        if n == None:
            if f != None or v != None:
                self.printErr("wrong dep data")
        else:
            if (f == None and v != None) or (f != None and v == None):
                self.printErr("wrong dep data")
            if f == None:
                f = [None] * len(n)
            if v == None:
                v = [None] * len(n)
            if len(n) != len(f) or len(f) != len(v):
                self.printErr("wrong length of deps for %s" % name)

    def __getDeps(self, name, flags, version):
        n = self[name]
        if n == None:
            return []
        f = self[flags]
        v = self[version]
        if f == None:
            f = [None] * len(n)
        if v == None:
            v = [None] * len(n)
        return zip(n, f, v)

    def getProvides(self):
        provs = self.__getDeps("providename", "provideflags", "provideversion")
        if not self.issrc:
            provs.append( (self["name"], RPMSENSE_EQUAL, self.getEVR()) )
        return provs

    def getRequires(self):
        return self.__getDeps("requirename", "requireflags", "requireversion")

    def getObsoletes(self):
        return self.__getDeps("obsoletename", "obsoleteflags",
            "obsoleteversion")

    def getConflicts(self):
        return self.__getDeps("conflictname", "conflictflags",
            "conflictversion")

    def getTriggers(self):
        deps = self.__getDeps("triggername", "triggerflags", "triggerversion")
        index = self["triggerindex"]
        scripts = self["triggerscripts"]
        progs = self["triggerscriptprog"]
        if deps == []:
            if self.verify:
                if index != None or scripts != None or progs != None:
                    self.printErr("wrong triggers still exist")
            return []
        if self.verify and len(scripts) != len(progs):
            self.printErr("wrong triggers")
        if index == None:
            if self.verify and len(deps) != len(scripts):
                self.printErr("wrong triggers")
        else:
            if self.verify and len(deps) != len(index):
                self.printErr("wrong triggers")
            scripts = [ scripts[i] for i in index ]
            progs = [ progs[i] for i in index ]
        return [(n, f, v, progs.pop(0), scripts.pop(0)) for (n, f, v) in deps]

    def buildOnArch(self, arch):
        # do not build if this arch is in the exclude list
        exclude = self["excludearch"]
        if exclude and arch in exclude:
            return None
        # do not build if this arch is not in the exclusive list
        exclusive = self["exclusivearch"]
        if exclusive and arch not in exclusive:
            return None
        # return 2 if this will build into a "noarch" rpm
        if self["buildarchs"] == [ 'noarch' ]:
            return 2
        # otherwise build this rpm normally for this arch
        return 1

    def getChangeLog(self, num=-1):
        """ Return the changlog entry in one string. """
        ctext = self["changelogtext"]
        if not ctext:
            return ""
        cname = self["changelogname"]
        ctime = self["changelogtime"]
        if num == -1 or num > len(ctext):
            num = len(ctext)
        data = ""
        for i in xrange(num):
            data = data + "* %s %s\n\n%s\n\n" % (time.strftime("%a %b %d %Y",
                time.localtime(ctime[i])), cname[i], ctext[i])
        return data

    def buildFileNames(self):
        """This function should go away: Returns (dir, filename, linksto,
        flags)."""
        if self["filemodes"] == None: # detect empty filelist
            return []
        # XXX We loose the class data here completely, move this stuff
        # for the non-verify (e.g. extraction) case.
        uid = Uid()
        self["fileusername"] = uid.addUGids(self["fileusername"])
        gid = Gid()
        self["filegroupname"] = gid.addUGids(self["filegroupname"])
        basenames = self["basenames"]
        oldfilenames = self["oldfilenames"]
        if basenames == None and oldfilenames:
            basenames = oldfilenames
            dirnames = [None] * len(oldfilenames)
        else:
            d = self["dirnames"]
            dirnames = [ d[index] for index in self["dirindexes"] ]
        return zip(dirnames, basenames, self["fileflags"],
                   self["fileusername"], self["filegroupname"],
                   self["filemodes"], self["filemtimes"],
                   self["filedevices"], self["fileinodes"],
                   self["filesizes"], self["filemd5s"],
                   self["filelinktos"], self["filerdevs"])

    def __doVerify(self):
        for i in rpmsigtagrequired:
            if not self.sig.has_key(i):
                self.printErr("sig header is missing: %s" % i)
        for i in rpmtagrequired:
            if not self.hdr.has_key(i):
                self.printErr("hdr is missing: %s" % i)
        size_in_sig = self.sig.getOne("size_in_sig")
        if size_in_sig != None:
            rpmsize = os.stat(self.filename)[6]
            if rpmsize != 96 + self.sigdatasize + size_in_sig:
                self.printErr("wrong size in rpm package")
        filenames = self.getFilenames()
        fileflags = self["fileflags"]
        if fileflags:
            for flag in fileflags:
                if flag & RPMFILE_EXCLUDE:
                    self.printErr("exclude flag set in rpm")
        if self.issrc:
            i = self.getSpecfile(filenames)
            if i == None:
                self.printErr("no specfile found in src.rpm")
            else:
                if self.strict and not filenames[i].endswith(".spec"):
                    self.printErr("specfile does not end with .spec")
            if self["sourcerpm"] != None:
                self.printErr("binary rpm does contain sourcerpm tag")
        else:
            if self["sourcerpm"] == None:
                self.printErr("source rpm does not contain sourcerpm tag")
        if self["triggerscripts"] != None:
            if len(self["triggerscripts"]) != len(self["triggerscriptprog"]):
                self.printErr("wrong trigger lengths")
        if "-" in self["version"] or ":" in self["version"]:
            self.printErr("version contains wrong char")
        if ":" in self["release"]:
            self.printErr("version contains wrong char")
        if self.strict:
            if "," in self["version"] or "," in self["release"]:
                self.printErr("version contains wrong char")
        if self["payloadformat"] not in [None, "cpio", "drpm"]:
            self.printErr("wrong payload format %s" % self["payloadformat"])
        if self.strict:
          if self["payloadcompressor"] not in [None, "gzip"]:
            self.printErr("no gzip compressor: %s" % self["payloadcompressor"])
        else:
          if self["payloadcompressor"] not in [None, "gzip", "bzip2"]:
            self.printErr("no gzip/bzip2 compressor: %s" % \
                self["payloadcompressor"])
        if self.strict:
          if self["payloadflags"] not in ["9"]:
            self.printErr("no payload flags: %s" % self["payloadflags"])
        if self.strict and self["os"] not in ["Linux", "linux"]:
            self.printErr("bad os: %s" % self["os"])
        elif self["os"] not in ["Linux", "linux", "darwin"]:
            self.printErr("bad os: %s" % self["os"])
        if self.strict:
          if self["packager"] not in (None, \
            "Red Hat, Inc. <http://bugzilla.redhat.com/bugzilla>"):
            self.printErr("unknown packager: %s" % self["packager"])
          if self["vendor"] not in (None, "Red Hat, Inc."):
            self.printErr("unknown vendor: %s" % self["vendor"])
          if self["distribution"] not in (None, "Red Hat Linux", "Red Hat FC-3",
            "Red Hat (FC-3)", "Red Hat (RHEL-3)", "Red Hat (FC-4)"):
            self.printErr("unknown distribution: %s" % self["distribution"])
        arch = self["arch"]
        if self["rhnplatform"] not in (None, arch):
            self.printErr("unknown arch for rhnplatform")
        if self.strict:
          if os.path.basename(self.filename) != self.getFilename():
            self.printErr("bad filename: %s" % self.filename)
          if self["platform"] not in (None, "", arch + "-redhat-linux-gnu",
            arch + "-redhat-linux", "--target=${target_platform}",
            arch + "-unknown-linux",
            "--target=${TARGET_PLATFORM}", "--target=$TARGET_PLATFORM"):
            self.printErr("unknown arch %s" % self["platform"])
        if self["exclusiveos"] not in (None, ["Linux"], ["linux"]):
            self.printErr("unknown os %s" % self["exclusiveos"])
        if self.strict:
            if self["buildarchs"] not in (None, ["noarch"]):
                self.printErr("bad buildarch: %s" % self["buildarchs"])
            if self["excludearch"] != None:
                for i in self["excludearch"]:
                    if not possible_archs.has_key(i):
                        self.printErr("new possible arch %s" % i)
            if self["exclusivearch"] != None:
                for i in self["exclusivearch"]:
                    if not possible_archs.has_key(i):
                        self.printErr("new possible arch %s" % i)
        for (s, p) in (("prein", "preinprog"), ("postin", "postinprog"),
            ("preun", "preunprog"), ("postun", "postunprog"),
            ("verifyscript", "verifyscriptprog")):
            (script, prog) = (self[s], self[p])
            if script != None and prog == None:
                self.printErr("no prog")
            if self.strict:
                if not possible_scripts.has_key(prog):
                    self.raiseErr("unknown prog: %s" % prog)
                if script == None and prog == "/bin/sh":
                    self.printErr("empty script: %s" % s)
                if script != None and isCommentOnly(script):
                    self.printErr("empty(2) script: %s" % s)
        # some verify tests are also in these functions:
        for (n, f, v) in (("providename", "provideflags", "provideversion"),
            ("requirename", "requireflags", "requireversion"),
            ("obsoletename", "obsoleteflags", "obsoleteversion"),
            ("conflictname", "conflictflags", "conflictversion"),
            ("triggername", "triggerflags", "triggerversion")):
            self.__verifyDeps(n, f, v)
        if not self.issrc:
            provs = self.__getDeps("providename", "provideflags",
                "provideversion")
            mydep = (self["name"], RPMSENSE_EQUAL, self.getEVR())
            ver = self["rpmversion"]
            # AS2.1 still has compat rpms which need this:
            if ver != None and ver[:4] < "4.3." and mydep not in provs:
                provs.append(mydep)
            if mydep not in provs:
                self.printErr("no provides for own rpm package, rpm=%s" % ver)
        self.getTriggers()

        # check file* tags to be consistent:
        reqfiletags = ["fileusername", "filegroupname", "filemodes",
            "filemtimes", "filedevices", "fileinodes", "filesizes",
            "filemd5s", "filerdevs", "filelinktos", "fileflags"]
        filetags = ["fileverifyflags", "filelangs", "filecolors", "fileclass",
            "filedependsx", "filedependsn"]
        x = self[reqfiletags[0]]
        lx = None
        if x != None:
            lx = len(x)
            for t in reqfiletags:
                if self[t] == None or len(self[t]) != lx:
                    self.printErr("wrong length for tag %s" % t)
            for t in filetags:
                if self[t] != None and len(self[t]) != lx:
                    self.printErr("wrong length for tag %s" % t)
        else:
            for t in reqfiletags[:] + filetags[:]:
                if self[t] != None:
                    self.printErr("non-None tag %s" % t)
        if self["oldfilenames"]:
            if self["dirindexes"] != None or \
                self["dirnames"] != None or \
                self["basenames"] != None:
                self.printErr("new filetag still present")
            if lx != len(self["oldfilenames"]):
                self.printErr("wrong length for tag oldfilenames")
        elif self["dirindexes"]:
            if len(self["dirindexes"]) != lx or len(self["basenames"]) != lx \
                or self["dirnames"] == None:
                self.printErr("wrong length for file* tag")

        if self.nodigest:
            return

        # sha1 of the header
        sha1header = self.sig["sha1header"]
        if sha1header:
            ctx = sha.new()
            ctx.update(self.hdrdata[2])
            ctx.update(self.hdrdata[3])
            ctx.update(self.hdrdata[4])
            if ctx.hexdigest() != sha1header:
                self.printErr("wrong sha1: %s / %s" % (sha1header,
                    ctx.hexdigest()))
        # md5sum of header plus payload
        md5sum = self.sig["md5"]
        if md5sum:
            ctx = md5.new()
            ctx.update(self.hdrdata[2])
            ctx.update(self.hdrdata[3])
            ctx.update(self.hdrdata[4])
            data = self.fd.read(65536)
            while data:
                ctx.update(data)
                data = self.fd.read(65536)
            # make sure we re-open this file if we read the payload
            self.closeFd()
            if ctx.digest() != md5sum:
                self.printErr("wrong md5: %s / %s" % (md5sum, ctx.hexdigest()))


class RRpm:
    """Sample class that uses ReadRpm() to get important information about
    an rpm."""

    def __init__(self, rpm):
        self.filename = rpm.filename
        self.name = rpm["name"]
        self.version = rpm["version"]
        self.release = rpm["release"]
        self.epoch = rpm.hdr.getOne("epoch")
        self.dep = (self.name, RPMSENSE_EQUAL, rpm.getEVR())
        self.arch = rpm["arch"]

        self.fileinfo = rpm.buildFileNames()

        self.provides = rpm.getProvides()
        self.requires = rpm.getRequires()
        self.obsoletes = rpm.getObsoletes()
        self.conflicts = rpm.getConflicts()

        self.pre = rpm["prein"]
        self.preprog = rpm["preinprog"]
        self.post = rpm["postin"]
        self.postprog = rpm["postinprog"]
        self.preun = rpm["preun"]
        self.preunprog = rpm["preunprog"]
        self.postun = rpm["postun"]
        self.postunprog = rpm["postunprog"]
        self.verify = rpm["verifyscript"]
        self.verifyprog = rpm["verifyscriptprog"]

        self.triggers = rpm.getTriggers()
        self.triggerin = rpm["triggerin"]
        self.triggerun = rpm["triggerun"]
        self.triggerpostun = rpm["triggerpostun"]


def verifyRpm(filename, verify, strict, payload, nodigest, hdrtags, keepdata):
    """Read in a complete rpm and verify its integrity."""
    rpm = ReadRpm(filename, verify, strict=strict, nodigest=nodigest)
    if rpm.readHeader(rpmsigtag, hdrtags, keepdata):
        return None
    if payload:
        rpm.readPayload(rpm.verifyCpio)
    rpm.closeFd()
    return rpm


def checkSymlinks(repo):
    """Check if any two dirs in a repository differ in user/group/mode."""
    allfiles = {}
    # collect all directories
    for rpm in repo:
        for f in rpm.filenames:
            allfiles[f] = None
    for rpm in repo:
        if not rpm.filenames:
            continue
        for (f, mode, link) in zip(rpm.filenames, rpm["filemodes"],
            rpm["filelinktos"]):
            if not S_ISLNK(mode):
                continue
            if not link.startswith("/"):
                link = "%s/%s" % (os.path.dirname(f), link)
            link = os.path.normpath(link)
            if allfiles.has_key(link):
                continue
            print "%s has dangling symlink from %s to %s" \
                % (rpm["name"], f, link)

def checkDirs(repo):
    """Check if any two dirs in a repository differ in user/group/mode."""
    dirs = {}
    # collect all directories
    for rpm in repo:
        if not rpm.filenames:
            continue
        for (f, mode, user, group) in zip(rpm.filenames, rpm["filemodes"],
            rpm["fileusername"], rpm["filegroupname"]):
            # check if startup scripts are in wrong directory
            if f.startswith("/etc/init.d"):
                print "init.d:", rpm.filename, f
            # collect all directories into "dirs"
            if not S_ISDIR(mode):
                continue
            dirs.setdefault(f, []).append( (f, user, group, mode,
                rpm.filename) )
    # check if all dirs have same user/group/mode
    for d in dirs.values():
        if len(d) < 2:
            continue
        (user, group, mode) = (d[0][1], d[0][2], d[0][3])
        for i in xrange(1, len(d)):
            if d[i][1] != user or d[i][2] != group or d[i][3] != mode:
                print "dir check failed for ", d
                break

dupes = [ ("glibc", "i386"),
          ("nptl-devel", "i386"),
          ("openssl", "i386"),
          ("kernel", "i586"),
          ("kernel-smp", "i686"),
          ("kernel-smp-devel", "i686"),
          ("kernel-xen0", "i686"),
          ("kernel-xenU", "i686"),
          ("kernel-devel", "i586") ]
def checkProvides(repo, checkrequires=1):
    provides = {}
    requires = {}
    for rpm in repo:
        req = rpm.getRequires()
        for r in req:
            if not requires.has_key(r[0]):
                requires[r[0]] = []
            requires[r[0]].append(rpm.getFilename())
    for rpm in repo:
        if (rpm["name"], rpm["arch"]) in dupes:
            continue
        for p in rpm.getProvides():
            if not provides.has_key(p):
                provides[p] = []
            provides[p].append(rpm)
    print "Duplicate provides:"
    for p in provides.keys():
        # only look at duplicate keys
        if len(provides[p]) <= 1:
            continue
        # if no require can match this, ignore duplicates
        if checkrequires and not requires.has_key(p[0]):
            continue
        x = []
        for rpm in provides[p]:
            #x.append(rpm.getFilename())
            if rpm["name"] not in x:
                x.append(rpm["name"])
        if len(x) <= 1:
            continue
        print p, x


# split EVR string in epoch, version and release
def evrSplit(evr):
    epoch = "0"
    i = evr.find(":")
    if i != -1:
        epoch = evr[:i]
    j = evr.find("-", i + 1)
    if j != -1:
        return (epoch, evr[i + 1:j], evr[j + 1:])
    return (epoch, evr[i + 1:], "")


fileglobs = [".*bin\/.*", "^\/etc\/.*", "^\/usr\/lib\/sendmail$"]
dirglobs = [".*bin\/.*", "^\/etc\/.*"]

class RepoRpm:
    """Read one rpm for createrepo data."""

    def __init__(self, filename):
        stats = os.stat(filename)
        self.size = stats[6]
        self.mtime = stats[8]
        self.rpm = ReadRpm(filename)
        if self.rpm.readHeader(rpmsigtag, rpmtag):
            return
        self.rpm.closeFd()
        self.rangestart = 96 + self.rpm.sigdatasize
        self.rangeend = self.rangestart + self.rpm.hdrdatasize - 1

        # setup regex objects
        self.filerc = []
        self.dirrc = []
        for glob in fileglobs:
            self.filerc.append(re.compile(glob))
        for glob in dirglobs:
            self.dirrc.append(re.compile(glob))

        self.filenames = []
        self.dirnames = []
        self.ghostnames = []
        filenames = self.rpm.getFilenames()
        if filenames != []:
            for (filename, mode, flag) in zip(filenames, self.rpm["filemodes"],
                self.rpm["fileflags"]):
                if S_ISDIR(mode):
                    self.dirnames.append(filename)
                else:
                    if flag & RPMFILE_GHOST:
                        self.ghostnames.append(filename)
                        continue
                    self.filenames.append(filename)

        self.usefulfiles = []
        for f in self.filenames:
            for glob in self.filerc:
                if glob.match(f):
                    self.usefulfiles.append(f)
        self.usefulghosts = []
        for f in self.ghostnames:
            for glob in self.filerc:
                if glob.match(f):
                    self.usefulghosts.append(f)
        self.usefuldirs = []
        for f in self.dirnames:
            for glob in self.dirrc:
                if glob.match(f):
                    self.usefuldirs.append(f)


def main():
    import getopt
    repo = []
    strict = 0
    nodigest = 0
    payload = 1
    wait = 0
    verify = 1
    small = 0
    (opts, args) = getopt.getopt(sys.argv[1:], "?",
        ["help", "strict", "digest", "nodigest",
         "payload", "nopayload", "wait", "noverify", "small"])
    for (opt, val) in opts:
        if opt in ["-?", "--help"]:
            print "verify rpm packages"
            sys.exit(0)
        elif opt == "--strict":
            strict = 1
        elif opt == "--digest":
            nodigest = 0
        elif opt == "--nodigest":
            nodigest = 1
        elif opt == "--payload":
            payload = 1
        elif opt == "--nopayload":
            payload = 0
        elif opt == "--wait":
            wait = 1
        elif opt == "--noverify":
            verify = 0
        elif opt == "--small":
            small = 1
    keepdata = 1
    hdrtags = rpmtag
    if nodigest == 1:
        keepdata = 0
        if verify == 0 and small:
            for i in importanttags.keys():
                value = rpmtag[i]
                importanttags[i] = value
                importanttags[value[0]] = value
            hdrtags = importanttags
    #for z in xrange(10):
    for a in args:
        b = [a]
        if os.path.isdir(a):
            b = []
            for c in os.listdir(a):
                fn = "%s/%s" % (a, c)
                if c.endswith(".rpm") and os.path.isfile(fn):
                    b.append(fn)
        for a in b:
            #reporpm = RepoRpm(a)
            rpm = verifyRpm(a, verify, strict, payload, nodigest, hdrtags,
                keepdata)
            if rpm == None:
                continue
            #f = rpm["requirename"]
            #if f:
            #    print rpm.getFilename()
            #    print f
            #rrpm = RRpm(rpm)
            if strict or wait:
                repo.append(rpm)
            del rpm
    if strict:
        for rpm in repo:
            rpm.filenames = rpm.getFilenames()
        del rpm
        checkDirs(repo)
        checkSymlinks(repo)
        checkProvides(repo, checkrequires=1)
    if wait:
        print "ready"
        time.sleep(30)

if __name__ == "__main__":
    dohotshot = 0
    if dohotshot:
        import tempfile, hotshot, hotshot.stats
        filename = tempfile.mktemp()
        prof = hotshot.Profile(filename)
        prof.runcall(main)
        prof.close()
        del prof
        s = hotshot.stats.load(filename)
        s.strip_dirs().sort_stats("time").print_stats(100)
        s.strip_dirs().sort_stats("cumulative").print_stats(100)
        os.unlink(filename)
    else:
        main()

# vim:ts=4:sw=4:showmatch:expandtab
