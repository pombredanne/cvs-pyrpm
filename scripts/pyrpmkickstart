#!/usr/bin/python
#
# (c) 2005 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published by
# the Free Software Foundation; version 2 only
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2004, 2005 Red Hat, Inc.
#
# AUTHOR: Thomas Woerner <twoerner@redhat.com>
#

import os, sys, getopt, md5, stat, tempfile, string, time, random, crypt, \
       signal, types, shutil, re
import pprint

PYRPMDIR = ".."
if not PYRPMDIR in sys.path:
    sys.path.append(PYRPMDIR)
PYBINDIR = os.path.dirname(sys.argv[0])

import pyrpm

################################### classes ###################################

#################################### dicts ####################################

grp_st_gl = 'grp:shift_toggle,grp_led:scroll'

keyboard_models = {
    'ar-azerty'           : ['us,ar(azerty)', 'pc105', '', grp_st_gl],
    'ar-azerty-digits'    : ['us,ar(azerty_digits)', 'pc105', '', grp_st_gl],
    'ar-digits'           : ['us,ar(digits)', 'pc105', '', grp_st_gl],
    'ar-qwerty'           : ['us,ar(qwerty)', 'pc105', '', grp_st_gl],
    'ar-qwerty-digits'    : ['us,ar(qwerty_digits)', 'pc105', '', grp_st_gl],
    'be-latin1'           : ['be', 'pc105', '', ''],
    'ben'                 : ['us,ben', 'pc105', '', grp_st_gl],
    'ben-probhat'         : ['us,ben(probhat)', 'pc105', '', grp_st_gl],
    'bg'                  : ['us,bg', 'pc105', '', grp_st_gl],
    'br-abnt2'            : ['br', 'abnt2', '', ''],
    'cf'                  : ['ca_enhanced', 'pc105', '', ''],
    'croat'               : ['hr', 'pc105', '', ''],
    'cz-lat2'             : ['cz_qwerty', 'pc105', '', ''],
    'cz-us-qwertz'        : ['us,cz', 'pc105', '', grp_st_gl],
    'de'                  : ['de', 'pc105', '', ''],
    'de-latin1'           : ['de', 'pc105', '', ''],
    'de-latin1-nodeadkeys': ['de', 'pc105', 'nodeadkeys', ''],
    'dev'                 : ['us,dev', 'pc105', '', grp_st_gl],
    'dk'                  : ['dk', 'pc105', '', ''],
    'dk-latin1'           : ['dk', 'pc105', '', ''],
    'dvorak'              : ['dvorak', 'pc105', '', ''],
    'es'                  : ['es', 'pc105', '', ''],
    'et'                  : ['ee', 'pc105', '', ''],
    'fi'                  : ['fi', 'pc105', '', ''],
    'fi-latin1'           : ['fi', 'pc105', '', ''],
    'fr'                  : ['fr', 'pc105', '', ''],
    'fr-latin1'           : ['fr', 'pc105', '', ''],
    'fr-latin9'           : ['fr-latin9', 'pc105', '', ''],
    'fr-pc'               : ['fr', 'pc105', '', ''],
    'fr_CH'               : ['fr_CH', 'pc105', '', ''],
    'fr_CH-latin1'        : ['fr_CH', 'pc105', '', ''],
    'gr'                  : ['us,el', 'pc105', '', grp_st_gl],
    'guj'                 : ['us,guj', 'pc105', '', grp_st_gl],
    'gur'                 : ['us,gur', 'pc105', '', grp_st_gl],
    'hu'                  : ['hu', 'pc105', '', ''],
    'hu101'               : ['hu_qwerty', 'pc105', '', ''],
    'is-latin1'           : ['is', 'pc105', '', ''],
    'it'                  : ['it', 'pc105', '', ''],
    'it-ibm'              : ['it', 'pc105', '', ''],
    'it2'                 : ['it', 'pc105', '', ''],
    'jp106'               : ['jp', 'jp106', '', ''],
    'la-latin1'           : ['la', 'pc105', '', ''],
    'mk-utf'              : ['us,mk', 'pc105', '', grp_st_gl],
    'nl'                  : ['nl', 'pc105', '', ''],
    'no'                  : ['no', 'pc105', '', ''],
    'pl'                  : ['pl', 'pc105', '', ''],
    'pt-latin1'           : ['pt', 'pc105', '', ''],
    'ro_win'              : ['ro', 'pc105', '', ''],
    'ru'                  : ['us,ru', 'pc105', '', grp_st_gl],
    'ru-cp1251'           : ['us,ru', 'pc105', '', grp_st_gl],
    'ru-ms'               : ['us,ru', 'pc105', '', grp_st_gl],
    'ru.map.utf8ru'       : ['us,ru', 'pc105', '', grp_st_gl],
    'ru1'                 : ['us,ru', 'pc105', '', grp_st_gl],
    'ru2'                 : ['us,ru', 'pc105', '', grp_st_gl],
    'ru_win'              : ['us,ru', 'pc105', '', grp_st_gl],
    'sg'                  : ['de_CH', 'pc105', '', ''],
    'sg-latin1'           : ['de_CH', 'pc105', '', ''],
    'sk-qwerty'           : ['sk_qwerty', 'pc105', '', ''],
    'slovene'             : ['si', 'pc105', '', ''],
    'sv-latin1'           : ['se', 'pc105', '', ''],
    'tml-inscript'        : ['us,tml(INSCRIPT)', 'pc105', '', grp_st_gl],
    'tml-uni'             : ['us,tml(UNI)', 'pc105', '', grp_st_gl],
    'trq'                 : ['tr', 'pc105', '', ''],
    'ua-utf'              : ['us,ua', 'pc105', '', grp_st_gl],
    'uk'                  : ['gb', 'pc105', '', ''],
    'us'                  : ['us', 'pc105', '', ''],
    'us-acentos'          : ['us_intl', 'pc105', '', ''],
    }

################################## functions ##################################

def umount_all(dir):
    # umount target dir and included mount points
    mounted = [ ]
    try:
        fd = open("/proc/mounts", "r")
    except Exception:
        print "ERROR: Unable to open '/proc/mounts' for reading."
        return

    while 1:
        line = fd.readline()
        if not line:
            break
        args = string.split(line)
        i = args[1].find(dir)
        if i == 0:
            mounted.append(args[1])
    fd.close()
    # sort reverse
    mounted.sort()
    mounted.reverse()

    failed = 0
    for dir in mounted:
        if verbose:
            print "Umounting '%s' " % dir
        if pyrpm.umount(dir) == 1:
            failed = 1

    return failed

def check_dir(buildroot, dir):
    if not os.path.exists(buildroot+dir):
        print "ERROR: Directory '%s' does not exist." % dir
        return 0
    return 1

def create_dir(buildroot, dir):
    d = buildroot+dir
    if not os.path.exists(d):
        try:
            os.mkdir(d)
        except Exception, msg:
            print "ERROR: Unable to create '%d':" % dir, msg
            exit(1)

def getName(name):
    tmp = name[:]
    while len(tmp) > 0 and tmp[-1] >= '0' and tmp[-1] <= '9':
        tmp = tmp[:-1]
    if len(tmp) < 1:
        raise ValueError, "'%s' contains no name" % name
    return tmp

def getId(name):
    tmp = name[:]
    if tmp[-1] < '0' or tmp[-1] > '9':
        raise ValueError, "'%s' contains no id" % name
    i = 0
    while len(tmp) > 0 and tmp[-1] >= '0' and tmp[-1] <= '9':
        i *= 10
        i += int(tmp[-1])
        tmp = tmp[:-1]
    return i

def buildroot_copy(source, target):
    try:
        source_fd = open(buildroot+source, "r")
    except Exception, msg:
        print "ERROR: Failed to open '%s':" % buildroot+source, msg
        return
    try:
        target_fd = open(buildroot+target, "w")
    except Exception, msg:
        print "ERROR: Failed to open '%s':" % buildroot+target, msg
        source_fd.close()
        return
    data = source_fd.read(65536)
    while data:
        target_fd.write(data)
        data = source_fd.read(65536)
    source_fd.close()
    target_fd.close()

def exitHandler(signum, frame):
    exit(1)

def exit(code):
    time.sleep(1)

    if wait:
        if target_dir:
            sys.stdout.write('Use "chroot %s" to change into the installation tree.\n' %\
                             target_dir)
        sys.stdout.write('Waiting.. Press any key to cleanup and quit. ')
        c = sys.stdin.read(1)

    if stage2_img_dir:
        if verbose:
            print "Umounting '%s' " % stage2_img_dir
        pyrpm.umount(stage2_img_dir)

    if devmap:
        # remove temporary devices
        for dev in devmap:
            os.unlink(buildroot+devmap[dev])

    if tempdir:
        if umount_all(tempdir+"/") == 0:
            if not nocleanup:
                shutil.rmtree(tempdir)
    if partitionmap:
        for onpart in partitionmap:
            if partitionmap[onpart]["name"] == "swap" and \
                   partitionmap[onpart].has_key("on"):
                pyrpm.swapoff(partitionmap[onpart]["device"])
                del partitionmap[onpart]["on"]
    if diskmap:
        for disk in diskmap:
            diskmap[disk].close()

    sys.exit(code)

def loadComps(dir):
    # load comps file for groups and default packages
    comps_xml = "%s/RedHat/base/comps.xml" % dir
    if not os.path.exists(comps_xml):
        comps_xml = "%s/Fedora/base/comps.xml" % dir
    if not os.path.exists(comps_xml):
        return None
    comps = pyrpm.RpmCompsXML(pyrpm.rpmconfig, comps_xml)
    if comps.read():
        return comps
    del comps
    return None

def compsLangsupport(comps, languages):
    pkgs = [ ]
    for group in comps.grouphash.keys():
        if comps.grouphash[group].has_key("langonly") and \
               comps.grouphash[group]["langonly"] in languages:
            optional_list = comps.getOptionalPackageNames(group)
            for (name, requires) in optional_list:
                for req in requires:
                    if req in pkgs:
                        print "Adding '%s' for langsupport" % name
                        pkgs.append(name)
                        break
    return pkgs

#################################### main ####################################

verbose = 0
buildroot = ""
xen = 0
nocleanup = 0
confirm = 1
tempdir = None
diskmap = None
partitionmap = None
devmap = None
wait = 0
kudzu = 0
orig_yum = 0
target_dir = None
label_prefix = ""
standalone = 0
stage2_img_dir = None
repo_comps = 0
upgrade = None
no_stage2 = 0

def usage():
    print """
Usage: pyrpmkickstart <options> <kickstartfile>
                      [[<disk name>:]<disk image>|<disk device>]*

OPTIONS
  -h  | --help     Print help.
  -v  | --verbose  Be verbose, and more, ..
  -y  | --yes      Do not ask questions, assume yes.

  --kudzu          Run kudzu after installation.
  --label-prefix   Prepend prefix before labels on partitions
  --no-cleanup     Do not cleanup temporary directory and files.
  --standalone     Start in standalone mode: start network before running
                   pre script, swapon swap partitions
  --wait           Wait after installation before umounting.
  --xen            Write a simple xen config file.
  --yum            Use yum instead of pyrpmyum.
  --repo-comps     Load comps file in repos and use them for package and group
                   selection.
  --no-stage2      Do not mount stage2.img from installation source, use host
                   system tools to format partitions. This will not work for
                   all host and client system combinations, but could help 
                   with others.
  --upgrade=<part> Upgrade installation in partition <part>. This is only
                   useful for upgrades and if there is more than one
                   installation on the supplied disks.
"""
# TODO  --secure         Secure installation with firewall enabled in standalone mode

pyrpm.rpmconfig.supported_signals.extend([signal.SIGSEGV, signal.SIGBUS, signal.SIGABRT, signal.SIGILL, signal.SIGFPE])
pyrpm.setSignals(exitHandler)

if os.geteuid() != 0:
    print "ERROR: You have to be root to perform an installation."
    exit(1)

try:
    (opts, args) = getopt.getopt(sys.argv[1:], "hvy",
                                 [ "help", "verbose", "yes",
                                   "kudzu", "label-prefix", "no-cleanup",
                                   "standalone", "wait", "xen", "yum",
                                   "repo-comps", "no-stage2", "upgrade=", ])
except:
    usage()
    exit(1)

for (opt, val) in opts:
    if opt in [ "-h", "--help" ]:
        usage()
        exit(1)
    elif opt in [ "-v", "--verbose" ]:
        verbose += 1
        pyrpm.rpmconfig.verbose += 1
    elif opt in [ "-y", "--yes" ]:
        confirm = 0
    elif opt == "--xen":
        xen = 1
    elif opt == "--no-cleanup":
        nocleanup = 1
    elif opt == "--wait":
        wait = 1
    elif opt == "--kudzu":
        kudzu = 1
    elif opt == "--yum":
        orig_yum = 1
    elif opt == "--label-prefix":
        label_prefix = "%x_" % int(time.strftime("%m%d%H%M"))
    elif opt == "--standalone":
        standalone = 1
    elif opt == "--repo-comps":
        repo_comps = 1
    elif opt == "--no-stage2":
        no_stage2 = 1
    elif opt == "--upgrade":
        upgrade = val
    else:
        print "Unknown option '%s'" % opt
        usage()
        exit(1)

if len(args) < 1:
    usage()
    exit(1)

# kickstart file
ks_file = args[0]
if not os.path.exists(ks_file):
    print "ERROR: '%s' does not exist." % ks_file
    exit(1)

### load kickstart file ###

ks = pyrpm.KickstartConfig(ks_file)

# start network in standalone mode for pre script
if standalone:
    # TODO
    pass

# run pre script
if ks["pre"] and len(ks["pre"]["script"]) > 0:
    print "Running pre script"
    interpreter = "/bin/sh"
    if ks["pre"].has_key("interpreter"):
        interpreter = ks["pre"]["interpreter"]
    (status, rusage) = pyrpm.runScript(interpreter, ks["pre"]["script"])
    if status != 0:
        if ks["pre"].has_key("erroronfail"):
            print "ERROR: Pre script failed, aborting."
            exit(1)
        else:
            print "WARNING: Pre script failed, aborting."

# parse file again
ks.clear()
ks.parse(ks_file)

# sanity checks
if ks.has_key("install"):
    if not ks["autopart"] and (not ks["partition"] or \
                               len(ks["partition"]) < 1 or \
                               not ks["partition"].has_key("/")):
        print "ERROR: root partition not defined"
        exit(1)
else:
    # no upgrade checks
    pass

if not keyboard_models.has_key(ks["keyboard"]):
    print "ERROR: Keyboard model '%s' is not defined, exiting." % \
          ks["keyboard"]
    exit(1)

# installation methods

if not ks["nfs"] and not ks["url"]:
    print "ERROR: Only installation with nfs or url is supported, exiting."
    exit(1)
if ks["url"] and not ks["url"]["url"].startswith("file://"):
    print "ERROR: Unsupported url installation method, exiting."
    exit(1)
if ks["repository"]:
    for repo in ks["repository"]:
        if not ks["repository"][repo]["url"].startswith("file://") and \
               not ks["repository"][repo]["url"].startswith("nfs://"):
            print "ERROR: Unsupported url for repository, exiting."
            exit(1)

### system disks ###

system_disks = [ ]
try:
    fd = open("/proc/partitions") # get all disks
except Exception, msg:
    print "ERROR: Failed to open '/proc/partitions':", msg
    exit(1)
else:
    while 1:
        line = fd.readline()
        if not line:
            break
        line = string.strip(line)
        if len(line) < 1 or line[0] == '#':
            continue
        if line[:5] == "major":
            continue
        splits = line.split() # major, minor, blocks, name
        if len(splits) < 4:
            print "ERROR: '/proc/partitions' malformed."
            exit(1)
        if int(splits[1], 16) % 16 == 0: # minor%16=0 for harddisk devices
            hd = splits[3]
            if hd[0:4] == "loop":
                continue
            system_disks.append("/dev/"+hd)

### create user supplied diskmap ###

diskmap = { }
if len(args) > 1:
    for arg in args[1:]:
        splits = string.split(arg, ":")
        if len(splits) != 2:
            if len(splits) != 1:
                usage()
                exit(1)
            key = None
            val = string.strip(arg)
        else:
            key = string.strip(splits[0])
            val = string.strip(splits[1])
        if not os.path.exists(val):
            print "ERROR: '%s' does not exist." % val
            exit(1)
        mode = os.stat(val).st_mode
        if stat.S_ISBLK(mode):
            if not key:
                if len(val) > 7 and (val[:7] == "/dev/hd" or \
                                     val[:7] == "/dev/sd"):
                    key = val[5:]
                elif len(val) > 9 and val[:9] == "/dev/dasd":
                    key = val[5:]
        elif stat.S_ISREG(mode):
            if not key:
                for i in xrange(ord("a"), ord("z"), 1):
                    _key = "hd%c" % chr(i)
                    if not diskmap.has_key(_key):
                        key = _key
                        break;
            if not key:
                print "ERROR: Unable to find an unused name for '%s'" % val
                exit(1)
        if not key:
            print "ERROR: Unsupported type of '%s'." % val
            exit(1)
        disk_image = 0
        if val not in system_disks:
            print "Using '%s' as disk '%s'." % (val, key)
            disk_image = 1
        if diskmap.has_key(key):
            print "ERROR: '%s' already exists in diskmap." % key
            exit(1)

        diskmap[key] = pyrpm.Disk(val, alloc_loop=1, as_image=disk_image)

### create system diskmap ###

if len(diskmap) == 0:
    print "WARNING: No device maps defined, using system harddisks!"
    if confirm:
        choice = raw_input("Is this ok [y/N]: ")
        if len(choice) == 0 or choice[0] != "y" and choice[0] != "Y":
            exit(1)

    for disk in system_disks:
        hd = disk[5:] # strip '/dev/'
        diskmap[hd] = pyrpm.Disk(disk, as_image=0)

# are there any disks at all?
if len(diskmap) == 0:
    print "ERROR: No harddisks specified or found."
    exit(1)

# print disks
if verbose:
    disks = diskmap.keys()
    disks.sort()
    for disk in disks:
        if not diskmap[disk].has_disklabel():
            continue
        diskmap[disk].print_info()
        diskmap[disk].print_partitions()

### clear and generate partitions and disklabels ###

# clearpart, initialize disks
modified = [ ]
if ks.has_key("install") and \
       ks["clearpart"] and not ks["clearpart"].has_key("none"):
    disklabel = "msdos"
    linuxtypes = [ 0x82, 0x83, 0x8e, 0xfd ]
    drives = diskmap.keys()
    if ks["clearpart"].has_key("drives"):
        drives = ks["clearpart"]["drives"]
        for disk in drives:
            if diskmap.has_key(disk):
                continue
            print "ERROR: clearpart --drives: disk %s is not available" % disk
            exit(1)
    for disk in drives:
        if ks["clearpart"].has_key("initlabel") or \
               (ks["zerombr"] and ks["zerombr"].has_key("yes")) or \
               not diskmap[disk].has_disklabel():
            print "Initializing disk '%s'" % disk
            diskmap[disk].new_disklabel(disklabel)
            if not disk in modified:
                modified.append(disk)
        elif ks["clearpart"].has_key("all"):
            print "Removing all partitions on disk '%s'" % disk
            diskmap[disk].delete_all_partitions()
            if not disk in modified:
                modified.append(disk)
        elif ks["clearpart"].has_key("linux"):
            partition = diskmap[disk]["partition"].keys()
            partition.reverse()
            for i in partition:
                partition = diskmap[disk]["partition"][i]
                if partition["native_type"] in linuxtypes:
                    print "Removing partition %d on %s" % (i, disk)
                    diskmap[disk].delete_partition(i)
                    if not disk in modified:
                        modified.append(disk)

### create temp dir ###

try:
    tempdir = tempfile.mkdtemp(prefix="pyrpmkickstart_")
except Exception, msg:
    print msg
    exit(1)
source_dir = tempdir+"/source"
target_dir = tempdir+"/target"
stage2_dir = tempdir+"/stage2"
repo_dir = tempdir+"/repo"

### disk / partition selection ###

autopart = { }
autopart["/boot"] = { "fstype": "ext3", "size": 100 }
autopart["/"] = { "fstype": "ext3", "size": 650, "grow": 1 }
autopart["swap"] = { "size": 100 }

# create partitions dict
# 1) copy autopart key value pair if set
# 2) overwrite with kickstart partitions
partitions = { }
if ks.has_key("install"):
    if ks["autopart"]:
        for name in autopart.keys():
            partitions[name] = autopart[name]
    if ks["partition"]:
        for name in ks["partition"].keys():
            partitions[name] = ks["partition"][name]
else:
    # search for installations and load fstab file
    # generate partitions according to fstab entries as onpart and noformat

    print "Serching for installations"
    
    fstemp_dir = tempdir+"/fstemp"
    os.mkdir(fstemp_dir)

    fstabs = { }
    release = { }
    labelmap = { }
    for disk in diskmap:
        partition = diskmap[disk]["partition"]
        for part in partition:
            label = pyrpm.getLabel(partition[part]["device"])
            if label in labelmap:
                print "ERROR: label %s is not unique" % label
                exit(1)
            onpart = "%s%s" % (disk, part)
            labelmap[label] = onpart
            
            if partition[part]["fstype"] in [ "ext2", "ext3" ] and \
                   partition[part]["native_type"] == 0x83:

                # try to mount partition and search for fstab
                if verbose:
                    print "Mounting '%s' on '%s'" % (partition[part]["device"],
                                                     fstemp_dir)
                try:
                    pyrpm.mount(partition[part]["device"], fstemp_dir,
                                fstype=partition[part]["fstype"], options="ro")
                except Exception, msg:
                    pass
                else:
                    f = fstemp_dir + "/etc/fstab"
                    # anaconda does not support updates where /etc is
                    # an extra filesystem
                    #if not os.path.exists(f) or not os.path.isfile(f):
                    #    f = fstemp_dir + "/fstab"
                    if os.path.exists(f) and os.path.isfile(f):
                        try:
                            fd = open(f, "r")
                        except:
                            pass
                        else:
                            lines = fd.readlines()
                            fstabs[onpart] = [ ]
                            for line in lines:
                                splits = string.split(line)
                                if (splits[4] == "1" and \
                                    splits[5] in ["1", "2"]) or \
                                    splits[1] == "swap":
                                    fstabs[onpart].append(line)
                            fd.close()
                    f = fstemp_dir + "/etc/redhat-release"
                    if os.path.exists(f) and os.path.isfile(f):
                        try:
                            fd = open(f, "r")
                        except:
                            pass
                        else:
                            release[onpart] = string.strip(fd.readline())
                            fd.close()
                    if verbose:
                        print "Umounting '%s' " % fstemp_dir
                    pyrpm.umount(fstemp_dir)
                    if not release.has_key(onpart) or \
                           not fstabs.has_key(onpart):
                        if release.has_key(onpart):
                            del release[onpart]
                        if fstabs.has_key(onpart):
                            del fstabs[onpart]

    if len(fstabs) < 1:
        print "ERROR: Could not find any installation."
        exit(1)

    print "Available installations:"
    for onpart in release:
        print "%s: %s" % (onpart, release[onpart])

    if upgrade:
        if not upgrade in fstabs.keys():
            print "ERROR: Could not find %s." % upgrade
            exit(1)
        else:
            fstab = fstabs[upgrade]
    elif len(fstabs) == 1:
        fstab = fstabs.values()[0]
    elif len(fstabs) > 1:
        print "ERROR: More than one installation found, exiting."
        exit(1)

    if fstab:
        for line in fstab:
            if not line or len(line) < 1 or line[0] == "#":
                continue
            splits = line.split()
            if len(splits) != 6:
                continue
            if len(splits[1]) < 1: # mountpoint
                continue
            if splits[2] in [ "ext2", "ext3", "swap" ]:
                if splits[0][:6] == "LABEL=":
                    label = splits[0][6:]
                    if label in labelmap:
                        onpart = labelmap[label]
                else:
                    onpart = splits[0]
                partitions[splits[1]] = { "fstype": splits[2],
                                          "onpart": onpart,
                                          "noformat": 1 }
    del labelmap
    os.rmdir(fstemp_dir)

# create partitionmap
partitionmap = { }
to_create = { }
for name in partitions.keys():
    part = partitions[name]
    if part.has_key("onpart"):
        # partition is defined
        onpart = part["onpart"]
        # remove leading '/dev/' to be compatible with old kickstart versions
        if onpart[:5] == "/dev/":
            onpart = onpart[5:]
        error = 0
        try:
            disk = getName(onpart)
            i = getId(onpart)
        except:
            print "ERROR: '%s' is not a valid partition name." % onpart
            exit(1)
        if onpart in partitionmap:
            print "ERROR: '%s' is used more than once." % part["onpart"]
            exit(1)
        partitionmap[onpart] = { }
        partitionmap[onpart]["name"] = name
        partitionmap[onpart]["disk"] = disk
        partitionmap[onpart]["id"] = i
        if partitionmap[onpart]["id"] < 1:
            print "ERROR: Partition id '%d' is not valid." % \
                  partitionmap[onpart]["id"]
            exit(1)
    else:
        # create partition
        ondisk = "hda"
        # TODO: use SCSI disks
        # Not possible right now, because there is no hardware detection.
        # Therefore the SCSI driver is not in the initrd.
        #if not diskmap.has_key(ondisk):
        #    if diskmap.has_key("sda"):
        #         ondisk = "sda"
        if not diskmap.has_key(ondisk):
            if diskmap.has_key("dasda"):
                ondisk = "dasda"
        if part.has_key("ondisk"):
            ondisk = part["ondisk"]
            # drop leading '/dev/' to be compatible with old kickstart versions
            if ondisk[:5] == "/dev/":
                ondisk = ondisk[5:]
        if not part.has_key("size"):
            print "ERROR: No size given for %s." % name
            exit(1)
        if not diskmap.has_key(ondisk):
            print "ERROR: '%s' is not defined." % ondisk
            exit(1)
        to_create.setdefault(ondisk, [ ]).append(name)

# create primary and logical lists
for disk in to_create.keys():
    # check to have only onw grow partition per disk
    grow = None
    primary = [ ]
    logical = [ ]
    part_size = { }
    part_maxsize = { }
    size_needed = 0
    for name in to_create[disk]:
        part = partitions[name]

        if part.has_key("size"):
            part_size[name] = long(part["size"])
        else:
            if name in [ "swap", "/boot" ]:
                # use recommeneded memory size for swap partition if no size
                # is given
                part_size[name] = long(autopart[name]["size"])
        if not part_size.has_key(name):
            print "ERROR: Partition '%s' has no size." % name
            exit(1)
        part_size[name] = (((part_size[name] * 1024L*1024L) / \
                            diskmap[disk]["units"] + \
                            diskmap[disk]["sector_size"] - 1) / \
                           diskmap[disk]["sector_size"])
        size_needed += part_size[name]
        if part.has_key("maxsize"):
            part_maxsize[name] = (((long(part["maxsize"]) * 1024L*1024L) / \
                                   diskmap[disk]["units"] + \
                                   diskmap[disk]["sector_size"] - 1) / \
                                  diskmap[disk]["sector_size"])
        if part.has_key("asprimary"):
            primary.append(name)
        else:
            logical.append(name)

    freespace = diskmap[disk]["freespace_primary"]

    if len(diskmap[disk]["primary"]) + len(diskmap[disk]["extended"]) > 0:
        print "ERROR: Disk '%s' is already partitioned." % disk
        exit(1)

    if len(freespace) == 0 or size_needed > freespace[0]["unit-length"]:
        print "ERROR: Not enough free block on '%s'." % disk

    for name in to_create[disk]:
        part = partitions[name]

        if part.has_key("grow"):
            size_needed -= part_size[name]
            # there is only one freespace
            part_size[name] = freespace[0]["unit-length"] - size_needed
            if part_maxsize.has_key(name) and \
                   part_size[name] > part_maxsize[name]:
                part_size[name] = part_maxsize[name]
            size_needed += part_size[name]

    primary.sort()
    logical.sort()
    if len(primary) + len(logical) + len(diskmap[disk]["partition"]) > 4:
        # more than 4 partitions
        if len(primary) + len(diskmap[disk]["partition"]) < 3:
            # Try to move "/boot" to primary if it is not in primary already
            # and if it exists. If there is no "/boot", try to move "/".
            if "/boot" in logical:
                primary.insert(0, "/boot")
                logical.remove("/boot")
            elif not "/boot" in primary and "/" in logical:
                primary.insert(0, "/")
                logical.remove("/")
    else:
        # all can be primary
        primary.extend(logical)
        logical = [ ]

        # move /boot to the top, if it is in primary and not on top
        if "/boot" in primary and primary.index("/boot") > 0:
            primary.remove("/boot")
            primary.insert(0, "/boot")

    size_primary = 0
    size_logical = 0
    for name in primary:
        size_primary += part_size[name]
    for name in logical:
        size_logical += part_size[name]

    # create partitions
    for name in primary+logical:
        part = partitions[name]

        # get freespace
        if name in primary:
            freespace = diskmap[disk]["freespace_primary"]
        else:
            if len(diskmap[disk]["extended"]) == 0:
                # create extended partition

                freespace = diskmap[disk]["freespace"]
                match = freespace[0]

                match = None
                for free in freespace:
                    if free["unit-length"] >= size_logical:
                        if not match or \
                               long(match["unit-length"]) > \
                               long(free["unit-length"]):
                            match = free
                    if free["unit-length"] == size_logical:
                        match = free
                        break
                if not match:
                    print "ERROR: Extended partition does not fit onto %s." % \
                          disk
                    exit(1)

                start = long(match["start"])
                end = start + (size_logical) * diskmap[disk]["units"] - 1

                if end > match["end"]:
                    print "ERROR: Size calculation wrong for the extended " + \
                          "partition: Size is "+ (end-start+1) \
                          +" and should be "+ (match["end"]-start+1) + "."
                    exit(1)

                print "Creating extended partition on disk %s" % disk
                try:
                    diskmap[disk].add_partition(0, start, end,
                                                pyrpm.Partition.PARTITION_EXTENDED,
                                                None)
                except Exception, msg:
                    print "ERROR: Failed to create extended partition: ", msg
                    exit(1)

            freespace = diskmap[disk]["freespace_logical"]

        match = None
        for free in freespace:
            if free["unit-length"] >= part_size[name]:
                if not match or \
                       long(match["unit-length"]) > long(free["unit-length"]):
                    match = free
            if free["unit-length"] == part_size[name]:
                match = free
                break
        if not match:
            print "ERROR: Partition %s does not fit onto %s." % (name, disk)
            exit(1)

        if match["type"] & pyrpm.Partition.PARTITION_LOGICAL:
            type = pyrpm.Partition.PARTITION_LOGICAL
            # create extended if there is none, yet
        else:
            type = pyrpm.Partition.PARTITION_PRIMARY
        if name == "swap" or part["fstype"] == "swap":
            fstype = "linux-swap"
        else:
            fstype = "ext3"

        start = long(match["start"])
        end = start + part_size[name] * diskmap[disk]["units"] - 1

        if end > match["end"]:
            print "ERROR: Partition %s does not fit onto %s." % (name, disk)
            exit(1)
        print "Creating new partition '%s' on disk %s." % (name, disk)
        try:
            num = diskmap[disk].add_partition(0, start, end, type, fstype)
        except Exception, msg:
            print "ERROR: Failed to create partition '%s': " % name, msg
            exit(1)

        onpart = "%s%d" % (disk, num)
        partitionmap[onpart] = { }
        partitionmap[onpart]["name"] = name
        partitionmap[onpart]["disk"] = disk
        partitionmap[onpart]["id"] = num

        if not disk in modified:
            modified.append(disk)

    if verbose:
        diskmap[disk].print_info()
        diskmap[disk].print_partitions()

if len(modified) > 0 and confirm == 1:
    choice = raw_input("Is this ok [y/N]: ")
    if len(choice) == 0 or choice[0] != "y" and choice[0] != "Y":
        exit(1)

# commit changes
for disk in modified:
    try:
        diskmap[disk].commit()
    except Exception, msg:
        if not diskmap[disk].has_key("image"):
            print msg
            exit(1)
    diskmap[disk].reload()

# sanity check
if len(partitionmap) == 0:
    print "INTERNAL ERROR: partitionmap is empty."
    exit(1)

# check partitionmap with diskmap
for onpart in partitionmap:
    disk = partitionmap[onpart]["disk"]
    if not diskmap.has_key(disk):
        print "ERROR: disk '%s' is not defined." % disk
        exit(1)

# are all needed partitions there?
error = 0
for onpart in partitionmap:
    name = partitionmap[onpart]["name"]
    disk = partitionmap[onpart]["disk"]
    id = partitionmap[onpart]["id"]
    d = diskmap[disk]
    if not id in d["partition"]:
        print "ERROR: partition '%s' does not exist." % onpart
        error = 1
    if error:
        continue
    p = d["partition"][id]
    sector_size = diskmap[disk]["sector_size"]
    partitionmap[onpart]["start"] = p["start"] * sector_size
    partitionmap[onpart]["end"] = p["end"] * sector_size
    partitionmap[onpart]["size"] = p["length"] * sector_size
    partitionmap[onpart]["device"] = p["device"]

    part = partitions[name]

    # check partition types
    if not p["native_type"]:
        print "ERROR: Partition '%s' has no type." % onpart
        error = 1
    else:
        if p["native_type"] == 0x83:
            if not part.has_key("fstype") or \
                   not part["fstype"] in [ "ext2", "ext3" ]:
                print "ERROR: Partition '%s' does not match filesystem" % onpart
                error = 1
        elif p["native_type"] == 0x82:
            if part.has_key("fstype") and part["fstype"] != "swap":
                print "ERROR: Partition '%s' does not match filesystem" % onpart
                error = 1
        else:
            print "ERROR: Filesystem '%s' with code 0x%x on '%s' is not supported" % \
                  (p["fstype"], p["native_type"], onpart)
            error = 1

if error:
    exit(1)

labels = [ ]
# get all labels
for disk in diskmap.keys():
    partition = diskmap[disk]["partition"]
    for i in partition.keys():
        label = pyrpm.getLabel(partition[i]["device"])
        if not label:
            continue
        onpart = "%s%d" % (disk, i)
        if onpart in partitionmap:
            name = partitionmap[onpart]["name"]
            partitionmap[onpart]["label"] = label
            part = partitions[name]
            if part.has_key("noformat"):
                labels.append(label)
        else:
            labels.append(label)

# create labels
for onpart in partitionmap:
    name = partitionmap[onpart]["name"]
    label = label_prefix
    part = partitions[name]

    if part.has_key("noformat"):
        # filesystem marked not to get formatted
        continue

    if part.has_key("fstype") and part["fstype"] in [ "ext2", "ext3" ]:
        label += name
    elif name == "swap":
        label += "%s-swap" % onpart
    else:
        print "Could not determine filesystem type of '%s'" % onpart
        error = 1
    if part.has_key("label"):
        label = part["label"]
    if len(label) > 16:
        print "WARNING: Label '%s' for '%s' is too long," % (label, onpart) + \
              ", tuncating to 16 chars."
        label = label[:16]

    # add or increase label id as long as label in labels
    while label in labels:
        try:
            id = getId(label)
        except:
            label = label + "1"
        else:
            try:
                l_name = getName(label)
            except:
                print "ERROR: '%s' is no valid label name" % label
                exit(1)
            label = "%s%d" % (l_name, (id+1))

    partitionmap[onpart]["label"] = label

error = 0
for disk in diskmap:
    if not os.path.exists(diskmap[disk]["device"]):
        print "ERROR: Disk %s: %s is no valid device." % \
              (disk, diskmap[disk]["device"])
        error = 1
for onpart in partitionmap:
    if not os.path.exists(partitionmap[onpart]["device"]):
        print "ERROR: Partition %s: %s is no valid device." % \
              (onpart, partitionmap[onpart]["device"])
        error = 1
if error:
    exit(1)

#if verbose:
#    sys.stdout.write("diskmap=")
#    pprint.pprint(diskmap)
#    sys.stdout.write("partitionmap=")
#    pprint.pprint(partitionmap)
#    sys.stdout.write("labels=")
#    pprint.pprint(labels)

### mount source ###

# create source mount point and mount source (nfs)
opts = "ro"
os.mkdir(source_dir)
if ks["nfs"]:
    source = "%s:%s" % (ks["nfs"]["server"], ks["nfs"]["dir"])
    fstype = "nfs"
    args = None
elif ks["url"]:
    soure = None
    fstype = None
    args = None
    if ks["url"]["url"].startswith("file://"):
        source = ks["url"]["url"][7:]
        args = [ "--rbind" ]
    else:
        # TODO: http and ftp source
        print "ERROR: Only file urls are currently supported."
        exit(1)

if verbose:
    print "Mounting '%s' on '%s'" % (source, source_dir)
try:
    pyrpm.mount(source, source_dir, fstype, opts, args)
except Exception, msg:
    print msg
    exit(1)

### mount stage2 temporary ###

if not no_stage2:
    stage2_img_dir = tempdir+"/tmp"
    os.mkdir(stage2_img_dir)
    stage2 = "%s/RedHat/base/stage2.img" % source_dir
    if not os.path.exists(stage2):
        stage2 = "%s/Fedora/base/stage2.img" % source_dir
    if not os.path.exists(stage2):
        print "ERROR: Could not find stage2 image in installation source."
        exit(1)

    fstype = None # no fstype needed for compressed rom fs
    # determine stage2.img filesystem type
    try:
        fd = open(stage2, "r")
    except Exception, msg:
        print msg
        exit(1)
    else:
        magic = fd.read(4)
        fd.close()
        if len(magic) != 4:
            print "ERROR: %s is not a valid stage2 image" % stage2
            exit(1)
        if magic == "hsqs" or magic == "sqsh":
            fstype = "squashfs"

    if verbose:
        print "Mounting '%s' on '%s'" % (stage2, stage2_img_dir)
    try:
        pyrpm.mount(stage2, stage2_img_dir, fstype, options="loop,defaults,ro")
    except Exception, msg:
        print msg
        exit(1)

    ### analyze stage2 ###
    buildstamp = "%s/.buildstamp" % stage2_img_dir
    if not os.path.exists(buildstamp):
        print "ERROR: Buildstamp information is missing in stage2."
        exit(1)
    try:
        fd = open(buildstamp, "r")
    except Exception, msg:
        print "ERROR: Failed to open buildstamp information in stage2:", msg
        exit(1)
    lines = fd.readlines()
    fd.close()
    if len(lines) < 3:
        print "ERROR: Buildstamp information in stage2 is malformed:", lines
        exit(1)

    source_date = string.strip(lines[0])
    source_release = string.strip(lines[1])
    source_version = string.strip(lines[2])
    del lines

else: # no_stage2
    dir = "%s/RedHat/RPMS" % source_dir
    source_release = "Red Hat Enterprise Linux"
    release = "redhat"
    if not os.path.exists(dir) or not os.path.isdir(dir):
        dir = "%s/Fedora/RPMS" % source_dir
        source_release = "Fedora Core"
        release = "fedora"
    if not os.path.exists(dir) or not os.path.isdir(dir):
        print "ERROR: No valid installation source."
        exit(1)
    list = os.listdir(dir)
    s = [ ]
    regex = re.compile('%s-release-.*\.rpm' % release)
    for l in list:
        if regex.match(l):
            s.append(l)
    if len(s) != 1:
        print "ERROR: Could not find release package in installation source."
        exit(1)
    splits = string.split(s[0], "-")
    i = 0
    while i < len(splits[2]) and splits[2][i] >= '0' and splits[2][i] <= '9':
        i += 1
    source_version = splits[2][:i]
    if len(source_version) == 0:
       print "ERROR: No valid version of installation source"
       exit(1)
    i = string.find(s[0], "rawhide")
    if i != -1:
        source_version += ".90" # fix for rawhide (bad)

if source_release == "Red Hat Enterprise Linux":
    install_version = "RHEL"
elif source_release == "Fedora Core":
    install_version = "FC"
else:
    print "ERROR: Unknown source release."
    exit(1)
install_release = install_version
install_version += "-%s" % source_version

print "Installation source: %s %s" % (source_release, source_version)

### mount repos ###

repos = { }
repo_count = 0
if ks["repository"]:
    # create repo base directory
    os.mkdir(repo_dir)

    for repo in ks["repository"]:
        dir = "%s/%04d" % (repo_dir, repo_count)
        os.mkdir(dir)

        soure = None
        fstype = None
        opts = "ro"
        args = None

        # nfs source
        if ks["repository"][repo]["url"].startswith("nfs://"):
            s = string.splitfields(ks["repository"][repo]["url"][6:], "/", 1)
            source = "%s:/%s" % (s[0], s[1])
            fstype = "nfs"
            args = None
        # file source
        elif ks["repository"][repo]["url"].startswith("file://"):
            source = ks["repository"][repo]["url"][7:]
            args = [ "--rbind" ]
        else:
            # TODO: http and ftp source
            print "ERROR: Only nfs and file urls are currently supported " + \
                  "for repos."
            exit(1)

        # mount the repo
        if verbose:
            print "Mounting '%s' on '%s'" % (source, dir)
        try:
            pyrpm.mount(source, dir, fstype, opts, args)
        except Exception, msg:
            print msg
            exit(1)

        repos[repo] = dir
        repo_count += 1

### format partitions ###

# prepare to format partitions
to_format = [ ]
for onpart in partitionmap:
    name = partitionmap[onpart]["name"]
    part = partitions[name]
    if not part.has_key("noformat"):
        to_format.append(onpart)
to_format.sort()
to_format.reverse()

if confirm == 1 and len(to_format) > 0:
    print "About to format these partitions:"
    for onpart in to_format:
        name = partitionmap[onpart]["name"]
        if diskmap[partitionmap[onpart]["disk"]].has_key("image"):
            disk = "%s:%s" % (partitionmap[onpart]["disk"],
                              diskmap[partitionmap[onpart]["disk"]]["image"])
        else:
            disk = partitionmap[onpart]["disk"]
        print "\t'%s': '%s' on '%s'" % (name, onpart, disk)
    choice = raw_input("Is this ok [y/N]: ")
    if len(choice) == 0 or choice[0] != "y" and choice[0] != "Y":
        exit(1)

# if there is something to format:
# 1) copy stage2
# 2) format partitions
# 3) free stage2 copy
if len(to_format) > 0:

    if not no_stage2:
        ### create stage2 chroot ###

        # copy temporary stage2 mount
        print "Preparing to format"

        # create stage2 mount point and mount ramfs for stage2
        os.mkdir(stage2_dir)

        if verbose:
            print "Mounting ramfs on '%s'" % stage2_dir
        try:
            pyrpm.mount("None", stage2_dir, fstype="ramfs")
        except Exception, msg:
            print "ERROR: Unable to create stage2 ramfs:", msg
            exit(1)

        # copytree does not like to get a signal
        pyrpm.blockSignals()
        for f in os.listdir(stage2_img_dir):
            s = "%s/%s" % (stage2_img_dir, f)
            d = "%s/%s" % (stage2_dir, f)
            if os.path.isdir(s):
                shutil.copytree(s, d, symlinks=True)
            else:
                shutil.copy2(s, d)
        pyrpm.unblockSignals()

        # craete missing dirs and links
        create_dir(stage2_dir, "/bin")
        create_dir(stage2_dir, "/dev")
        create_dir(stage2_dir, "/etc")
        create_dir(stage2_dir, "/proc")
        create_dir(stage2_dir, "/tmp")
        create_dir(stage2_dir, "/var")
        create_dir(stage2_dir, "/var/log")
        create_dir(stage2_dir, "/var/tmp")

        if not os.path.exists("%s/usr/sbin/mke2fs" % stage2_dir):
            print "ERROR: /usr/sbin/mke2fs is missing."
            exit(1)
        if not os.path.exists("%s/usr/sbin/tune2fs" % stage2_dir):
            print "ERROR: /usr/sbin/tune2fs is missing."
            exit(1)
        if not os.path.exists("%s/usr/sbin/mkswap" % stage2_dir):
            print "ERROR: /usr/sbin/mkswap is missing."
            exit(1)

        if not os.path.exists("%s/bin/sh" % stage2_dir):
            try:
                os.symlink("../usr/bin/bash", "%s/bin/sh" % stage2_dir)
            except Exception, msg:
                print "ERROR: Unable to generate /bin/sh symlink:", msg
                exit(1)
        if not os.path.exists("%s/bin/bash" % stage2_dir):
            try:
                os.symlink("../usr/bin/bash", "%s/bin/bash" % stage2_dir)
            except Exception, msg:
                print "ERROR: Unable to generate /bin/bash symlink:", msg
                exit(1)
        if not os.path.exists("%s/etc/mtab" % stage2_dir):
            try:
                fd = open("%s/etc/mtab" % stage2_dir, "w")
            except Exception, msg:
                print "ERROR: Unable to generate /etc/mtab:", msg
                exit(1)
            fd.close()

        # create needed devices
        if not os.path.exists(stage2_dir+"/dev/console"):
            os.mknod(stage2_dir+"/dev/console", 0666 | stat.S_IFCHR,
                     os.makedev(5, 1))
        if not os.path.exists(stage2_dir+"/dev/null"):
            os.mknod(stage2_dir+"/dev/null", 0666 | stat.S_IFCHR,
                     os.makedev(1, 3))
        if not os.path.exists(stage2_dir+"/dev/zero"):
            os.mknod(stage2_dir+"/dev/zero", 0666 | stat.S_IFCHR,
                     os.makedev(1, 5))

        # create disk and partition devices
        for disk in diskmap:
            stats = os.stat(diskmap[disk]["device"])
            tmpdev = "%s/%s" % (stage2_dir, diskmap[disk]["device"])
            os.mknod(tmpdev, stats.st_mode, stats.st_rdev)
        for onpart in partitionmap:
            stats = os.stat(partitionmap[onpart]["device"])
            tmpdev = "%s/%s" % (stage2_dir, partitionmap[onpart]["device"])
            os.mknod(tmpdev, stats.st_mode, stats.st_rdev)

        # test if bash is runnable in changeroot
        (status, rusage) = pyrpm.runScript( \
            script="/bin/bash --version 2>&1 >/dev/null", chroot=stage2_dir)
        if status != 0:
            print "/bin/bash in stage2 is not usable, exiting."
            exit(1)

        mke2fs_prog = "/usr/sbin/mke2fs"
        tune2fs_prog = "/usr/sbin/tune2fs"
        mkswap_prog = "/usr/sbin/mkswap"
        chroot = stage2_dir
    else: # no stage2
        mke2fs_prog = "/sbin/mke2fs"
        tune2fs_prog = "/sbin/tune2fs"
        mkswap_prog = "/sbin/mkswap"
        chroot = None
        
    ### format partitions ###
    
    for onpart in to_format:
        name = partitionmap[onpart]["name"]
        label = partitionmap[onpart]["label"]
        disk = partitionmap[onpart]["disk"]
        part = partitions[name]

        if part.has_key("fstype") and \
               (part["fstype"] == "ext2" or part["fstype"] == "ext3"):
            mke2fs = "%s -q -L '%s'" % (mke2fs_prog, label)
            if part["fstype"] == "ext3":
                mke2fs += " -j"
            if diskmap[disk].has_key("image"):
                blocksize = 4096
                mke2fs += " -b %d" % blocksize
            mke2fs += " '%s'" % partitionmap[onpart]["device"]
            if diskmap[disk].has_key("image"):
                mke2fs += " %d" % (partitionmap[onpart]["size"] / blocksize)

#            print mke2fs
            print "Formatting '%s' on '%s' (%s)" % \
                  (onpart, partitionmap[onpart]["disk"], name)

            (status, rusage) = pyrpm.runScript(script=mke2fs, chroot=chroot)
            if status != 0:
                print "ERROR: mke2fs failed."
                exit(1)

            if part["fstype"] == "ext3": # set ext options
                tune2fs = "%s -c 0 -i 0 -O dir_index '%s'" % \
                          (tune2fs_prog, partitionmap[onpart]["device"])

#                print tune2fs
                if verbose:
                    print "Tuning filesystem '%s' on '%s'" % \
                          (onpart, partitionmap[onpart]["disk"])

                (status, rusage) = pyrpm.runScript(script=tune2fs,
                                                   chroot=chroot)
                if status != 0:
                    print "ERROR: tune2fs failed."
                    exit(1)

        elif name == "swap":
            l = ""
            if install_version != "RHEL-3" and install_version != "FC-2":
                # no swap labels for RHEL-3, FC-1
                l = "-L '%s'" % label
            mkswap = "%s %s '%s' %d >/dev/null" % \
                     (mkswap_prog, l, partitionmap[onpart]["device"],
                      (partitionmap[onpart]["size"] / 1024))

#            print mkswap
            print "Formatting '%s' on '%s' (%s)" % \
                  (onpart, partitionmap[onpart]["disk"], name)

            (status, rusage) = pyrpm.runScript(script=mkswap, chroot=chroot)
            if status != 0:
                print "ERROR: mkswap failed."
                exit(1)
        else:
            print "ERROR: Unknown filesystem for '%s' (%s)" % \
                  (partitionmap[onpart]["disk"], name)
            exit(1)

    del to_format
    ### format end ###

    if not no_stage2:
        # umount real stage2 mount
        if verbose:
            print "Umounting '%s' " % stage2_dir
        pyrpm.umount(stage2_dir)

if not no_stage2:
    # umount temporary stage2 mount
    if verbose:
        print "Umounting '%s' " % stage2_img_dir
    pyrpm.umount(stage2_img_dir)
    stage2_img_dir = None

### mount target ###

os.mkdir(target_dir)

# prepare to format partitions
to_mount = [ ]
mountmap = { }
for onpart in partitionmap:
    name = partitionmap[onpart]["name"]
    to_mount.append(name)
    mountmap[name] = onpart
to_mount.sort()

for mntpnt in to_mount:
    if mntpnt == "swap":
        if standalone:
            # swapon if in standalone mode
            if pyrpm.swapon(partitionmap[mountmap[mntpnt]]["device"]) == 1:
                exit(1)
            partitionmap[mountmap[mntpnt]]["on"] = None
    else:
        if mntpnt == "/":
            dir = target_dir
        else:
            dir = target_dir+mntpnt
            if not os.path.exists(dir):
                try:
                    os.mkdir(dir)
                except Exception, msg:
                    print "ERROR: Could not create '%s': %s" % (dir, msg)
                    exit(1)

        part = partitions[mntpnt]

        if verbose:
            print "Mounting '%s' on '%s'" %\
                  (partitionmap[mountmap[mntpnt]]["device"], dir)
        try:
            pyrpm.mount(partitionmap[mountmap[mntpnt]]["device"], dir,
                        fstype=part["fstype"])
        except Exception, msg:
            print msg
            exit(1)

buildroot = target_dir
pyrpm.rpmconfig.buildroot = buildroot

### package selection ###

if ks.has_key("install"):
    # set default group "base" if no groups are specified
    if not ks["packages"] or \
           not ks["packages"].has_key("groups") or \
           len(ks["packages"]["groups"]) == 0:
        groups = [ "base" ]
    else:
        groups = ks["packages"]["groups"]
        pyrpm.normalizeList(groups)

    languages = [ ]
    if ks["langsupport"]:
        if ks["langsupport"].has_key("default"):
            languages.append(ks["langsupport"]["default"][:2])
        for lang in ks["langsupport"]["supported"]:
            languages.append(lang[:2])
        pyrpm.normalizeList(languages)

    # load comps file for groups and default packages
    comps = loadComps(source_dir)
    if not comps:
        print "Could not find comps file, exiting."
        exit(1)

    pkgs = [ ]

    # everything install
    if "everything" in groups:
        for group in comps.grouphash.values():
            if group.has_key("packagelist"):
                pkgs.extend(group["packagelist"])
    else:
        # add package for selected groups
        for group in groups:
            pkgs.extend(comps.getPackageNames(group))

        # add default desktop
        if ks["xconfig"] and ks["xconfig"].has_key("startxonboot"):
            pkgs.extend(comps.getPackageNames("base-x"))
            desktop = "GNOME"
            if ks["xconfig"].has_key("defaultdesktop"):
                desktop = ks["xconfig"]["defaultdesktop"]
            desktop = "%s-desktop" % desktop.lower()
            if not desktop in groups:
                print "Adding group %s" % desktop
                pkgs.extend(comps.getPackageNames(desktop))
        # TODO: add xorg driver package for FC-5
        if install_release == "FC" and install_version > "FC-4":
#            if ks["xconfig"].has_key("driver"):
#                pkgs.append("xorg-x11-drv-%s" % ks["xconfig"]["driver"])
#            else:
            if not "xorg-x11-drivers" in pkgs:
                pkgs.append("xorg-x11-drivers")

        # add comps package
        if not "comps" in pkgs:
            pkgs.append("comps")

        # append authconfig
        if ks["authconfig"]:
            print "Adding package providing /usr/bin/authconfig"
            pkgs.append("/usr/bin/authconfig")

        # append iptables
        if ks["firewall"] and not ks["firewall"].has_key("disabled") and \
               not "iptables" in pkgs:
            print "Adding package iptables"
            pkgs.append("iptables")
            # no firewall con
            if install_version != "RHEL-3":
                print "Adding package providing /usr/sbin/lokkit"
                pkgs.append("/usr/sbin/lokkit")

        if ks["selinux"] and install_version != "RHEL-3" and \
               not "/usr/sbin/lokkit" in pkgs:
            print "Adding package providing /usr/sbin/lokkit"
            pkgs.append("/usr/sbin/lokkit")

        # append kernel
        if not "kernel" in pkgs and not "kernel-smp" in pkgs:
            print "Adding package kernel"
            pkgs.append("kernel")

        # append firstboot
        if ks["firstboot"] and not ks["firstboot"].has_key("disabled") and \
               not "firstboot" in pkgs:
            print "Adding package firstboot"
            pkgs.append("firstboot")

        # append dhclient
        if ks["network"] and ks["network"]["bootproto"] == "dhcp" and \
               not "dhclient" in pkgs:
            print "Adding package dhclient"
            pkgs.append("dhclient")

        # get langsupport packages
        pkgs.extend(compsLangsupport(comps, languages))

    # load additional comps files
    if repo_comps:
        for repo in repos:
            _comps = loadComps(repos[repo])
            if _comps:
                print "Using additional comps in repository %s" % repo
                if "everything" in groups:
                    for group in _comps.grouphash.values():
                        if group.has_key("packagelist"):
                            pkgs.extend(group["packagelist"])
                else:
                    # add package for selected groups
                    for group in groups:
                        pkgs.extend(_comps.getPackageNames(group))
                pkgs.extend(compsLangsupport(_comps, languages))
                del _comps

    # add and remove packages from package list
    if ks["packages"] and ks["packages"].has_key("drop"):
        for pkg in ks["packages"]["drop"]:
            if pkg in pkgs:
                pkgs.remove(pkg)
    if ks["packages"] and ks["packages"].has_key("add"):
        for pkg in ks["packages"]["add"]:
            if not pkg in pkgs:
                pkgs.append(pkg)

    del comps
    pyrpm.normalizeList(pkgs)

    # no packages?
    if len(pkgs) < 1:
        print "Nothing to do."
        exit(1)

# else: upgrade
# ignore package selection


# create essential directories and files
os.umask(022)

create_dir(buildroot, "/boot")
create_dir(buildroot, "/boot/grub")
create_dir(buildroot, "/dev")
create_dir(buildroot, "/etc")
create_dir(buildroot, "/etc/rpm")
create_dir(buildroot, "/etc/sysconfig")
if install_version != "RHEL-3":
    create_dir(buildroot, "/sys")
create_dir(buildroot, "/tmp")
os.chmod(buildroot+"/tmp", 1777)
create_dir(buildroot, "/var")
create_dir(buildroot, "/var/log")
create_dir(buildroot, "/var/tmp")
os.chmod(buildroot+"/var/tmp", 1777)

# /dev
if not os.path.exists(buildroot+"/dev/console"):
    os.mknod(buildroot+"/dev/console", 0666 | stat.S_IFCHR, os.makedev(5, 1))
if not os.path.exists(buildroot+"/dev/null"):
    os.mknod(buildroot+"/dev/null", 0666 | stat.S_IFCHR, os.makedev(1, 3))
if not os.path.exists(buildroot+"/dev/zero"):
    os.mknod(buildroot+"/dev/zero", 0666 | stat.S_IFCHR, os.makedev(1, 5))

if ks.has_key("install"):
    # /etc/sysconfig/kernel
    if not os.path.exists(buildroot+"/etc/sysconfig/kernel"):
        print "Configuring kernel"
        try:
            fd = open(buildroot+"/etc/sysconfig/kernel", "w")
        except Exception, msg:
            print "ERROR: Configuration of '/etc/sysconfig/kernel' failed:", msg
        else:
            fd.write('# UPDATEDEFAULT specifies if new-kernel-pkg should make\n')
            fd.write('# new kernels the default\n')
            fd.write('UPDATEDEFAULT=yes\n')
            fd.write('\n')
            fd.write('# DEFAULTKERNEL specifies the default kernel package type\n')
            fd.write('DEFAULTKERNEL=kernel\n')
            fd.close()

# /etc/fstab
if ks.has_key("install") and not os.path.exists(buildroot+"/etc/fstab"):
    print "Configuring '/etc/fstab'"
    try:
        fd = open(buildroot+"/etc/fstab", "w")
    except Exception, msg:
        print "ERROR: Configuration of '/etc/fstab' failed:", msg
    else:
        partition = partitionmap.keys()
        partition.sort()
        partition.reverse()
        for onpart in partition:
            name = partitionmap[onpart]["name"]
            part = partitions[name]

            major = minor = 0
            if part.has_key("fstype") and name != "swap":
                fs = part["fstype"]
                major = 1
                if name == "/":
                    minor = 1
                else:
                    minor = 2
                fd.write("LABEL=%s\t\t%s\t\t%s\tdefaults\t%d %d\n" % \
                         (partitionmap[onpart]["label"], name, fs, major, minor))
            elif name == "swap":
                continue
            else:
                print "ERROR: Unknown filesystem for '%s' (%s)" % \
                      (partitionmap[onpart]["disk"], name)
                continue
        fd.write("none\t\t/dev/pts\t\tdevpts\tgid=5,mode=620\t0 0\n")
        fd.write("none\t\t/dev/shm\t\ttmpfs\tdefaults\t0 0\n")
        fd.write("none\t\t/proc\t\tproc\tdefaults\t0 0\n")
        if install_version != "RHEL-3":
            fd.write("/dev/sys\t\t/sys\t\tsysfs\tdefaults\t0 0\n")
        for onpart in partition:
            if partitionmap[onpart]["name"] == "swap":
                if install_version == "RHEL-3" or install_version == "FC-2":
                    # RHEL-3, FC-2 does not support swap labels
                    what = "/dev/%s" % onpart
                else:
                    what = "LABEL=%s" % partitionmap[onpart]["label"]
                fd.write("%s\t\t%s\t\t%s\tdefaults\t0 0\n" % \
                         (what, partitionmap[onpart]["name"],
                          partitionmap[onpart]["name"]))
        fd.close()

# /etc/hosts
if ks.has_key("install") and not os.path.exists(buildroot+"/etc/hosts"):
    try:
        fd = open(buildroot+"/etc/hosts", "w")
    except Exception, msg:
        print "ERROR: Configuration of '/etc/hosts' failed:", msg
    else:
        fd.write("# Do not remove the following line, or various programs\n")
        fd.write("# that require network functionality will fail.\n")
        hostname = ""
        if ks["network"].has_key("hostname") and \
               not ks["network"].has_key("ip"):
            hostname = "%s\t" % ks["network"]["hostname"]
        fd.write("127.0.0.1\t\t%slocalhost.localdomain\tlocalhost\n" % \
                 hostname)
        if ks["network"].has_key("hostname") and ks["network"].has_key("ip"):
            fd.write("%s\t\t%s\n" % (ks["network"]["ip"],
                                     ks["network"]["hostname"]))
        fd.close()

# /etc/resolv.conf
if ks.has_key("install") and not os.path.exists(buildroot+"/etc/resolv.conf"):
    try:
        fd = open(buildroot+"/etc/resolv.conf", "w")
    except Exception, msg:
        print "ERROR: Configuration of '/etc/resolv.conf' failed:", msg
    else:
        if ks["network"]:
            if ks["network"].has_key("hostname"):
                hostname = ks["network"]["hostname"]
                idx = string.find(hostname, ".")
                if idx >= 0:
                    domainname = hostname[(idx+1):]
                    fd.write("search %s\n" % domainname)
            else:
                fd.write("search localdomain\n")
            if ks["network"].has_key("nameserver") and \
                   not ks["network"].has_key("nodns"):
                for server in ks["network"]["nameserver"]:
                    fd.write("nameserver %s\n" % server)
            else:
                fd.write("nameserver 127.0.0.1\n")
        fd.close()

# /etc/modprobe.conf and /etc/modules.conf
if ks.has_key("install"):
    if install_version == "RHEL-3":
        conf = "/etc/modules.conf"
    else:
        conf = "/etc/modprobe.conf"
    if not os.path.exists(buildroot+conf):
        try:
            fd = open(buildroot+conf, "w")
        except Exception, msg:
            print "ERROR: Configuration of '%s' failed:" % conf, msg
        else:
            adapter = 0
            # add options for defined devices in ks["device"]
            if ks["device"] and len(ks["device"]) > 0:
                for type in ks["device"]:
                    if ks["device"][type] and len(ks["device"][type]) > 0:
                        for module in ks["device"][type]:
                            if type == "scsi":
                                if adapter == 0:
                                    fd.write('alias scsi_hostadapter %s\n' % \
                                             module)
                                else:
                                    fd.write('alias scsi_hostadapter%d %s\n' % \
                                             adapter, module)
                            if ks["device"][type][module].has_key("opts"):
                                fd.write('options %s %s\n' % \
                                         (module,
                                          ks["device"][type][module]["opts"]))
            fd.close()

# /etc/rpm/platform
if ks.has_key("install") and not os.path.exists(buildroot+"/etc/rpm/platform"):
    try:
        fd = open(buildroot+"/etc/rpm/platform", "w")
    except Exception, msg:
        print "ERROR: Configuration of '/etc/rpm/platform' failed:", msg
    else:
        # TODO: use arch of installed system
        fd.write("%s-redhat-linux" % pyrpm.rpmconfig.machine)
        fd.close()

# /var/log/lastlog
if ks.has_key("install") and not os.path.exists(buildroot+"/var/log/lastlog"):
    try:
        fd = open(buildroot+"/var/log/lastlog", "w")
    except Exception, msg:
        print "ERROR: Creation of '/var/log/lastlog' failed:", msg
    else:
        fd.close()

# /var/log/messages
if ks.has_key("install") and not os.path.exists(buildroot+"/var/log/messages"):
    try:
        fd = open(buildroot+"/var/log/messages", "w")
    except Exception, msg:
        print "ERROR: Creation of '/var/log/messages' failed:", msg
    else:
        fd.close()

# print previous installed release
if ks.has_key("upgrade"):
    f = target_dir+"/etc/redhat-release"
    if not os.path.exists(f):
        f = target_dir+"/etc/fedora-release"
    if os.path.exists(f):
        try:
            fd = open(f)
        except:
            pass
        else:
            lines = fd.readlines()
            fd.close()
            if lines:
                print "Detected '%s' installation" % \
                      string.strip(string.join(lines))

### installation ###

if ks.has_key("install"):
    print "Preparing installation"
else:
    print "Preparing upgrade"

# configure yum
os.mkdir("%s/yum.cache" % tempdir)
os.mkdir("%s/yum.repos.d" % tempdir)
yum_conf = tempdir+"/yum.conf"
try:
    fd = open(yum_conf, "w")
except Exception, msg:
    print "ERROR: Configuration of the yum failed:", msg
    exit(1)
fd.write("[main]\n")
fd.write("cachedir=%s/yum.cache\n" % tempdir)
fd.write("debuglevel=0\n")
fd.write("errorlevel=0\n")
fd.write("pkgpolicy=newest\n")
fd.write("distroverpkg=redhat-release\n")
fd.write("tolerant=1\n")
fd.write("exactarch=1\n")
fd.write("retries=20\n")
fd.write("obsoletes=1\n")
fd.write("reposdir=%s/yum.repos.d\n" % tempdir)
if ks.has_key("install") and ks["packages"] and ks["packages"].has_key("drop"):
    fd.write("exclude=%s\n" % string.join(ks["packages"]["drop"]))
fd.write("\n")
fd.write("[dist %s]\n" % install_version)
fd.write("name=dist %s\n" % install_version)
fd.write("baseurl=file://%s\n" % source_dir)
fd.write("\n")
# add repos
for repo in repos:
    fd.write("[%s]\n" % repo)
    fd.write("name=%s\n" % repo)
    fd.write("baseurl=file://%s\n" % repos[repo])
    fd.write("\n")
fd.close()

# yum
if orig_yum:
    yum = "yum -y -c '%s' --installroot='%s'" % (yum_conf, buildroot)
else:
    yum = "PYTHONPATH=%s PATH=%s:${PATH} pyrpmyum -y --hash -c '%s' -r '%s'" %\
          (PYRPMDIR, PYBINDIR, yum_conf, buildroot)
    # --servicehack
if ks["packages"] and ks["packages"].has_key("ignoredeps") and \
       ks["packages"].has_key("ignoremissing"):
    yum += " --nodeps"
if ks.has_key("install"):
    yum += " install "
    yum += string.join(pkgs)
else:
    if not orig_yum:
        yum += " --autoerase "
    yum += " update "
#print yum
pid = os.fork()
if pid != 0:
    (rpid, status) = os.waitpid(pid, 0)
    if status != 0:
        if ks.has_key("install"):
            print "ERROR: Installation failed, aborting."
        else:
            print "ERROR: Upgrade failed, aborting."
        exit(1)
else:
    if os.system(yum) != 0:
        sys.exit(255)
    sys.exit(0)
    
### configuration ###

# check system dirs
if not check_dir(buildroot, "/etc") or \
       not check_dir(buildroot, "/etc/sysconfig"):
    print "Aborting."
    exit(1)

## run kudzu
if ks.has_key("install") and kudzu:
    print "Running kudzu"

    if not os.path.exists(buildroot+"/usr/sbin/kudzu"):
        print "ERROR: /usr/sbin/kudzu does not exist, skipping."
    else:
        (status, rusage) = pyrpm.runScript(script="/usr/sbin/kudzu -q -s",
                                           chroot=buildroot)
        if status != 0:
            print "ERROR: kudzu failed."

# run authconfig if set
if ks.has_key("install") and ks["authconfig"]:
    print "Configuring authentication"

    # Create /etc/samba for authconfig
    if not os.path.exists(buildroot+"/etc/samba"):
        os.mkdir(buildroot+"/etc/samba")

    if not os.path.exists(buildroot+"/usr/bin/authconfig"):
        print "ERROR: /usr/bin/authconfig does not exist, skipping."
    else:
        authconfig = "/usr/bin/authconfig --kickstart --nostart"
        for tag in ks["authconfig"]:
            if ks["authconfig"][tag]:
                authconfig += " --%s=%s" % (tag, ks["authconfig"][tag])
            else:
                authconfig += " --%s" % tag
        (status, rusage) = pyrpm.runScript(script=authconfig, chroot=buildroot)
        if status != 0:
            print "ERROR: authconfig failed"

# setting root password
if ks.has_key("install") and ks["rootpw"]:
    print "Setting root password"

    if not os.path.exists(buildroot+"/usr/sbin/usermod"):
        print "ERROR: /usr/sbin/usermod does not exist, skipping."
    else:
        password = ks["rootpw"].keys()[0]
        if not ks["rootpw"][password].has_key("iscrypted"):
            salt = ""
            salt_len = 2
            if ks["authconfig"].has_key("enablemd5"):
                salt = "$1$"
                salt_len = 8
            for i in range(salt_len):
                salt += random.choice(string.letters+string.digits+"./")
            password = crypt.crypt(password, salt)
        (status, rusage) = pyrpm.runScript( \
                script="/usr/sbin/usermod -p '%s' root" % password,
                chroot=buildroot)
        if status != 0:
            print "ERROR: Setting root password failed"

# /etc/inittab
if ks.has_key("install") and \
       ks["xconfig"] and ks["xconfig"].has_key("startxonboot"):
    print "Configuring runlevel"

    try:
        fd_in = open(buildroot+"/etc/inittab", "r")
        fd_out = open(buildroot+"/etc/inittab.pyrpmkickstart", "w")
    except Exception, msg:
        print "ERROR: Configuration of '/etc/inittab' failed:", msg
    else:
        while 1:
            line = fd_in.readline()
            if not line:
                break
            if len(line) > 3 and line[:3] == "id:":
                id = string.split(line, ":")
                if len(id) > 1:
                    id[1] = "5"
                    line = string.join(id, ":")
                else:
                    print "ERROR: Malformed '/etc/inittab'"
            fd_out.write(line)
        fd_in.close()
        fd_out.close()
        os.unlink(buildroot+"/etc/inittab")
        os.rename(buildroot+"/etc/inittab.pyrpmkickstart",
                  buildroot+"/etc/inittab")

# /etc/sysconfig/selinux
if ks.has_key("install") and ks["selinux"] and install_version != "RHEL-3":
    print "Configuring selinux"

    if not os.path.exists(buildroot+"/usr/sbin/lokkit"):
        print "ERROR: /usr/sbin/lokkit does not exist, skipping."
    else:
        lokkit = "/usr/sbin/lokkit --quiet --nostart --selinux='%s'" % \
                 ks["selinux"].keys()[0]
        (status, rusage) = pyrpm.runScript(script=lokkit, chroot=buildroot)
        if status != 0:
            print "ERROR: Configuring selinux failed."

# /etc/sysconfig/clock
if ks.has_key("install") and ks["timezone"]:
    print "Configuring timezone"
    zone = ks["timezone"].keys()[0]
    try:
        fd = open(buildroot+"/etc/sysconfig/clock", "w")
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/clock' failed:", msg
    else:
        fd.write('ZONE="%s"\n' % zone)
        if ks["timezone"][zone].has_key("utc"):
            fd.write('UTC=true\n')
        else:
            fd.write('UTC=false\n')
        fd.write('ARC=false\n')
        fd.close()

    tzfile = "/usr/share/zoneinfo/" + zone
    if not os.path.exists(buildroot+tzfile):
        print "ERROR: %s does not exist, skipping." % tzfile
    else:
        # Create /etc/localtime
        # do not hardlink /etc/localtime, has to be copy for
        # system-config-date
        (status, rusage) = pyrpm.runScript( \
                script="rm -f /etc/localtime; cp '%s' /etc/localtime" % tzfile,
                chroot=buildroot)
        if status != 0:
            print "ERROR: Could not create /etc/localtime."

if ks.has_key("install"):
    # /etc/sysconfig/desktop
    print "Configuring desktop"
    desktop = "GNOME"
    if ks["xconfig"] and ks["xconfig"].has_key("defaultdesktop"):
        desktop = ks["xconfig"]["defaultdesktop"]
    try:
        fd = open(buildroot+"/etc/sysconfig/desktop", "w")
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/desktop' failed:", msg
    else:
        fd.write('DESKTOP="%s"\n' % desktop)
        fd.close()

# /etc/sysconfig/i18n
if ks["langsupport"]:
    print "Configuring languages"
    try:
        fd = open(buildroot+"/etc/sysconfig/i18n", "w")
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/i18n' failed:", msg
    else:
        if ks["langsupport"].has_key("default"):
            fd.write('LANG="%s"\n' % ks["langsupport"]["default"])
            if ks["langsupport"].has_key("supported") and \
                   len(ks["langsupport"]["supported"]) > 0:
                fd.write('SUPPORTED="%s"\n' % \
                         string.join(ks["langsupport"]["supported"], ":"))
        else:
            fd.write('LANG="%s"\n' % \
                     string.join(ks["langsupport"]["supported"], ":"))
        fd.write('SYSFONT="latarcyrheb-sun16"\n')
        fd.close()

# /etc/sysconfig/installinfo
if ks.has_key("install"):
    print "Configuring installinfo"
    try:
        fd = open(buildroot+"/etc/sysconfig/installinfo", "w")
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/installinfo' failed:", \
              msg
    else:
        method = ""
        for key in [ "cdrom", "harddrive", "nfs", "url" ]:
            if ks[key]:
                method = key
                break
        fd.write('INSTALLMETHOD=%s\n' % method)
        fd.close()

# /etc/sysconfig/iptables
if ks.has_key("install") and \
       ks["firewall"] and not ks["firewall"].has_key("disabled"):
    print "Configuring firewall"

    if install_version == "RHEL-3":
        # lokkit is not able to configure firewall for RHEL-3

        try:
            fd = open(buildroot+"/etc/sysconfig/iptables", "w")
        except Exception, msg:
            print "ERROR: Configuration of '/etc/sysconfig/iptables' failed:", \
                  msg
        else:
            fd.write('# Firewall configuration written by pyrpmkickstart\n')
            fd.write('# Manual customization of this file is not recommended.\n')
            fd.write('*filter\n')
            fd.write(':INPUT ACCEPT [0:0]\n')
            fd.write(':FORWARD ACCEPT [0:0]\n')
            fd.write(':OUTPUT ACCEPT [0:0]\n')
            fd.write(':RH-Firewall-1-INPUT - [0:0]\n')
            fd.write('-A INPUT -j RH-Firewall-1-INPUT\n')
            fd.write('-A FORWARD -j RH-Firewall-1-INPUT\n')
            fd.write('-A RH-Firewall-1-INPUT -i lo -j ACCEPT\n')
            # add truted devices
            if ks["firewall"].has_key("trusted"):
                for iface in ks["firewall"]["trusted"]:
                    fd.write('-A RH-Firewall-1-INPUT -i %s -j ACCEPT\n' % iface)
            fd.write('-A RH-Firewall-1-INPUT -p icmp --icmp-type any -j ACCEPT\n')
            fd.write('-A RH-Firewall-1-INPUT -p 50 -j ACCEPT\n')
            fd.write('-A RH-Firewall-1-INPUT -p 51 -j ACCEPT\n')
            fd.write('-A RH-Firewall-1-INPUT -p udp --dport 5353 -d 224.0.0.251 -j ACCEPT\n')
            fd.write('-A RH-Firewall-1-INPUT -p udp -m udp --dport 631 -j ACCEPT\n')
            fd.write('-A RH-Firewall-1-INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n')
            if ks["firewall"].has_key("ports"):
                ports = ks["firewall"]["ports"][:]
                ports.sort()
                for port in ports:
                    fd.write('-A RH-Firewall-1-INPUT -m state --state NEW -m %s -p %s --dport %d -j ACCEPT\n' % (port[1], port[1], port[0]))
            fd.write('-A RH-Firewall-1-INPUT -j REJECT --reject-with icmp-host-prohibited\n')
            fd.write('COMMIT\n')
            fd.close()

        # enable firewall
        if ks["firewall"].has_key("enabled"):
            (status, rusage) = pyrpm.runScript( \
                    script="/sbin/chkconfig iptables on", chroot=buildroot)
            if status != 0:
                print "ERROR: Could not enable firewall."
    else:
        # use lokkit to configure firewall

        if not os.path.exists(buildroot+"/usr/sbin/lokkit"):
            print "ERROR: /usr/sbin/lokkit does not exist, skipping."
        else:
            args = [ ]
            if ks["firewall"].has_key("enabled"):
                args.append("--enabled")
            if ks["firewall"].has_key("disabled"):
                args.append("--disabled")
            if ks["firewall"].has_key("trusted"):
                for trusted in ks["firewall"]["trusted"]:
                    args.append("--trusted=%s\n" % trusted)
            if ks["firewall"].has_key("ports"):
                for port in ks["firewall"]["ports"]:
                    args.append("--port=%s:%s\n" % (port[0], port[1]))

            lokkit = "/usr/sbin/lokkit --quiet --nostart -f %s" % \
                     string.join(args)
            (status, rusage) = pyrpm.runScript(script=lokkit, chroot=buildroot)
            if status != 0:
                print "ERROR: Configuration of firewall failed"

            try:
                fd = open(buildroot+"/etc/sysconfig/system-config-securitylevel", "w")
            except Exception, msg:
                print "ERROR: Configuration of '/etc/sysconfig/system-config-securitylevel' failed:", msg
            else:
                fd.write('# Configuration file for system-config-securitylevel\n')
                fd.write('\n')
                for arg in args:
                    fd.write('%s\n' % arg)
                fd.close()

# /etc/sysconfig/keyboard
if ks["keyboard"]:
    print "Configuring keyboard"
    try:
        fd = open(buildroot+"/etc/sysconfig/keyboard", "w")
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/keyboard' failed: ", msg
    else:
        fd.write('KEYBOARDTYPE="pc"\n')
        fd.write('KEYTABLE="%s"\n' % ks["keyboard"])
        fd.close()

# /etc/sysconfig/mouse
if ks.has_key("install"):
    print "Configuring generic IMPS/2 mouse"
    if not os.path.exists(buildroot+"/usr/sbin/mouseconfig"):
        print "ERROR: /usr/sbin/mouseconfig does not exist, skipping."
    else:
        (status, rusage) = pyrpm.runScript( \
                script="/usr/sbin/mouseconfig --noui genericwheelps/2",
                chroot=buildroot)
        if status != 0:
            print "ERROR: mouseconfig failed"

# setup networking
if ks.has_key("install") and ks["network"]:
    print "Configuring network"
    try:
        fd = open(buildroot+"/etc/sysconfig/network", "w")
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/network' failed:", msg
    else:
        fd.write('NETWORKING=yes\n')
        if ks["network"].has_key("hostname"):
            fd.write('HOSTNAME=%s\n' % ks["network"]["hostname"])
        else:
            fd.write('HOSTNAME=localhost.localdomain\n')
#        if ks["network"].has_key("gateway"):
#            fd.write('GATEWAY=%s\n' % ks["network"]["gateway"])
        fd.close()

    device = "eth0"
    if ks["network"].has_key("device"):
        device = ks["network"]["device"]

    if device[:3] == "ctc":
        type = "CTC"
    elif device[:4] == "iucv":
        type = "IUCV"
    elif device[:2] == "tr":
        type = '"Token Ring"'
    else:
        type = "Ethernet"

    bootproto = "none"
    if ks["network"]["bootproto"] and \
           ks["network"]["bootproto"] != "static":
        bootproto = ks["network"]["bootproto"]

    if not os.path.exists(buildroot+"/etc/sysconfig/network-scripts"):
        os.mkdir(buildroot+"/etc/sysconfig/network-scripts")
    try:
        fd = open(buildroot+"/etc/sysconfig/network-scripts/ifcfg-%s" % \
                  device, "w")
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/network-scripts/ifcfg-%s' failed:" % device, msg
    else:
        fd.write('DEVICE=%s\n' % device)
        fd.write('BOOTPROTO=%s\n' % bootproto)
        if ks["network"].has_key("gateway"):
            fd.write('GATEWAY=%s\n' % ks["network"]["gateway"])
        if ks["network"].has_key("netmask"):
            fd.write('NETMASK=%s\n' % ks["network"]["netmask"])
        if ks["network"].has_key("ip"):
            fd.write('IPADDR=%s\n' % ks["network"]["ip"])
        if ks["network"].has_key("essid"):
            fd.write('ESSID=%s\n' % ks["network"]["essid"])
        if ks["network"].has_key("ethtool"):
            fd.write('ETHTOOL_OPTS=%s\n' % ks["network"]["ethtool"])
        if ks["network"].has_key("class"):
            fd.write('DHCP_CLASSID=%s\n' % ks["network"]["class"])
        if ks["network"].has_key("onboot"):
            fd.write('ONBOOT=%s\n' % ks["network"]["onboot"])
        else:
            fd.write('ONBOOT=yes\n')
        fd.write('TYPE=%s\n' % type)
        fd.close()

    if ks["network"].has_key("wepkey"):
        try:
            fd = open(buildroot+"/etc/sysconfig/network-scripts/keys-%s" % \
                      ks["network"]["device"], "w")
        except Exception, msg:
            print "ERROR: Configuration of '/etc/sysconfig/network-scripts/keys-%s' failed:" % ks["network"]["device"], msg
        else:
            fd.write('KEY=%s\n' % ks["network"]["wepkey"])
            fd.close()

# /etc/X11/xorg.conf
if ks.has_key("install") and ks["xconfig"]:
    print "Configuring X"

    # default: VGA graphics card, Generic extended super VGA monitor
    card = "Unknown video card"
    driver = "vga"
    videoram = 0
    monitor = "Unknown monitor"
    hsync = "31.5 - 37.9"
    vsync = "50 - 61"
    resolution = "800x600"
    depth = 8
    user_hsync = user_vsync = None
    options = [ ]

    # keyboard
    (kbd_layout, kbd_model, kbd_variant, kbd_options) = \
                 keyboard_models[ks["keyboard"]]

    kscard = None
    if ks["xconfig"].has_key("card"):
        kscard = ks["xconfig"]["card"]
    ksdriver = None
    if ks["xconfig"].has_key("driver"):
        ksdriver = ks["xconfig"]["driver"]
    ksoptions = [ ]

    if os.path.exists(buildroot+'/usr/share/hwdata/Cards'):
        if ksdriver and not kscard:
            print "ERROR: Card not specified, using default configuration."
        else:
            try:
                fd = open(buildroot+'/usr/share/hwdata/Cards')
            except:
                print "ERROR: Unable to open graphics card database."
            else:
                # TODO: honour SEE tags in file
                found = 0
                _card = None
                _driver = None
                _options = [ ]
                while 1:
                    line = fd.readline()
                    if not line:
                        break
                    line = string.strip(line)
                    if len(line) < 1 or line[0] == "#":
                        continue

                    if line[:4] == "NAME":
                        if kscard and kscard == _card:
                            card = _card
                            driver =_driver
                            options = _options
                            found = 1
                            break
                        _card = string.strip(line[4:])
                        _driver = None
                        _options = [ ]
                    elif line[:6] == "DRIVER":
                        _driver = string.strip(line[6:])
                    elif line[:4] == "LINE":
                        _options.append(string.strip(line[4:]))
                    else:
                        continue
                fd.close()
                if not found:
                    print "ERROR: Card not found in graphics card database."

    elif os.path.exists(buildroot+'/usr/share/hwdata/videodrivers'):
        # There is no usable name in the videodrivers file, so fake it
        if ksdriver:
            driver = ksdriver
            card = driver + ' (generic)'
        else:
            print "ERROR: Driver not specified for xconfig, " +\
                  "using default configuration."
    else:
        print "ERROR: Could not find hardware database for video drivers."

    if ks["xconfig"].has_key("videoram"):
        videoram = ks["xconfig"]["videoram"]
    if ks["xconfig"].has_key("monitor"):
        try:
            fd = open(buildroot+'/usr/share/hwdata/MonitorsDB')
        except:
            print "ERROR: Unable to open monitor database."
        else:
            found = 0
            while 1:
                line = fd.readline()
                if not line:
                    break
                line = string.strip(line)
                if len(line) < 1 or line[0] == "#":
                    continue
                args = string.split(line, ";")
                if len(args) < 5:
                    continue
                if string.strip(args[1]) == ks["xconfig"]["monitor"]:
                    monitor = ks["xconfig"]["monitor"]
                    hsync = string.strip(args[3])
                    vsync = string.strip(args[4])
                    found = 1
                    break
            fd.close()
            if found != 1:
                print "ERROR: Monitor not found in hardware database."
    if ks["xconfig"].has_key("hsync"): # overwrite with user supplied value
        hsync = ks["xconfig"]["hsync"]
    if ks["xconfig"].has_key("vsync"):
        vsync = ks["xconfig"]["vsync"] # overwrite with user supplied value
    if ks["xconfig"].has_key("resolution"):
        resolution = ks["xconfig"]["resolution"]
    if ks["xconfig"].has_key("depth"):
        depth = ks["xconfig"]["depth"]


    if install_version == "RHEL-3":
        conf = "/etc/X11/XF86Config"
    else:
        conf = "/etc/X11/xorg.conf"

    try:
        fd = open(buildroot+conf, "w")
    except Exception, msg:
        print "ERROR: Configuration of '/etc/X11/xorg.conf' failed:", msg
    else:
        fd.write('Section "ServerLayout"\n')
        fd.write('        Identifier   "Default Layout"\n')
        fd.write('        Screen       0 "Screen0" 0 0\n')
        fd.write('        InputDevice  "Mouse0" "CorePointer"\n')
        fd.write('        InputDevice  "Keyboard0" "CoreKeyboard"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "Files"\n')
        fd.write('        RgbPath      "/usr/X11R6/lib/X11/rgb"\n')
        fd.write('        FontPath     "unix/:7100"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "Module"\n')
        fd.write('        Load         "dbe"\n')
        fd.write('        Load         "extmod"\n')
        fd.write('        Load         "fbdevhw"\n')
        fd.write('        Load         "record"\n')
        fd.write('        Load         "freetype"\n')
        fd.write('        Load         "type1"\n')
        fd.write('        Load         "glx"\n')
        fd.write('        Load         "dri"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "InputDevice"\n')
        fd.write('        Identifier   "Keyboard0"\n')
        fd.write('        Driver       "kbd"\n')
        fd.write('        Option       "XkbModel" "%s"\n' % kbd_model)
        fd.write('        Option       "XkbLayout" "%s"\n' % kbd_layout)
        if kbd_variant and len(kbd_variant) > 0:
            fd.write('        Option       "XkbVariant" "%s"\n' % kbd_variant)
        if kbd_options and len(kbd_options) > 0:
            fd.write('        Option       "XkbOptions" "%s"\n' % kbd_options)
        fd.write('EndSection\n\n')
        fd.write('Section "InputDevice"\n')
        fd.write('        Identifier   "Mouse0"\n')
        fd.write('        Driver       "mouse"\n')
        fd.write('        Option       "Protocol" "IMPS/2"\n')
        if install_version == "RHEL-3":
            fd.write('        Option       "Device" "/dev/mouse"\n')
        else:
            fd.write('        Option       "Device" "/dev/input/mice"\n')
        fd.write('        Option       "ZAxisMapping" "4 5"\n')
        fd.write('        Option       "Emulate3Buttons" "no"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "Monitor"\n')
        fd.write('        Identifier   "Monitor0"\n')
        fd.write('        VendorName   "Monitor Vendor"\n')
        fd.write('        ModelName    "%s"\n' % monitor)
        if hsync:
            fd.write('        HorizSync    %s\n' % hsync)
        if vsync:
            fd.write('        VertRefresh  %s\n' % vsync)
        fd.write('        Option       "dpms"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "Device"\n')
        fd.write('        Identifier   "Videocard0"\n')
        fd.write('        VendorName   "Videocard vendor"\n')
        fd.write('        BoardName    "%s"\n' % card)
        fd.write('        Driver       "%s"\n' % driver)
        if videoram:
            fd.write('        VideoRam     %s\n' % videoram)
        if len(options) > 0:
            for option in options:
                fd.write('        %s\n' % option)
        fd.write('EndSection\n\n')
        fd.write('Section "Screen"\n')
        fd.write('        Identifier   "Screen0"\n')
        fd.write('        Device       "Videocard0"\n')
        fd.write('        Monitor      "Monitor0"\n')
        fd.write('        DefaultDepth %s\n' % depth)
        fd.write('        SubSection "Display"\n')
        fd.write('                Viewport 0 0\n')
        fd.write('                Depth    %s\n' % depth)
        fd.write('                Modes    "%s"\n' % resolution)
        fd.write('        EndSubSection\n')
        fd.write('EndSection\n\n')
        if install_version != "RHEL-3":
            fd.write('Section "DRI"\n')
            fd.write('        Group        0\n')
            fd.write('        Mode         0666\n')
            fd.write('EndSection\n')
        fd.close()

# /etc/sysconfig/firstboot
if ks.has_key("install") and ks["firstboot"]:
    print "Configuring firstboot"
    if ks["firstboot"].has_key("reconfig"):
        try:
            fd = open(buildroot+"/etc/reconfigSys", "w")
        except Exception, msg:
            print "ERROR: Configuration of '/etc/reconfigSys' failed:", msg
        else:
            fd.close()
    if ks["firstboot"].has_key("disabled"):
        try:
            fd = open(buildroot+"/etc/sysconfig/firstboot", "w")
        except Exception, msg:
            print "ERROR: Configuration of '/etc/syscofig/firstboot' failed:",\
                  msg
        else:
            fd.write('RUN_FIRSTBOOT=NO\n')
            fd.close()

# /boot/grub/grub.conf
if ks["bootloader"] and not (ks["bootloader"].has_key("location") and \
                             ks["bootloader"]["location"] == "none"):
#TODO:                          and not (ks.has_key("upgrade") and \
#                                  not ks["bootloader"].has_key("upgrade")):

    prefix = "/boot"
    dir = "/"
    have = "have"
    if mountmap.has_key("/boot"):
        dir = "/boot"
        prefix = ""
        have = "do not have"

    append=""
    if ks["bootloader"] and ks["bootloader"].has_key("append"):
        append = " "+ks["bootloader"]["append"]

    hds = diskmap.keys()
    hds.sort()
    # driveorder
    if ks["bootloader"].has_key("driveorder"):
        hds_ = ks["bootloader"]["driveorder"]
        for hd in hds:
            if hd not in hds_:
                hds_.append(hd)
        hds = hds_
    hdmap = { }
    id = 0
    for hd in hds:
        hdmap[hd] = "hd%d" % id
        id += 1
    if verbose:
        print "hdmap=%s" % hdmap

    hd_boot = "%s,%d" % (hdmap[partitionmap[mountmap[dir]]["disk"]],
                         (partitionmap[mountmap[dir]]["id"] - 1))

    kernels = [ ]
    if not os.path.exists(buildroot+"/bin/rpm"):
        print "ERROR: Could not determine installed kernels, /bin/rpm does not exist, skipping."
    else:
        (status, rusage) = pyrpm.runScript(\
            script="rpm -qla 'kernel*' | grep /boot/vmlinuz | cut -d- -f2- >/tmp/installed-kernels 2>/dev/null", chroot=buildroot)
        if status != 0:
            print "ERROR: Failed to determine installed kernels, aborting."
            exit(1)

        try:
            fd = open(buildroot+"/tmp/installed-kernels")
        except Exception, msg:
            print "ERROR: Failed to open '/tmp/installed-kernels':", msg
        else:
            kernels = fd.readlines()
            fd.close()

    if len(kernels) < 1:
        print "ERROR: No kernels are installed."
        exit(1)

    # sort kernel versions with evrCompare
    _kernels = [ ]
    for i in xrange(len(kernels)):
        kernel = kernels[i]
        found = 0
        for j in xrange(len(_kernels)):
            k = _kernels[j]
            if pyrpm.evrCompare(kernel, pyrpm.RPMSENSE_GREATER, k):
                _kernels.insert(j, kernel)
                found = 1
                break
        if not found:
            _kernels.append(kernel)
    kernels = _kernels
    del _kernels

    location = "mbr"
    if ks["bootloader"].has_key("location"):
        location = ks["bootloader"]["location"]
    if location == "mbr":
        location = partitionmap[mountmap[dir]]["disk"]
    elif location == "partition":
        location = mountmap[dir]

    if not os.path.exists(buildroot+"/boot/grub/grub.conf") or \
           ks.has_key("upgrade"):
#TODO:           ks["bootloader"].has_key("upgrade"):
        print "Configuring grub"

        try:
            fd = open(buildroot+"/boot/grub/grub.conf", "w")
        except Exception, msg:
            print "ERROR: Configuration of '/boot/grub/grub.conf' failed:", msg
        else:
            # TODO: upgrade grub.conf (preserve old entries)
            fd.write('# grub.conf generated by pyrpmkickstart\n')
            fd.write('#\n')
            fd.write('# Note that you do not have to rerun grub after making changes to this file\n')
            fd.write('# NOTICE:  You %s a /boot partition.  This means that\n' % have)
            fd.write('#          all kernel and initrd paths are relative to %s/, eg.\n' % prefix)
            fd.write('#          root (%s)\n' % hd_boot)
            fd.write('#          kernel %s/vmlinuz-version ro root=/dev/%s\n' % \
                     (prefix, mountmap["/"]))
            fd.write('#          initrd %s/initrd-version.img\n' % prefix)
            fd.write('#boot=/dev/%s\n' % location)
            fd.write('default=0\n')
            fd.write('timeout=5\n')
            fd.write('splashimage=(%s)%s/grub/splash.xpm.gz\n' % (hd_boot,
                                                                  prefix))
            if ks["bootloader"].has_key("password"):
                fd.write('password %s\n' % ks["bootloader"]["password"])
            if ks["bootloader"].has_key("md5pass"):
                fd.write('password --md5 %s\n' % ks["bootloader"]["md5pass"])
            if ks["bootloader"].has_key("lba32"):
                fd.write('lba32\n')

            # configure all kernels:
            for kernel in kernels:
                kernel = string.strip(kernel)
                fd.write('title %s (%s)\n' % (source_release, kernel))
                fd.write('\troot (%s)\n' % hd_boot)
                fd.write('\tkernel %s/vmlinuz-%s ro root=LABEL=%s%s\n' % \
                         (prefix, kernel, partitionmap[mountmap["/"]]["label"],
                          append))
                fd.write('\tinitrd %s/initrd-%s.img\n' % (prefix, kernel))

            fd.close()

        # TODO: use arch of installed system
        machine = pyrpm.buildarchtranslate[pyrpm.rpmconfig.machine]
        buildroot_copy("/usr/share/grub/%s-redhat/stage1" % machine,
                       "/boot/grub/stage1")
        buildroot_copy("/usr/share/grub/%s-redhat/stage2" % machine,
                       "/boot/grub/stage2")
        buildroot_copy("/usr/share/grub/%s-redhat/e2fs_stage1_5" % machine,
                       "/boot/grub/e2fs_stage1_5")

        # create temporary devices which are usable by grub (hda, hda1, ..)
        devmap = { } # device mapping
        for disk in diskmap:
            stats = os.stat(diskmap[disk]["device"])
            tmpdev = "/tmp/%s" % disk
            devmap[diskmap[disk]["device"]] = tmpdev
            os.mknod(buildroot+tmpdev, stats.st_mode, stats.st_rdev)
        for onpart in partitionmap:
            stats = os.stat(partitionmap[onpart]["device"])
            tmpdev = "/tmp/%s%d" % (partitionmap[onpart]["disk"],
                                    partitionmap[onpart]["id"])
            devmap[partitionmap[onpart]["device"]] = tmpdev
            os.mknod(buildroot+tmpdev, stats.st_mode, stats.st_rdev)

        try:
            fd = open(buildroot+"/boot/grub/devices.map", "w")
        except Exception, msg:
            print "ERROR: Configuration of '/boot/grub/devices.map' failed:", \
                  msg
        else:
            fd.write('(fd0) /dev/fd0\n')
            for disk in diskmap:
                fd.write('(%s) %s\n' % (hdmap[disk], disk))
            fd.close()

        try:
            fd = open(buildroot+"/tmp/grub-setup", "w")
        except Exception, msg:
            print "ERROR: Configuration of '/tmp/grub-setup' failed:", \
                  msg
        else:
            fd.write('/sbin/grub --batch >/tmp/grub-setup.log <<EOF\n')
            for disk in diskmap:
                fd.write('device (%s) %s\n' % (hdmap[disk],
                                               devmap[diskmap[disk]["device"]]))
                if diskmap[disk].has_key("image"):
                    fd.write('geometry (%s) %d %d %d\n' % \
                             (hdmap[disk],
                              diskmap[disk]["cylinders"],
                              diskmap[disk]["heads"],
                              diskmap[disk]["sectors"]))
            fd.write('root (%s)\n' % hd_boot)
            if hdmap.has_key(location):
                hd = hdmap[location]
            else:
                try:
                    hd_name = getName(location)
                    id = getId(location)
                except:
                    print "ERROR: Failed to get id for '%s'" % location
                hd = "%s,%d" % (hdmap[hd_name], (id-1))
            fd.write('setup (%s)\n' % hd)
            fd.write('quit\n')
            fd.write('EOF\n')
            fd.close()

            if not os.path.exists(buildroot+"/sbin/grub"):
                print "ERROR: /sbin/grub does not exist, skipping."
            else:
                (status, rusage) = pyrpm.runScript(\
                    script="/bin/sh /tmp/grub-setup", chroot=buildroot)
                if status != 0:
                    print "ERROR: grub setup failed"

# run post script
if ks["post"] and len(ks["post"]["script"]) > 0:
    print "Running post script"

    chroot = None
    if not ks["post"].has_key("nochroot"):
        chroot = buildroot
    interpreter = "/bin/sh"
    if ks["post"].has_key("interpreter"):
        interpreter = ks["post"]["interpreter"]

    (status, rusage) = pyrpm.runScript(interpreter, ks["post"]["script"],
                                       chroot=chroot)
    if status != 0:
        if ks["post"].has_key("erroronfail"):
            print "ERROR: post script failed"
            exit(1)
        else:
            print "WARNING: post script failed"

if xen:
    print "Writing xen.conf"
    try:
        fd = open("xen.conf", "w")
    except Exception, msg:
        print "ERROR: Configuration of 'xen.conf' failed:", msg
    else:
        fd.write('kernel = "/boot/vmlinuz-VERSION"\n')
        fd.write('ramdisk = "/boot/initrd-VERSION.img"\n')
        fd.write('memory = 128\n')
        fd.write('name = "xen"\n')
        fd.write('nics = 1\n')
        for disk in diskmap:
            if diskmap[disk].has_key("image") and \
                   diskmap[disk].has_key("device"):
                fd.write('disk = [ "file:%s,%s,r" ]\n' % \
                         (diskmap[disk]["image"], disk))
            else:
                fd.write('disk = [ "phy:%s,%s,r" ]\n' % \
                         (diskmap[disk]["device"], disk))
        fd.write('root = "%s"\n' % mountmap["/"])
        fd.write('extra = "ro"\n')
        fd.close()

# cleanup
exit(0)
