#!/usr/bin/python
#
# (c) 2005 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published by
# the Free Software Foundation; version 2 only
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2004, 2005 Red Hat, Inc.
#
# AUTHOR: Thomas Woerner <twoerner@redhat.com>
#

import os, sys, md5, stat, tempfile, string, time, stat, getopt, types
import rhpl.diskutil as diskutil

PYRPMDIR = os.path.abspath("..")
if not PYRPMDIR in sys.path:
    sys.path.append(PYRPMDIR)

import pyrpm

################################### classes ###################################

class KickstartConfig(dict):
    REQUIRED_TAGS = [ "authconfig", "bootloader", "keyboard", "lang",
                      "langsupport", "rootpw", "timezone" ]
    # Currently unsupported tags:
    # driverdisk, logvol, raid, xconfig, volgroup

    
    def __init__(self, filename):
        dict.__init__(self)
        self.parse(filename)

    def __getitem__(self, item):
        if not self.has_key(item):
            return None
        return dict.__getitem__(self, item)

    def parse(self, filename):
        self["filename"] = filename
        try:
            _fd = open(filename, "r")
        except:
            raise IOError, "Unable to open '%s'" % args[1]

        in_packages = 0
        in_post = 0
        in_pre = 0
        in_include = 0
        fd = [ _fd ]
        open_files = [ filename ]
        while 1:
            line = fd[0].readline()
            
            if not line:
                if len(fd) > 0:
                    _fd = fd.pop(0)
                    _fd.close()
                if len(fd) == 0:
                    break
            
            if line[-1:] == "\n":
                line = line[:-1]
            if len(line) < 1: continue
            if line[0] == '#': continue

            line = string.rstrip(line)

            args = noquote_split(line)
            opt = args[0]

            if opt == "%packages":
                self.parseSimple(opt[1:], args[1:],
                                    [ "resolvedeps", "ignoredeps",
                                      "ignoremissing" ])
                in_packages = 1
                in_post = 0
                in_pre = 0
                continue
            if opt == "%post":
                self.parseSimple(opt[1:], args[1:],
                                    [ "nochroot", "interpreter=",
                                      "erroronfail" ])
                in_packages = 0
                in_post = 1
                in_pre = 0
                continue
            if opt == "%pre":
                self.parseSimple(opt[1:], args[1:],
                                    [ "erroronfail", "interpreter=" ])
                in_packages = 0
                in_post = 0
                in_pre = 1
                continue
            if opt == "%include":
                if len(args) == 2:
                    try:
                        _fd = open(args[1], "r")
                    except:
                        raise IOError, "Unable to open '%s'" % args[1]
                    if args[1] in open_files:
                        raise ValueError, "Include loop detected for '%s'" % \
                              args[1]
                    fd.insert(0, _fd)
                    open_files.append(args[1])
                else:
                    raise ValueError, "Error in line '%s'" % line

            if not in_packages and not in_post and not in_pre:
                if len(args) == 1:
                    if opt in [ "autopart", "autostep", "cdrom", "cmdline",
                                "install", "interactive", "reboot", "skipx",
                                "text", "upgrade", "mouse" ]:
                        self[opt] = None
                    else:
                        print "'%s' is unsupported" % line
                    continue

                if opt in [ "keyboard", "lang", "zerombr" ]:
                    if len(args) > 2:
                        raise ValueError, "Error in line '%s'" % line
                    self[opt] = args[1]
                    continue

                if opt == "auth" or opt == "authconfig":
                    self.parseSimple("authconfig", args[1:],
                                     [ "enablemd5", "enablenis", "nisdomain=",
                                       "nisserver=", "useshadow",
                                       "enableshadow", "enableldap",
                                       "enableldapauth", "ldapserver=",
                                       "ldapbasedn=", "enableldaptls",
                                       "enablekrb5", "krb5realm=",
                                       "krb5adminserver=", "enablehesiod",
                                       "hesiodlhs=", "hesiodrhs=",
                                       "enablesmbauth", "smbservers=",
                                       "smbworkgroup=", "enablecache" ],
                                     { "useshadow": "enableshadow" })
                elif opt == "bootloader":
                    self.parseSimple(opt, args[1:],
                                     [ "append:", "driveorder", "location:",
                                       "password:", "md5pass:", "lba32",
                                       "upgrade" ])
                elif opt == "clearpart":
                    self.parseSimple(opt, args[1:],
                                     [ "all", "drives:", "initlabel", "linux",
                                       "none" ])
                elif opt == "device":
                    (_dict, _args) = self.parseArgs(opt, args[1:], [ "opts:" ])
                    if len(_args) != 2:
                        raise ValueError, "'%s' is unsupported" % line
                    if not self[opt]:
                        self[opt] = { }
                    if not self[opt].has_key(_args[0]):
                        self[opt][_args[0]] = { }
                    self[opt][_args[0]][_args[1]] = _dict
                # TODO: driverdisk
                elif opt == "firewall":
                    # firewall is special, so we have to do it by hand
                    if self[opt]:
                        raise ValueError, "%s already set." % opt

                    (_opts, _args) = getopt(args[1:], "",
                                            [ "enabled", "enable",
                                              "disabled", "disable", "trust:",
                                              "ssh", "telnet", "smtp",
                                              "http", "ftp", "port:" ])
                    replace_tags = { "enabled": "enable",
                                     "disabled": "disable" }
                    self[opt] = { }
                    for (_opt, _val) in _opts:
                        if replace_tags and replace_tags.has_key(_opt):
                            _opt = replace_tags[_opt]
                        if _opt == "--enabled" or _opt == "--enable":
                            self[opt]["enabled"] = None
                        elif _opt == "--disabled" or _opt == "--disable":
                            self[opt]["disabled"] = None
                        elif _opt == "--trust" and _val:
                            if not self[opt].has_key("trust"):
                               self[opt]["trust"] = [ ]
                            self[opt]["trust"].append(_val)
                        elif _opt in [ "--ssh", "--telnet", "--smtp", "--http",
                                       "--ftp" ]:
                            if not self[opt].has_key("services"):
                               self[opt]["services"] = [ ]
                            self[opt]["services"].append(_opt[2:])
                        elif _opt == "--port":
                            _vals = noquote_split(val, ",")
                            for v in _vals:
                                if not self[opt].has_key("ports"):
                                    self[opt]["ports"] = [ ]
                                self[opt]["ports"].append(v)
                        else:
                            print "'%s': option '%s' not recognized" % (line,
                                                                        _opt)
                    for arg in _args:
                        if not self[opt].has_key("devices"):
                            self[opt]["devices"] = [ ]
                        self[opt]["devices"].append(arg)
                elif opt == "firstboot":
                    self.parseSimple(opt, args[1:],
                                     [ "enable", "enabled", "disable",
                                       "disabled", "reconfig" ])
                elif opt == "harddrive":
                    self.parseSimple(opt, args[1:],
                                     [ "partition:", "dir:" ])
                    if not self[opt].has_key("partition") or \
                       not self[opt].has_key("dir"):
                        raise ValueError, "Error in line '%s'" % line
                elif opt == "langsupport":
                    (_dict, _args) = self.parseArgs(opt, args[1:],
                                                    [ "default:" ])
                    self[opt] = _dict
                    if len(args) > 0:
                        self[opt]["supported"] = _args
                    if len(self[opt]) == 0:
                        raise ValueError, "Error in line '%s'" % line
                # TODO: logvol
                elif opt == "network":
                    self.parseSimple(opt, args[1:],
                                     [ "bootproto=", "device=", "ip=",
                                       "gateway=", "nameserver=", "nodns",
                                       "netmask=", "hostname=", "ethtool=",
                                       "essid=", "wepkey=", "onboot=",
                                       "class=" ])
                elif opt == "nfs":
                    self.parseSimple(opt, args[1:],
                                     [ "server:", "dir:" ])
                    if not self[opt].has_key("server") or \
                       not self[opt].has_key("dir"):
                        raise ValueError, "Error in line '%s'" % line
                elif opt == "part" or opt == "partition":
                    self.parseSub("partition", args[1:],
                                  [ "size:", "grow", "maxsize:", "noformat",
                                    "onpart:", "usepart:", "ondisk:",
                                    "ondrive:", "asprimary", "fstype:",
                                    "fsoptions:", "label:", "start:", "end:",
                                    "bytes-per-inode:", "recommended",
                                    "onbiosdisk" ],
                                  { "usepart": "onpart", "ondrive": "ondisk" })
                # TODO: raid
                elif opt == "rootpw":
                    self.parseSub(opt, args[1:], [ "iscrypted" ])
                elif opt == "selinux":
                    self.parseSimple(opt, args[1:],
                                     [ "enforcing", "permissive", "disabled" ])
                elif opt == "timezone":
                    self.parseSub(opt, args[1:], [ "utc" ])
                elif opt == "url":
                    self.parseSimple(opt, args[1:], [ "url:" ])
                    if not self[opt].has_key("url"):
                        raise ValueError, "Error in line '%s'" % line
                # TODO: xconfig
                # TODO: volgroup
                else:
                    print "'%s' is unsupported" % line
            elif in_packages:
                if len(args) == 1:
                    # there was no space as delimiter
                    args = [ line[:1], line[1:] ]
                    opt = line

                if not self["packages"]:
                    self["packages"] = { }
                if len(args) > 1:
                    if opt[0] == "@":
                        if not self["packages"].has_key("groups"):
                            self["packages"]["groups"] = [ ]
                        if not args[1] in self["packages"]["groups"]:
                            self["packages"]["groups"].append(args[1])
                    else:
                        print "'%s' is unsupported" % line
                elif opt[0] == "-":
                    if not self["packages"].has_key("drop"):
                        self["packages"]["drop"] = [ ]
                    if not line in self["packages"]["drop"]:
                        self["packages"]["drop"].append(args[1])
                else:
                    if not self["packages"].has_key("add"):
                        self["packages"]["add"] = [ ]
                    if not line in self["packages"]["add"]:
                        self["packages"]["add"].append(opt)
            elif in_post:
                if not self["post"].has_key("script"):
                    self["post"]["script"] = ""
                self["post"]["script"] += line+"\n"
            elif in_pre:
                if not self["pre"].has_key("script"):
                    self["pre"]["script"] = ""
                self["pre"]["script"] += line+"\n"

        ret = 0
        for tag in self.REQUIRED_TAGS:
            if not self[tag]:
                raise ValueError, "ERROR: %s is required." % tag

        if self.has_key("install") and not self.has_key("partition"):
            raise ValueError, \
                  "ERROR: partition has to be set for an installation."

    def parseArgs(self, tag, argv, allowed_args, replace_tags=None):
        dict = { }
        (opts, args) = getopt(argv, "", allowed_args)

        for (opt, val) in opts:
            if replace_tags and replace_tags.has_key(opt):
                opt = replace_tags[opt]
            if val:
                if opt[-1] == "=":
                    o = opt[2:-1]
                else:
                    o = opt[2:]
                dict[o] = val
            else:
                dict[opt[2:]] = None

        return (dict, args)

    def parseSimple(self, tag, argv, allowed_args, replace_tags=None):
        if self[tag]:
            raise ValueError, "%s already set." % tag

        (dict, args) = self.parseArgs(tag, argv, allowed_args, replace_tags)

        if len(args) != 0:
            raise ValueError, "'%s %s' is unsupported" % (tag,
                                                          string.join(argv))
        self[tag] = dict
        
    def parseSub(self, tag, argv, allowed_args, replace_tags=None):
        (dict, args) = self.parseArgs(tag, argv, allowed_args, replace_tags)

        if len(args) != 1:
            raise ValueError, "'%s %s' is unsupported" % (tag,
                                                          string.join(argv))
        if not self[tag]:
            self[tag] = { }
        elif self[tag].has_key(args[0]):
                raise ValueError, "%s already set." % tag

        self[tag][args[0]] = dict

################################## functions ##################################

# To combine option and value in longopts:
#   "opt=" for --opt=val 
#   "opt:" for --opt val or --opt=val
def getopt(args, shortopts, longopts=[ ]):
    _shortopts = { }
    _longopts = { }
    _opts = [ ]
    _args = args[:]

    for i in xrange(len(shortopts)):
        opt = shortopts[i]
        if i < len(shortopts) - 1 and shortopts[i+1] == ":":
            _shortopts[opt] = ":"
            i += 1
        else:
            _shortopts[opt] = None

    for opt in longopts:
        if len(opt) < 1:
            raise ValueError, "Invalid options"
        if opt[-1] == "=" or opt[-1] == ":":
            _longopts[opt[0:-1]] = opt[-1]
        else:
            _longopts[opt] = None

    idx = 0
    while len(_args) > idx:
        arg = _args[idx]

        if arg[0:2] == "--": # longopts
            a = arg[2:]
            if a in _longopts:
                if not _longopts[a]:
                    _opts.append((arg, None))
                    _args.pop(idx)
                    continue
                elif _longopts[a] == ":":
                    if len(args) > 1:
                        _args.pop(idx)
                        val = _args.pop(idx)
                        _opts.append((arg, val))
                        continue
                    else:
                        raise ValueError, "Missing value for '%s'" % arg
            
            i = arg.find("=")
            if i > 0: # found '='
                a = arg[2:i]
                if a in _longopts and \
                       (_longopts[a] == "=" or _longopts[a] == ":"):
                    _opts.append((arg[:i], arg[i+1:]))
                    _args.pop(idx)
                    continue

            raise ValueError, "Invalid option '%s'" % arg
        elif arg[0] == "-": # shortopts
            a = arg[1:]
            for c in a:
                if c in _shortopts:
                    if not _shortopts[c]:
                        _opts.append(("-"+c, None))
                    elif _shortopts[c] == ":":
                        if len(a) > 1:
                            raise ValueError, "Invalid option '%s'" % arg
                        _args.pop(idx)
                        val = _args.pop(idx)
                        _opts.append((arg, val))
                    else:
                        raise ValueError, "Invalid option '%s'" % arg
                    _args.pop(idx)
                else:
                    raise ValueError, "Invalid option '%s'" % arg

        else: # do not stop on no-opt, continue
            idx += 1

    return (_opts,_args)


def noquote_split(s, delimiter=None):
    delimiters = [ " ", "\t", "\r", "\n", "\f", "\v" ]
    tokens = [ ]
    single_quote = 0
    double_quote = 0
    if delimiter:
        if isinstance(delimiter, types.ListType):
            delimiters = delimiter
        else:
            delimiters = [ delimiter ]
    for i in xrange(len(delimiters)):
        if not isinstance(delimiters[i], types.StringType):
            raise ValueError, "delimiter is not of type string"
        if len(delimiters[i]) == 0:
            delimiters.pop(i)

    b = 0;
    for i in xrange(len(s)):
#        print "s[%d]='%s' %x %d %d" % (i, s[i], ord(s[i]), single_quote, double_quote)
        if s[i] == "'":
            if single_quote == 0 or double_quote > 0:
                single_quote += 1
            else:
                single_quote -= 1
        if s[i] =="\"":
            if double_quote == 0 or single_quote > 0:
                double_quote += 1
            else:
                double_quote -= 1
        if single_quote == 0 and double_quote == 0:
            for delim in delimiters:
                l = len(delim)
                if s[i:i+l] == delim:
#                    print "found delim='%s'" % delim
                    if i > 0 and len(s[b:i]) > 0:
                        tokens.append(s[b:i])
                    b = i + l
                    break
    if len(s[b:]) > 0:
        tokens.append(s[b:])

    return tokens


def rm_rf(name):
    if not os.path.exists(name) or not os.path.isdir(name):
        return
    if os.path.ismount(name):
        umount(name)
        return
    list = os.listdir(name)
    for file in list:
        if os.path.isdir(name+"/"+file) and not os.path.islink(name+"/"+file):
            rm_rf(name+"/"+file)
        else:
            os.unlink(name+"/"+file)
    os.rmdir(name)


def mount(what, where, fstype="ext3", options=None):
    print "Mounting '%s' on '%s'" % (what, where)

    opts = ""
    if options:
        opts = "-o '%s'" % options
    stat = os.system("mount %s -t '%s' '%s' '%s'" % \
                     (opts, fstype, what , where))
    if stat != 0:
        raise IOError, "mount of '%s' on '%s' failed" % (what , where)


def umount(what):
    if not os.path.ismount(what):
        return
    print "Umounting '%s'" % what
    
    i = 0
    failed = 0
    while os.path.ismount(what) and i < 100:
        if i == 1:
            # kill all processes running in dir
            print "Killing all processes running in  '%s'" % what
        if i > 0:
            pid = os.fork()
            if pid != 0:
                (rpid, status) = os.waitpid(pid, 0)
                if status != 0:
                    sys.exit(1)
            else:
                pyrpm.runScript(script="/sbin/fuser -k '%s'" % what)
                sys.exit(0)

            print "Trying to umount '%s'" % source_dir
            time.sleep(0.5)
        stat = os.system("umount '%s'" % what)
        if stat != 0:
            failed = 1
        else:
            failed = 0
        i += 1
    if failed == 1:
        print "ERROR: Umount of '%s' failed" % what

    return failed

def umount_all(dir):
    # umount target dir and included mount points
    mounted = [ ]
    fd = open("/proc/mounts", "r")
    while 1:
        line = fd.readline()
        if not line:
            break
        args = string.split(line)
        i = args[1].find(dir)
        if i == 0:
            mounted.append(args[1])
    fd.close()
    # sort reverse
    mounted.sort()
    mounted.reverse()

    failed = 0
    for dir in mounted:
        if umount(dir) == 1:
            failed = 1

    return failed

def check_dir(buildroot, dir):
    if not os.path.exists(buildroot+dir):
        print "ERROR: Directory '%s' does not exist." % dir
        return 0
    return 1

#################################### main ####################################

verbose = 0
buildroot = ""
xen = 0
nocleanup = 0
confirm = 1

def usage():
    print """Usage: pyrpmkickstart <options> <file> [<disk image> | <device>]

OPTIONS
  -h  | --help       Print help.
  -v  | --verbose    Be verbose, and more, ..
  -y                 So not ask questions, assume yes.

  -x  | --xen        Write a simple xen config file.
  -n  | --nocleanup  Do not cleanup temporary files.
"""

try:
    (opts, args) = getopt(sys.argv[1:], "hvyxn", [ "help", "verbose", "xen",
                                                   "nocleanup" ])
except:
    usage()
    sys.exit(1)

for (opt, val) in opts:
    if opt in ["-h", "--help"]:
        usage()
        sys.exit(1)
    elif opt in ["-v", "--verbose"]:
        verbose += 1
        pyrpm.rpmconfig.verbose += 1
    elif opt == "-y":
        confirm = 0
    elif opt in ["-x", "--xen"]:
        xen = 1
    elif opt in ["-n", "--nocleanup"]:
        nocleanup = 1
    else:
        print "Unknown option '%s'" % opt
        usage()
        sys.exit(1)

if len(args) != 2:
    usage()
    sys.exit(1)

ks_file = args[0]
target = args[1]

# test target
if not os.path.exists(target):
    print "ERROR: '%s' does not exist." % target
    sys.exit(1)

# image or block device
install_image = 0
install_device = 0
mode = os.stat(target).st_mode
if stat.S_ISREG(mode):
    install_image = 1
elif stat.S_ISBLK(mode):
    install_device = 1

if not install_image and not install_device:
    print "ERROR: No image and no device?"
    sys.exit(1)    

# load kickstart file
ks = KickstartConfig(ks_file)
#print ks
#sys.exit(0)

if not ks["nfs"] or not ks["nfs"]["server"] or not ks["nfs"]["dir"]:
    print "Only nfs install via server and dir is supported, exiting!"
    sys.exit(1)

if not ks.has_key("install"):
    print "ERROR: Only installation is supported, aborting"
    sys.exit(1)

# create temp dir

try:
    tempdir = tempfile.mkdtemp(prefix="pyrpmkickstart_")
except Exception, msg:
    print msg
    sys.exit(1)
    
source_dir = tempdir+"/source"
target_dir = tempdir+"/target"

### mounting ###

# create source mount point and mount source (nfs)
os.mkdir(source_dir)
source = "%s:%s" % (ks["nfs"]["server"], ks["nfs"]["dir"])
try:
    mount(source, source_dir, fstype="nfs")
except Exception, msg:
    print msg
    if umount_all(tempdir+"/") == 0:
        if not nocleanup:
            rm_rf(tempdir)
    sys.exit(1)

# format target
if ks.has_key("install"):
    if not ks["partition"].has_key("/"):
        print "ERROR: root partition not defined"
        sys.exit(1)
    if len(ks["partition"]) > 1:
        print "ERROR: Only one partition uspported at the moment"
        sys.exit(1)
    root = ks["partition"]["/"]
    if not root.has_key("fstype") or \
           (root["fstype"] != "ext2" and root["fstype"] != "ext3"):
        print "ERROR: filesystem type '%s' is not supported" % root["fstype"]
        sys.exit(1)
    if not root.has_key("noformat"):
        mke2fs = "/sbin/mke2fs -q"
        if root["fstype"] == "ext3":
            mke2fs += " -j"
        if install_image:
            mke2fs += " -F"
        if target[0] != "/":
            mke2fs += " %s/%s" % (os.getcwd(), target)
        else:
            mke2fs += " %s" % target

        if confirm == 1:
            print "About to format '/' filesystem on %s" % target
            choice = raw_input("Is this ok [y/N]: ")
            if len(choice) == 0 or choice[0] != "y" and choice[0] != "Y":
                if umount_all(tempdir+"/") == 0:
                    if not nocleanup:
                        rm_rf(tempdir)
                sys.exit(1)

        print "Formatting '/' filesystem on %s" % target
        pid = os.fork()
        if pid != 0:
            (rpid, status) = os.waitpid(pid, 0)
            if status != 0:
                sys.exit(1)
        else:
            pyrpm.runScript(script=mke2fs)
            sys.exit(0)
    else:
        print "Keeping '/' filesystem on %s" % target


os.mkdir(target_dir)
try:
    if install_image:
        mount(target, target_dir, fstype=ks["partition"]["/"]["fstype"],
              options="loop")
    if install_device:
        mount(target, target_dir, fstype=ks["partition"]["/"]["fstype"])
except Exception, msg:
    print msg
    if umount_all(tempdir+"/") == 0:
        if not nocleanup:
            rm_rf(tempdir)
    sys.exit(1)

buildroot = target_dir
pyrpm.rpmconfig.buildroot = buildroot

# set default group "base" if no groups are specified
if not ks["packages"]:
    ks["packages"] = { }
if not ks["packages"].has_key("groups"):
    ks["packages"]["groups"] = [ ]

if len(ks["packages"]["groups"]) == 0:
    ks["packages"]["groups"].append("base")

# load comps file for groups and default packages
comps = pyrpm.RpmCompsXML(pyrpm.rpmconfig,
                          "%s/repodata/comps.xml" % source_dir)
comps.read()
pkgs = [ ]
for group in ks["packages"]["groups"]:
    pkgs.extend(comps.getPackageNames(group))

# everything install
if "everything" in ks["packages"]["groups"]:
    for group in comps.grouphash.keys():
        if comps.grouphash[group].has_key("packagelist"):
            pkgs.extend(comps.grouphash[group]["packagelist"])

del comps
   

# add and remove packages from default list
if ks["packages"].has_key("drop"):
    for pkg in ks["packages"]["drop"]:
        if pkg in pkgs:
            pkgs.remove(pkg)
if ks["packages"].has_key("add"):
    for pkg in ks["packages"]["add"]:
        if not pkg in pkgs:
            pkgs.append(pkg)

# add comps package (FC-4)
if not "comps" in pkgs:
    pkgs.append("comps")

# append authconfig, if we want to configure it
if ks["authconfig"] and not "authconfig" in pkgs:
    print "Adding package authconfig"
    pkgs.append("authconfig")

if len(pkgs) < 1:
    print "Nothing to do."
    sys.exit(1)

# greate essential directories and files
os.umask(000)
if not os.path.exists(buildroot+"/dev"):
    os.mkdir(buildroot+"/dev")
    os.mknod(buildroot+"/dev/console", 0666 | stat.S_IFCHR, os.makedev(5, 1))
    os.mknod(buildroot+"/dev/null", 0666 | stat.S_IFCHR, os.makedev(1, 3))
    os.mknod(buildroot+"/dev/zero", 0666 | stat.S_IFCHR, os.makedev(1, 5))

if not os.path.exists(buildroot+"/etc"):
    os.mkdir(buildroot+"/etc")
    fd = open(buildroot+"/etc/fstab", "w")
    fd.write("/dev/root\t\t/\t\text3\tdefaults\t1 1\n")
    fd.write("/dev/devpts\t\t/dev/pts\t\tdevpts\tgid=5,mode=620\t0 0\n")
    fd.write("/dev/shm\t\t/dev/shm\t\ttmpfs\tdefaults\t0 0\n")
    fd.write("/dev/proc\t\t/proc\t\tproc\tdefaults\t0 0\n")
    fd.write("/dev/sys\t\t/sys\t\tsysfs\tdefaults\t0 0\n")
    fd.close()
    fd = open(buildroot+"/etc/hosts", "w")
    fd.write("# Do not remove the following line, or various programs\n")
    fd.write("# that require network functionality will fail.\n")
    fd.write("127.0.0.1\t\tlocalhost.localdomain\tlocalhost\n")
    fd.close()
    fd = open(buildroot+"/etc/modprobe.conf", "w")
    fd.close()

pre_failed = 0
# run pre script
if ks["pre"] and len(ks["pre"]["script"]) > 0:
    print "Running pre script"
    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0 and ks["pre"].has_key("erroronfail"):
            print "ERROR: Pre script failed, aborting."
            if umount_all(tempdir+"/") == 0:
                if not nocleanup:
                    rm_rf(tempdir)
    else:
        if not ks["pre"].has_key("nochroot"):
            os.chroot(buildroot)
        interpreter = "bin/sh"
        if ks["pre"].has_key("interpreter"):
            interpreter = ks["pre"]["interpreter"]
        pyrpm.runScript(interpreter, ks["pre"]["script"])
        sys.exit(0)


# configure yum
os.mkdir("%s/yum.cache" % tempdir)
os.mkdir("%s/yum.repos.d" % tempdir)
yum_conf = tempdir+"/yum.conf"
fd = open(yum_conf, "w")
fd.write("[main]\n")
fd.write("cachedir=%s/yum.cache\n" % tempdir)
fd.write("debuglevel=0\n")
fd.write("errorlevel=0\n")
fd.write("pkgpolicy=newest\n")
fd.write("distroverpkg=redhat-release\n")
fd.write("tolerant=1\n")
fd.write("exactarch=1\n")
fd.write("retries=20\n")
fd.write("obsoletes=1\n")
fd.write("reposdir=%s/yum.repos.d\n" % tempdir)
fd.write("\n")
fd.write("[dist]\n")
fd.write("name=dist\n")
fd.write("baseurl=file:%s/source\n" % tempdir)
fd.close()

# yum
yum = "PYTHONPATH=%s %s/scripts/pyrpmyum --servicehack -y -c '%s' -r '%s'" % \
      (PYRPMDIR, PYRPMDIR, yum_conf, buildroot)
if not ks["packages"].has_key("resolvedeps") or \
       (ks["packages"].has_key("ignoredeps") and \
        ks["packages"].has_key("ignoremissing")):
    yum += " --nodeps"
if ks.has_key("install"):
    yum += " install "
elif ks.has_key("update"):
#    if ks["packages"].has_key("resolvedeps"):
#        yum += " --autoerase "
    yum += " update "
yum += string.join(pkgs)
#print yum
pid = os.fork()
if pid != 0:
    (rpid, status) = os.waitpid(pid, 0)
    if status != 0:
        print "ERROR: Installation failed, aborting."
else:
    os.system(yum)
    sys.exit(0)


# check system dirs
if not check_dir(buildroot, "/etc") or \
       not check_dir(buildroot, "/etc/sysconfig"):
    print "Aborting."
    if umount_all(tempdir+"/") == 0:
        if not nocleanup:
            rm_rf(tempdir)
    sys.exit(0)

# run kudzu
print "Running kudzu"
pid = os.fork()
if pid != 0:
    (rpid, status) = os.waitpid(pid, 0)
    if status != 0:
        print "ERROR: kudzu failed."
else:
    os.chroot(buildroot)
    pyrpm.runScript("/usr/sbin/kudzu")
    sys.exit(0)

# run authconfig if set
if ks["authconfig"]:
    print "Configuring authentication"
    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: authconfig failed"
    else:
        os.chroot(buildroot)
        authconfig = "/usr/bin/authconfig --kickstart --nostart"
        for tag in ks["authconfig"]:
            if ks["authconfig"][tag]:
                authconfig += " --%s=%s" % (tag, ks["authconfig"][tag])
            else:
                authconfig += " --%s" % tag
        pyrpm.runScript(script=authconfig)
        sys.exit(0)

# /etc/sysconfig/clock
if ks["timezone"]:
    print "Configuring timezone"
    try:
        fd = open(buildroot+"/etc/sysconfig/clock", "w")
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/clock' failed:", msg
    else:
        zone = ks["timezone"].keys()[0]
        fd.write('ZONE="%s"\n' % zone)
        if ks["timezone"][zone].has_key("utc"):
            fd.write('UTC=true\n')
        else:
            fd.write('UTC=false\n')    
        fd.write('ARC=false\n')
        fd.close()

# /etc/sysconfig/desktop
print "Configuring desktop"
try:
    fd = open(buildroot+"/etc/sysconfig/desktop", "w")
    fd.write('DESKTOP="GNOME"\n')
    fd.close()
except Exception, msg:
    print "ERROR: Configuration of '/etc/sysconfig/desktop' failed:", msg

# /etc/sysconfig/i18n
if ks["langsupport"]:
    print "Configuring languages"
    try:
        fd = open(buildroot+"/etc/sysconfig/i18n", "w")
        if len(ks["langsupport"]) > 1:
            lang = ""
            supported = ""
            for l in ks["langsupport"].keys():
                if ks["langsupport"][l].has_key("default"):
                    lang = l
                else:
                    if len(supported) > 0:
                        supported += ":"
                    supported += l
            fd.write('LANG="%s"\n' % lang)
            fd.write('SUPPORTED="%s"\n' % supported)
        else:
            fd.write('LANG="%s"\n' % ks["langsupport"].keys()[0])
        fd.write('SYSFONT="latarcyrheb-sun16"\n')
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/i18n' failed:", msg

# /etc/sysconfig/installinfo
print "Configuring installinfo"
try:
    fd = open(buildroot+"/etc/sysconfig/installinfo", "w")
    fd.write('INSTALLMETHOD=nfs\n')
    fd.close()
except Exception, msg:
    print "ERROR: Configuration of '/etc/sysconfig/installinfo' failed:", msg

# /etc/sysconfig/keyboard
if ks["keyboard"]:
    print "Configuring keyboard"
    try:
        fd = open(buildroot+"/etc/sysconfig/keyboard", "w")
        fd.write('KEYBOARDTYPE="pc"\n')
        fd.write('KEYTABLE="%s"\n' % ks["keyboard"])
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/keyboard' failed: ", msg

# setup networking
if ks["network"]:
    print "Configuring network"
    try:
        fd = open(buildroot+"/etc/sysconfig/network", "w")
        fd.write("NETWORKING=yes\nHOSTNAME=localhost.localdomain\n")
        fd.close()
        if not os.path.exists(buildroot+"/etc/sysconfig/network-scripts"):
            os.mkdir(buildroot+"/etc/sysconfig/network-scripts")
        if ks["network"].has_key("device") and \
               ks["network"].has_key("bootproto"):
            fd = open(buildroot+"/etc/sysconfig/network-scripts/ifcfg-%s" % \
                      ks["network"]["device"], "w")
            fd.write("DEVICE=%s\n" % ks["network"]["device"])
            fd.write("BOOTPROTO=%s\n" % ks["network"]["bootproto"])
            fd.write("ONBOOT=yes\n")
            fd.write("TYPE=Ethernet\n")
            fd.close()        
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/network' failed:", msg

# run post script
if ks["post"] and len(ks["post"]["script"]) > 0:
    print "Running post script"
    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0 and ks["post"].has_key("erroronfail"):
            print "ERROR: post script failed"
            if umount_all(tempdir+"/") == 0:
                if not nocleanup:
                    rm_rf(tempdir)
    else:
        if not ks["post"].has_key("nochroot"):
            os.chroot(buildroot)
        interpreter = "bin/sh"
        if ks["post"].has_key("interpreter"):
            interpreter = ks["post"]["interpreter"]
        pyrpm.runScript(interpreter, ks["post"]["script"])
        sys.exit(0)

if xen:
    print "Writing xen.conf"
    try:
        fd = open("xen.conf", "w")
        fd.write('kernel = "/boot/vmlinuz-VERSION"\n')
        fd.write('ramdisk = "/boot/initrd-VERSION.img"\n')
        fd.write('memory = 128\n')
        fd.write('name = "xen"\n')
        fd.write('nics = 1\n')
        if install_image:
            fd.write('disk = [ "file:%s,sda1,r" ]\n' % target)
        if install_device:
            fd.write('disk = [ "phy:%s,sda1,r" ]\n' % target)
        fd.write('root = "/dev/sda1"\n')
        fd.write('extra = "ro"\n')
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of 'xen.conf' failed:", msg

# umount source_dir, target_dir and included mount points
if umount_all(tempdir+"/") == 0:
    if not nocleanup:
        rm_rf(tempdir)

sys.exit(0)

##############################################################################

"""
########################## MAYBE ##########################

/etc/localtime

/etc/nsswitch.conf
-netgroup:   nisplus
+netgroup:   files
-automount:  files nisplus
+automount:  files

/etc/rpm/platform
+i686-redhat-linux

/etc/sysconfig/iptables
+# Firewall configuration written by system-config-securitylevel
+# Manual customization of this file is not recommended.
+*filter
+:INPUT ACCEPT [0:0]
+:FORWARD ACCEPT [0:0]
+:OUTPUT ACCEPT [0:0]
+:RH-Firewall-1-INPUT - [0:0]
+-A INPUT -j RH-Firewall-1-INPUT
+-A FORWARD -j RH-Firewall-1-INPUT
+-A RH-Firewall-1-INPUT -i lo -j ACCEPT
+-A RH-Firewall-1-INPUT -p icmp --icmp-type any -j ACCEPT
+-A RH-Firewall-1-INPUT -p 50 -j ACCEPT
+-A RH-Firewall-1-INPUT -p 51 -j ACCEPT
+-A RH-Firewall-1-INPUT -p udp --dport 5353 -d 224.0.0.251 -j ACCEPT
+-A RH-Firewall-1-INPUT -p udp -m udp --dport 631 -j ACCEPT
+-A RH-Firewall-1-INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
+-A RH-Firewall-1-INPUT -j REJECT --reject-with icmp-host-prohibited
+COMMIT

/etc/sysconfig/kernel
+# UPDATEDEFAULT specifies if new-kernel-pkg should make
+# new kernels the default
+UPDATEDEFAULT=yes
+
+# DEFAULTKERNEL specifies the default kernel package type
+DEFAULTKERNEL=kernel-smp

/etc/sysconfig/mouse
+FULLNAME="Generic - Wheel Mouse (USB)"
+MOUSETYPE="imps2"
+XEMU3="no"
+XMOUSETYPE="IMPS/2"
+DEVICE=/dev/input/mice

/etc/modprobe.conf
"""
