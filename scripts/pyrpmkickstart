#!/usr/bin/python
#
# (c) 2005 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published by
# the Free Software Foundation; version 2 only
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2004, 2005 Red Hat, Inc.
#
# AUTHOR: Thomas Woerner <twoerner@redhat.com>
#

import os, sys, getopt, md5, stat, tempfile, string, time, random, crypt
import parted
from rhpl import keyboard_models

PYRPMDIR = os.path.abspath("..")
if not PYRPMDIR in sys.path:
    sys.path.append(PYRPMDIR)

import pyrpm

################################### classes ###################################

class Disk:
    def __init__(self, device_name):
        self.device = device_name
        self.dev = parted.PedDevice.get(self.device)
        self.disk = parted.PedDisk.new(self.dev)
        self.read()

    def read(self):
        self.partitions = 0
        self.partition = { }
        self.extended = { }
        self.free = { }
        partition = None
        partition = self.disk.next_partition()
        
        while partition:
            if partition.num < 0:
                if partition.type & parted.PARTITION_FREESPACE:
                    self.free[len(self.free)+1] = partition
                partition = self.disk.next_partition(partition)
                continue
            if partition.type & parted.PARTITION_EXTENDED:
                self.extended[partition.num] = partition
                self.partitions += 1
            else:
                self.partition[partition.num] = partition
                self.partitions += 1
            partition = self.disk.next_partition(partition)

    def getType(self):
        return self.disk.type

################################## functions ##################################

def rm_rf(name):
    if not os.path.exists(name) or not os.path.isdir(name):
        return
    if os.path.ismount(name):
        umount(name)
        return
    list = os.listdir(name)
    for file in list:
        if os.path.isdir(name+"/"+file) and not os.path.islink(name+"/"+file):
            rm_rf(name+"/"+file)
        else:
            os.unlink(name+"/"+file)
    os.rmdir(name)


def mount(what, where, fstype="ext3", options=None):
    print "Mounting '%s' on '%s'" % (what, where)

    opts = ""
    if options:
        opts = "-o '%s'" % options
    stat = os.system("mount %s -t '%s' '%s' '%s'" % \
                     (opts, fstype, what , where))
    if stat != 0:
        raise IOError, "mount of '%s' on '%s' failed" % (what , where)


def umount(what):
    if not os.path.ismount(what):
        return
    print "Umounting '%s' " % what

    i = 0
    failed = 0
    while os.path.ismount(what) and i < 100:
        if i == 1:
            # kill all processes running in dir
            print "Killing all processes running in  '%s'" % what
        if i > 0:
            pid = os.fork()
            if pid != 0:
                (rpid, status) = os.waitpid(pid, 0)
                if status != 0:
                    sys.exit(1)
            else:
                pyrpm.runScript(script="/sbin/fuser -k '%s'" % what)
                sys.exit(0)

#            print "Trying to umount '%s'" % what
            time.sleep(1)
        stat = os.system("umount '%s' 2>/dev/null" % what)
        if stat != 0:
            failed = 1
        else:
            failed = 0
        i += 1
    if failed == 1:
        print "ERROR: Umount of '%s' failed" % what

    return failed

def umount_all():
    # umount target dir and included mount points
    dir = tempdir+"/"
    mounted = [ ]
    fd = open("/proc/mounts", "r")
    while 1:
        line = fd.readline()
        if not line:
            break
        args = string.split(line)
        i = args[1].find(dir)
        if i == 0:
            mounted.append(args[1])
    fd.close()
    # sort reverse
    mounted.sort()
    mounted.reverse()

    failed = 0
    for dir in mounted:
        if umount(dir) == 1:
            failed = 1

    return failed

def check_dir(buildroot, dir):
    if not os.path.exists(buildroot+dir):
        print "ERROR: Directory '%s' does not exist." % dir
        return 0
    return 1

def create_dir(buildroot, dir):
    d = buildroot+dir
    if not os.path.exists(d):
        os.mkdir(d)

def losetup(target, offset=0):
    i = 0
    loop_device = None
    offset_string = ""
    if offset:
        offset_string = "-o%d" % offset
    while not loop_device and i < 100:
        (child_stdin, child_stdout) = os.popen2("/sbin/losetup -f 2>/dev/null")
        loop_device = child_stdout.read()
        loop_device = string.strip(loop_device)
        i += 1
        status = os.system("/sbin/losetup %s '%s' '%s'" % (offset_string,
                                                           loop_device,
                                                           target))
        if status != 0:
            loop_device = None
    if not loop_device:
        print "Unable to get loop device, exiting."
        return None
    return loop_device

def lofree(device):
    return (os.system("/sbin/losetup -d '%s'" % device) == 0)

def diskName(name):
    if len(name) < 2:
        raise ValueError, "'%s' is no partition name" % name
    tmp = name[:]
    while len(tmp) > 0 and tmp[-1] >= '0' and tmp[-1] <= '9':
        tmp = tmp[:-1]
    return tmp

def partitionId(name):
    if len(name) < 2:
        raise ValueError, "'%s' is no partition name" % name
    id = 0
    tmp = name[:]
    while len(tmp) > 0 and tmp[-1] >= '0' and tmp[-1] <= '9':
        id *= 10
        id += int(tmp[-1])
        tmp = tmp[:-1]
    return id

def swapon(device):
    swapon = "/sbin/swapon '%s'" % device
    print "Enable swap on '%s'" % device
    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: swapon failed."
            return 1
    else:
        pyrpm.runScript(script=swapon)
        sys.exit(0)
    return 0

def swapoff(device):
    swapoff = "/sbin/swapoff '%s'" % device
    print "Disable swap on '%s'" % device
    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: swapoff failed."
            return 1
    else:
        pyrpm.runScript(script=swapoff)
        sys.exit(0)
    return 0

def buildroot_copy(source, target):
    source_fd = open(buildroot+source, "r")
    target_fd = open(buildroot+target, "w")
    data = source_fd.read(65536)
    while data:
        target_fd.write(data)
        data = source_fd.read(65536)
    source_fd.close()
    target_fd.close()

def exitHandler(signum, frame):
    exit(1)

def exit(code):
    time.sleep(1)
    if wait:
        sys.stdout.write('Use "chroot %s" to change into the installation tree.\n' %\
                         target_dir)
        sys.stdout.write('Waiting.. Press any key to cleanup and quit. ')
        c = sys.stdin.read(1)

    if tempdir:
        if umount_all() == 0:
            if not nocleanup:
                rm_rf(tempdir)
    if partitionmap:
        for part in partitionmap:
            if partitionmap[part]["name"] == "swap" and \
                   partitionmap[part].has_key("on"):
                swapoff(partitionmap[part]["device"])
                del partitionmap[part]["on"]
            if partitionmap[part].has_key("disk") and \
                   partitionmap[part].has_key("device"):
                disk = partitionmap[part]["disk"]
                if diskmap[disk].has_key("image"):
                    lofree(partitionmap[part]["device"])
                    del partitionmap[part]["device"]
    if diskmap:
        for disk in diskmap:
            if diskmap[disk].has_key("image") and \
                   diskmap[disk].has_key("device"):
                lofree(diskmap[disk]["device"])
                del diskmap[disk]["device"]
    sys.exit(code)

#################################### main ####################################

verbose = 0
buildroot = ""
xen = 0
nocleanup = 0
confirm = 1
tempdir = None
diskmap = None
partitionmap = None
wait = 0
kudzu = 0
orig_yum = 0

def usage():
    print """
Usage: pyrpmkickstart <options> <kickstartfile>
                      [<disk name:disk image> | <device name:device>]*

OPTIONS
  -h  | --help       Print help.
  -v  | --verbose    Be verbose, and more, ..
  -y                 So not ask questions, assume yes.

  -x  | --xen        Write a simple xen config file.
  -n  | --nocleanup  Do not cleanup temporary files.
  -w  | --wait       Wait after installation before umounting.
  -k  | --kudzu      Run kudzu after installation.
        --yum        Use yum instead of pyrpmyum.
"""

pyrpm.setSignals(exitHandler)

if os.geteuid() != 0:
    print "ERROR: You have to be root to perform an installation."
    exit(1)

try:
    (opts, args) = getopt.getopt(sys.argv[1:], "hvyxnwk",
                                 [ "help", "verbose", "xen", "nocleanup",
                                   "wait", "kudzu" ])
except:
    usage()
    exit(1)

for (opt, val) in opts:
    if opt in ["-h", "--help"]:
        usage()
        exit(1)
    elif opt in ["-v", "--verbose"]:
        verbose += 1
        pyrpm.rpmconfig.verbose += 1
    elif opt == "-y":
        confirm = 0
    elif opt in ["-x", "--xen"]:
        xen = 1
    elif opt in ["-n", "--nocleanup"]:
        nocleanup = 1
    elif opt in ["-w", "--wait"]:
        wait = 1
    elif opt in ["-k", "--kudzu"]:
        kudzu = 1
    elif opt == "--yum":
        orig_yum = 1
    else:
        print "Unknown option '%s'" % opt
        usage()
        exit(1)

if len(args) < 1:
    usage()
    exit(1)

# kickstart file
ks_file = args[0]
if not os.path.exists(ks_file):
    print "ERROR: '%s' does not exist." % ks_file
    exit(1)

### create user supplied diskmap ###

diskmap = { }
if len(args) > 1:
    for arg in args[1:]:
        splits = string.split(arg, ":")
        if len(splits) != 2:
            usage()
            exit(1)
        key = string.strip(splits[0])
        val = string.strip(splits[1])
        if not os.path.exists(val):
            print "ERROR: '%s' does not exist." % val
            exit(1)
        diskmap[key] = { }
        mode = os.stat(val).st_mode
        if stat.S_ISREG(mode):
            diskmap[key]["image"] = val
        elif stat.S_ISBLK(mode):
            diskmap[key]["device"] = val
        else:
            print "ERROR: Unsupported type of '%s'." % val
            exit(1)

### load kickstart file ###

ks = pyrpm.KickstartConfig(ks_file)

# TODO: start network in standalone mode for pre script

# run pre script
if ks["pre"] and len(ks["pre"]["script"]) > 0:
    print "Running pre script"
    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0 and ks["pre"].has_key("erroronfail"):
            print "ERROR: Pre script failed, aborting."
            exit(1)
    else:
        interpreter = "bin/sh"
        if ks["pre"].has_key("interpreter"):
            interpreter = ks["pre"]["interpreter"]
        pyrpm.runScript(interpreter, ks["pre"]["script"])
        sys.exit(0)

# parse file again
ks.clear()
ks.parse(ks_file)

# sanity checks
if ks.has_key("install"):
    if not ks["partition"].has_key("/"):
        print "ERROR: root partition not defined"
        exit(1)
else:
    print "ERROR: Only installation is supported, aborting."
    exit(1)

if not ks["nfs"]:
    print "ERROR: Only nfs install is supported, exiting."
    exit(1)

### create system diskmap ###

if len(diskmap) == 0:
    print "WARNING: No device maps defined, using system harddisks!"
    if confirm:
        choice = raw_input("Is this ok [y/N]: ")
        if len(choice) == 0 or choice[0] != "y" and choice[0] != "Y":
            exit(1)
    fd = open("/proc/partitions") # get all disks
    while 1:
        line = fd.readline()
        if not line:
            break
        if line[:5] == "major":
            continue
        line = string.strip(line)
        if len(line) < 1:
            continue
        if line[0] == '#':
            continue
        splits = line.split() # major, minor, blocks, name
        if len(splits) < 4:
            print "ERROR: '/proc/partitions' malformed."
            exit(1)
        if int(splits[1], 16) % 16 == 0: # minor%16=0 for harddisk devices
            diskmap[splits[3]] = { }
            diskmap[splits[3]]["device"] = "/dev/"+splits[3]
    fd.close()

    if len(diskmap) == 0:
        print "ERROR: No harddisks found."
        exit(1)

### disk / partition selection ###

# create partitionmap
partitionmap = { }
for name in ks["partition"]:
    part = ks["partition"][name]

    if part.has_key("onpart"):
        onpart = part["onpart"]
        if onpart[:5] != "/dev/":
            print "ERROR: '%s' is not a valid partition name." % onpart
            exit(1)
        onpart = part["onpart"][5:]
        if onpart in partitionmap:
            print "ERROR: '%s' is used more than once." % part["onpart"]
            exit(1)
        partitionmap[onpart] = { }
        partitionmap[onpart]["name"] = name
        partitionmap[onpart]["disk"] = diskName(onpart)
        partitionmap[onpart]["id"] = partitionId(onpart)
        if partitionmap[onpart]["id"] < 1:
            print "ERROR: Partition id '%d' is not valid." % \
                  partitionmap[onpart]["id"]
            exit(1)
    else:
        print "ERROR: no partition gived for '%s'" % name
        exit(1)

#needed = [ ]
# check partitionmap with diskmap
for part in partitionmap:
    disk_name = partitionmap[part]["disk"]
    if not diskmap.has_key(disk_name):
        print "ERROR: disk '%s' does not exist." % disk_name
        exit(1)
#    if disk_name not in needed:
#        needed.append(disk_name)

## remove unneeded disks
#for disk in diskmap:
#    if not disk in needed:
#        print "INFO: Dropping unneded disk '%s'" % disk
#        del diskmap[disk]
#del needed

# get loop devices for disks, get parted structure
for disk in diskmap.keys():
    if diskmap[disk].has_key("image"):
        # losetup
        device = losetup(diskmap[disk]["image"])
        if not device:
            print "Unable to get loop device, exiting."
            exit(1)
        diskmap[disk]["device"] = device
        diskmap[disk]["disk"] = Disk(device)
        d = diskmap[disk]["disk"]

        if verbose:
            print "C/H/S: %d/%d/%d" % (d.disk.dev.cylinders, d.disk.dev.heads, d.disk.dev.sectors)
            for i in d.partition:
                if d.partition[i].type == parted.PARTITION_PRIMARY:
                    type = "primary"
                elif d.partition[i].type & parted.PARTITION_LOGICAL:
                    type = "logical"

                print "%s %d:" % (type, i)

                print "\t%d-%d size=%d bs=%d" % \
                      (d.partition[i].geom.start, d.partition[i].geom.end,
                       d.partition[i].geom.length,
                       d.partition[i].geom.dev.sector_size)
                if d.partition[i].fs_type and d.partition[i].fs_type.name:
                    print "\t%s" % d.partition[i].fs_type.name
    else:
        diskmap[disk]["device"] = "/dev/" + disk

# are all needed partitions there?
error = 0
for part in partitionmap:
    name = partitionmap[part]["name"]
    disk = partitionmap[part]["disk"]
    id = partitionmap[part]["id"]
    d = diskmap[disk]["disk"]
    if not id in d.partition:
        print "ERROR: partition '%s' does not exist." % part
        error = 1
    if error:
        continue
    if diskmap[disk].has_key("image"):
        partitionmap[part]["blocksize"] = d.partition[id].geom.dev.sector_size
        partitionmap[part]["start"] = d.partition[id].geom.start * \
                                      partitionmap[part]["blocksize"]
        partitionmap[part]["end"] = d.partition[id].geom.end * \
                                    partitionmap[part]["blocksize"]
        partitionmap[part]["length"] = d.partition[id].geom.length
        partitionmap[part]["size"] = d.partition[id].geom.length * \
                                     partitionmap[part]["blocksize"]
        device = losetup(diskmap[disk]["image"], partitionmap[part]["start"])
        partitionmap[part]["device"] = device

    # TODO: update
#    if d.partition[id].fs_type and d.partition[id].fs_type.name:
#        if d.partition[id].fs_type.name in [ "ext2", "ext3" ]:
#            if not ks["partition"][name].has_key("fstype") or \
#                   not ks["partition"][name]["fstype"] in [ "ext2", "ext3" ]:
#                print "ERROR: Partition '%s' does not match filesystem" % part
#                error = 1
#        else:
#            print "ERROR: Filesystem '%s' on '%s' is not supported" % \
#                  (d.partition[id].fs_type.name, part)
#            error = 1
    label = ""
    if ks["partition"][name].has_key("fstype") and \
           ks["partition"][name]["fstype"] in [ "ext2", "ext3" ]:
        label = name
    elif name == "swap":
        label = "swap-%s" % part
    else:
        print "Could not determine filesystem type of '%s'" % part
        error = 1
    if ks["partition"][name].has_key("label"):
        label = ks["partition"][name]["label"]
    partitionmap[part]["label"] = label

if error:
    exit(1)

if verbose:
    print "diskmap=%s" % diskmap
    print "partitionmap=%s" % partitionmap

### format partitions ###

# prepare to format partitions
to_format = [ ]
for part in partitionmap:
    name = partitionmap[part]["name"]
    if not ks["partition"][name].has_key("noformat"):
        to_format.append(part)
to_format.sort()
to_format.reverse()

if confirm == 1 and len(to_format) > 0:
    print "About to format these partitions:"
    for part in to_format:
        name = partitionmap[part]["name"]
        if diskmap[partitionmap[part]["disk"]].has_key("image"):
            disk = "%s:%s" % (partitionmap[part]["disk"],
                              diskmap[partitionmap[part]["disk"]]["image"])
        else:
            disk = partitionmap[part]["disk"]
        print "\t'%s' [%s] on '%s'" % (part, name, disk)
    choice = raw_input("Is this ok [y/N]: ")
    if len(choice) == 0 or choice[0] != "y" and choice[0] != "Y":
        exit(1)

# format
for part in to_format:
    name = partitionmap[part]["name"]
    label = partitionmap[part]["label"]
    disk = partitionmap[part]["disk"]
    partition = ks["partition"][name]

    if partition.has_key("fstype") and \
           (partition["fstype"] == "ext2" or partition["fstype"] == "ext3"):
        mke2fs = "/sbin/mke2fs -q -L '%s'" % label
        if partition["fstype"] == "ext3":
            mke2fs += " -j"
        if diskmap[disk].has_key("image"):
            blocksize = 4096
            mke2fs += " -b %d" % blocksize
        mke2fs += " '%s'" % partitionmap[part]["device"]
        if diskmap[disk].has_key("image"):
            mke2fs += " %d" % (partitionmap[part]["size"] / blocksize)

#        print mke2fs
        print "Formatting '%s' on '%s' (%s)" % \
              (part, partitionmap[part]["disk"], name)

        pid = os.fork()
        if pid != 0:
            (rpid, status) = os.waitpid(pid, 0)
            if status != 0:
                print "ERROR: mke2fs failed."
                exit(1)
        else:
            pyrpm.runScript(script=mke2fs)
            sys.exit(0)

        if partition["fstype"] == "ext3": # set ext options
            tune2fs = "/sbin/tune2fs -c 0 -i 0 -O dir_index '%s'" % \
                      partitionmap[part]["device"]

#            print tune2fs
            print "Tuning filesystem '%s' on '%s'" % \
                  (part, partitionmap[part]["disk"])
            pid = os.fork()
            if pid != 0:
                (rpid, status) = os.waitpid(pid, 0)
                if status != 0:
                    print "ERROR: tune2fs failed."
                    exit(1)
            else:
                pyrpm.runScript(script=tune2fs)
                sys.exit(0)

    elif name == "swap":
        mkswap = "/sbin/mkswap -L '%s' '%s' %d >/dev/null" % \
                 (label, partitionmap[part]["device"],
                  (partitionmap[part]["size"] / 1024))

#        print mkswap
        print "Formatting swap on '%s' (%s)" % (partitionmap[part]["disk"],
                                                name)
        pid = os.fork()
        if pid != 0:
            (rpid, status) = os.waitpid(pid, 0)
            if status != 0:
                print "ERROR: mkswap failed."
                exit(1)
        else:
            pyrpm.runScript(script=mkswap)
            sys.exit(0)
    else:
        print "ERROR: Unknown filesystem for '%s' (%s)" % \
              (partitionmap[part]["disk"], name)
        exit(1)

del to_format

### create temp dir ###

try:
    tempdir = tempfile.mkdtemp(prefix="pyrpmkickstart_")
except Exception, msg:
    print msg
    exit(1)
source_dir = tempdir+"/source"
target_dir = tempdir+"/target"

### mount target ###

os.mkdir(target_dir)

# prepare to format partitions
to_mount = [ ]
mountmap = { }
for part in partitionmap:
    name = partitionmap[part]["name"]
    to_mount.append(name)
    mountmap[name] = part
to_mount.sort()

for mntpnt in to_mount:
    if mntpnt == "swap":
        # TODO: swapon if in standalone mode
        if swapon(partitionmap[mountmap[mntpnt]]["device"]) == 1:
            exit(1)
        partitionmap[mountmap[mntpnt]]["on"] = None
    else:
        if mntpnt == "/":
            dir = target_dir
        else:
            dir = target_dir+mntpnt
            if not os.path.exists(dir):
                try:
                    os.mkdir(dir)
                except Exception, msg:
                    print "ERROR: Could not create '%s': %s" % (dir, msg)
                    exit(1)

        print "Mounting '%s':" % mntpnt
        try:
            mount(partitionmap[mountmap[mntpnt]]["device"], dir,
                  fstype=ks["partition"][mntpnt]["fstype"])
        except Exception, msg:
            print msg
            exit(1)

buildroot = target_dir
pyrpm.rpmconfig.buildroot = buildroot

### mount source ###

# create source mount point and mount source (nfs)
os.mkdir(source_dir)
source = "%s:%s" % (ks["nfs"]["server"], ks["nfs"]["dir"])
try:
    mount(source, source_dir, fstype="nfs")
except Exception, msg:
    print msg
    exit(1)

### package selection ###

# set default group "base" if no groups are specified
if not ks["packages"]:
    ks["packages"] = { }
if not ks["packages"].has_key("groups"):
    ks["packages"]["groups"] = [ ]

if len(ks["packages"]["groups"]) == 0:
    ks["packages"]["groups"].append("base")

# load comps file for groups and default packages
comps_xml = "%s/repodata/comps.xml" % source_dir
if not os.path.exists(comps_xml):
    comps_xml = "%s/RedHat/base/comps.xml" % source_dir
if not os.path.exists(comps_xml):
    print "Could not find comps file, exiting."
    exit(1)
comps = pyrpm.RpmCompsXML(pyrpm.rpmconfig, comps_xml)
comps.read()

pkgs = [ ]
for group in ks["packages"]["groups"]:
    pkgs.extend(comps.getPackageNames(group))

if ks["langsupport"]:
    languages = [ ]
    if ks["langsupport"].has_key("default"):
        languages.append(ks["langsupport"]["default"][:2])
    for lang in ks["langsupport"]["supported"]:
        languages.append(lang[:2])

    for group in comps.grouphash.keys():
        if comps.grouphash[group].has_key("langonly") and \
               comps.grouphash[group]["langonly"] in languages:
            optional_list = comps.getOptionalPackageNames(group)
            for (name, requires) in optional_list:
                for req in requires:
                    if req in pkgs:
                        print "Adding '%s' for langsupport" % name
                        pkgs.append(name)
                        break    

# everything install
if "everything" in ks["packages"]["groups"]:
    for group in comps.grouphash.values():
        if group.has_key("packagelist"):
            pkgs.extend(group["packagelist"])
else:
    # add default desktop
    if ks["xconfig"] and ks["xconfig"].has_key("startxonboot"):
        desktop = "GNOME"
        if ks["xconfig"].has_key("defaultdesktop"):
            desktop = ks["xconfig"]["defaultdesktop"]
        desktop = desktop.lower()
        if not desktop in ks["packages"]["groups"]:
            print "Adding group %s" % desktop
            pkgs.extend(comps.getPackageNames(desktop))

del comps

# add and remove packages from default list
if ks["packages"].has_key("drop"):
    for pkg in ks["packages"]["drop"]:
        if pkg in pkgs:
            pkgs.remove(pkg)
if ks["packages"].has_key("add"):
    for pkg in ks["packages"]["add"]:
        if not pkg in pkgs:
            pkgs.append(pkg)

# add comps package (FC-4)
if not "comps" in pkgs:
    pkgs.append("comps")

# append authconfig, if we want to configure it
if ks["authconfig"] and not "authconfig" in pkgs:
    print "Adding package authconfig"
    pkgs.append("authconfig")

# append iptables, if we want to configure it
if ks["firewall"] and not ks["firewall"].has_key("disabled") and \
       not "iptables" in pkgs:
    print "Adding package iptables"
    pkgs.append("iptables")
    pkgs.append("system-config-securitylevel-tui")

if ks["selinux"]:
    pkgs.append("system-config-securitylevel-tui")

# append xorg-x11, if we want to configure it
if ks["xconfig"]:
    if not "xorg-x11" in pkgs:
        print "Adding package xorg-x11"
        pkgs.append("xorg-x11")
    if ks["xconfig"].has_key("startxonboot") and not "gdm" in pkgs:
        print "Adding package gdm"
        pkgs.append("gdm")
        print "Adding package xorg-x11-twm"
        pkgs.append("xorg-x11-twm")

# append kernel
if not "kernel" in pkgs and not "kernel-smp" in pkgs:
    print "Adding package kernel"
    pkgs.append("kernel")

# append firstboot
if ks["firstboot"] and not ks["firstboot"].has_key("disabled") and \
       not "firstboot" in pkgs:
    print "Adding package firstboot"
    pkgs.append("firstboot")

# append dhclient
if ks["network"] and ks["network"]["bootproto"] == "dhcp" and \
       not "dhclient" in pkgs:
    print "Adding package dhclient"
    pkgs.append("dhclient")

pyrpm.normalizeList(pkgs)

# no packages?
if len(pkgs) < 1:
    print "Nothing to do."
    exit(1)

# create essential directories and files
os.umask(000)

create_dir(buildroot, "/boot")
create_dir(buildroot, "/boot/grub")
create_dir(buildroot, "/dev")
create_dir(buildroot, "/etc")
create_dir(buildroot, "/etc/rpm")
create_dir(buildroot, "/etc/sysconfig")
create_dir(buildroot, "/var")
create_dir(buildroot, "/var/log")
create_dir(buildroot, "/tmp")

# /dev
if not os.path.exists(buildroot+"/dev/console"):
    os.mknod(buildroot+"/dev/console", 0666 | stat.S_IFCHR, os.makedev(5, 1))
if not os.path.exists(buildroot+"/dev/null"):
    os.mknod(buildroot+"/dev/null", 0666 | stat.S_IFCHR, os.makedev(1, 3))
if not os.path.exists(buildroot+"/dev/zero"):
    os.mknod(buildroot+"/dev/zero", 0666 | stat.S_IFCHR, os.makedev(1, 5))

# /etc/sysconfig/kernel
if not os.path.exists(buildroot+"/etc/sysconfig/kernel"):
    print "Configuring kernel"
    try:
        fd = open(buildroot+"/etc/sysconfig/kernel", "w")
        fd.write('# UPDATEDEFAULT specifies if new-kernel-pkg should make\n')
        fd.write('# new kernels the default\n')
        fd.write('UPDATEDEFAULT=yes\n')
        fd.write('\n')
        fd.write('# DEFAULTKERNEL specifies the default kernel package type\n')
        fd.write('DEFAULTKERNEL=kernel\n')
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/kernel' failed:", msg

# /etc/fstab
if not os.path.exists(buildroot+"/etc/fstab"):
    fd = open(buildroot+"/etc/fstab", "w")
    partitions = partitionmap.keys()
    partitions.sort()
    partitions.reverse()
    for part in partitions:
        name = partitionmap[part]["name"]

        major = minor = 0
        if ks["partition"][name].has_key("fstype") and name != "swap":
            fs = ks["partition"][name]["fstype"]
            major = 1
            if name == "/":
                minor = 1
            else:
                minor = 2
            fd.write("LABEL=%s\t\t%s\t\t%s\tdefaults\t%d %d\n" % \
                     (partitionmap[part]["label"], name, fs, major, minor))
        elif name == "swap":
            continue
        else:
            print "ERROR: Unknown filesystem for '%s' (%s)" % \
                  (partitionmap[part]["disk"], name)
            continue
    fd.write("/dev/devpts\t\t/dev/pts\t\tdevpts\tgid=5,mode=620\t0 0\n")
    fd.write("/dev/shm\t\t/dev/shm\t\ttmpfs\tdefaults\t0 0\n")
    fd.write("/dev/proc\t\t/proc\t\tproc\tdefaults\t0 0\n")
    fd.write("/dev/sys\t\t/sys\t\tsysfs\tdefaults\t0 0\n")
    for part in partitions:
        if partitionmap[part]["name"] == "swap":
            fd.write("LABEL=%s\t\t%s\t\t%s\tdefaults\t0 0\n" % \
                     (partitionmap[part]["label"], partitionmap[part]["name"],
                      partitionmap[part]["name"]))
    fd.close()

# /etc/hosts
if not os.path.exists(buildroot+"/etc/hosts"):
    fd = open(buildroot+"/etc/hosts", "w")
    fd.write("# Do not remove the following line, or various programs\n")
    fd.write("# that require network functionality will fail.\n")
    hostname = ""
    if ks["network"].has_key("hostname") and not ks["network"].has_key("ip"):
        hostname = "%s\t" % ks["network"]["hostname"]
    fd.write("127.0.0.1\t\t%slocalhost.localdomain\tlocalhost\n" % hostname)
    if ks["network"].has_key("hostname") and ks["network"].has_key("ip"):
        fd.write("%s\t\t%s\n" % (ks["network"]["ip"],
                                 ks["network"]["hostname"]))
    fd.close()

# /etc/resolv.conf
if not os.path.exists(buildroot+"/etc/resolv.conf"):
    fd = open(buildroot+"/etc/resolv.conf", "w")
    if ks["network"]:
        if ks["network"].has_key("hostname"):
            hostname = ks["network"]["hostname"]
            idx = string.find(hostname, ".")
            if idx >= 0:
                domainname = hostname[(idx+1):]
                fd.write("search %s\n" % domainname)
        if ks["network"].has_key("nameserver") and \
               not ks["network"] and ks["network"].has_key("nodns"):
            fd.write("nameserver %s\n" % ks["network"]["nameserver"])
    fd.close()

# /etc/modprobe.conf
if not os.path.exists(buildroot+"/etc/modprobe.conf"):
    fd = open(buildroot+"/etc/modprobe.conf", "w")
    # add options for defined devices in ks["device"]
    if ks["device"] and len(ks["device"]) > 0:
        for type in ks["device"]:
            if ks["device"][type] and len(ks["device"][type]) > 0:
                for module in ks["device"][type]:
                    if ks["device"][type][module].has_key("opts"):
                        fd.write('options %s %s\n' % \
                                 (module, ks["device"][type][module]["opts"]))
    fd.close()

# /etc/rpm/platform
(sysname, nodename, release, version, machine) = os.uname()
if not os.path.exists(buildroot+"/etc/rpm/platform"):
    fd = open(buildroot+"/etc/rpm/platform", "w")
    fd.write("%s-redhat-linux" % machine)
    fd.close()

# /var/log/lastlog
if not os.path.exists(buildroot+"/var/log/lastlog"):
    fd = open(buildroot+"/var/log/lastlog", "w")
    fd.close()

# /var/log/messages
if not os.path.exists(buildroot+"/var/log/messages"):
    fd = open(buildroot+"/var/log/messages", "w")
    fd.close()

### installation ###

print "Preparing installation"

# configure yum
os.mkdir("%s/yum.cache" % tempdir)
os.mkdir("%s/yum.repos.d" % tempdir)
yum_conf = tempdir+"/yum.conf"
fd = open(yum_conf, "w")
fd.write("[main]\n")
fd.write("cachedir=%s/yum.cache\n" % tempdir)
fd.write("debuglevel=0\n")
fd.write("errorlevel=0\n")
fd.write("pkgpolicy=newest\n")
fd.write("distroverpkg=redhat-release\n")
fd.write("tolerant=1\n")
fd.write("exactarch=1\n")
fd.write("retries=20\n")
fd.write("obsoletes=1\n")
fd.write("reposdir=%s/yum.repos.d\n" % tempdir)
fd.write("\n")
fd.write("[dist]\n")
fd.write("name=dist\n")
fd.write("baseurl=file:%s/source\n" % tempdir)
fd.close()

# yum
if orig_yum:
    yum = "yum -y -c '%s' --installroot='%s'" % (yum_conf, buildroot)
else:
    yum = "PYTHONPATH=%s %s/scripts/pyrpmyum -y -c '%s' -r '%s'" % \
          (PYRPMDIR, PYRPMDIR, yum_conf, buildroot)
    # --servicehack
if ks["packages"].has_key("ignoredeps") and \
       ks["packages"].has_key("ignoremissing"):
    yum += " --nodeps"
if ks.has_key("install"):
    yum += " install "
elif ks.has_key("update"):
#    if ks["packages"].has_key("resolvedeps"):
#        yum += " --autoerase "
    yum += " update "
yum += string.join(pkgs)
#print yum
pid = os.fork()
if pid != 0:
    (rpid, status) = os.waitpid(pid, 0)
    if status != 0:
        print "ERROR: Installation failed, aborting."
        exit(1)
else:
    os.system(yum)
    sys.exit(0)

### configuration ###

# check system dirs
if not check_dir(buildroot, "/etc") or \
       not check_dir(buildroot, "/etc/sysconfig"):
    print "Aborting."
    exit(1)

## run kudzu
if kudzu:
    print "Running kudzu"
    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: kudzu failed."
    else:
        os.chroot(buildroot)
        pyrpm.runScript(script="/usr/sbin/kudzu -q -s")
        sys.exit(0)

# run authconfig if set
if ks["authconfig"]:
    print "Configuring authentication"

    # Create /etc/samba for authconfig
    if not os.path.exists(buildroot+"/etc/samba"):
        os.mkdir(buildroot+"/etc/samba")

    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: authconfig failed"
    else:
        os.chroot(buildroot)
        authconfig = "/usr/bin/authconfig --kickstart --nostart"
        for tag in ks["authconfig"]:
            if ks["authconfig"][tag]:
                authconfig += " --%s=%s" % (tag, ks["authconfig"][tag])
            else:
                authconfig += " --%s" % tag
#        print authconfig
        pyrpm.runScript(script=authconfig)
        sys.exit(0)

# setting root password
if ks["rootpw"]:
    print "Setting root password"

    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: Setting root password failed"
    else:
        os.chroot(buildroot)
        password = ks["rootpw"].keys()[0]
        if not ks["rootpw"][password].has_key("iscrypted"):
            salt = ""
            salt_len = 2
            if ks["authconfig"].has_key("enablemd5"):
                salt = "$1$"
                salt_len = 8
            for i in range(salt_len):
                salt += random.choice(string.letters+string.digits+"./")
            password = crypt.crypt(password, salt)
        pyrpm.runScript(script="/usr/sbin/usermod -p '%s' root" % password)
        sys.exit(0)

# /etc/inittab
if ks["xconfig"] and ks["xconfig"].has_key("startxonboot"):
    print "Configuring runlevel"

    try:
        fd_in = open(buildroot+"/etc/inittab", "r")
        fd_out = open(buildroot+"/etc/inittab.pyrpmkickstart", "w")
        while 1:
            line = fd_in.readline()
            if not line:
                break
            if len(line) > 3 and line[:3] == "id:":
                id = string.split(line, ":")
                if len(id) > 1:
                    id[1] = "5"
                    line = string.join(id, ":")
                else:
                    print "ERROR: Malformed '/etc/inittab'"
            fd_out.write(line)
        fd_in.close()
        fd_out.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/inittab' failed:", msg
    else:
        os.unlink(buildroot+"/etc/inittab")
        os.rename(buildroot+"/etc/inittab.pyrpmkickstart",
                  buildroot+"/etc/inittab")

# /etc/sysconfig/selinux
if ks["selinux"]:
    print "Configuring selinux"

    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: Setting root password failed"
    else:
        os.chroot(buildroot)
        lokkit = "/usr/sbin/lokkit --quiet --nostart --selinux='%s'" % \
                 ks["selinux"].keys()[0]
        pyrpm.runScript(script=lokkit)
        sys.exit(0)


# /etc/sysconfig/clock
if ks["timezone"]:
    print "Configuring timezone"
    zone = ks["timezone"].keys()[0]
    try:
        fd = open(buildroot+"/etc/sysconfig/clock", "w")
        fd.write('ZONE="%s"\n' % zone)
        if ks["timezone"][zone].has_key("utc"):
            fd.write('UTC=true\n')
        else:
            fd.write('UTC=false\n')
        fd.write('ARC=false\n')
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/clock' failed:", msg

    # Create /etc/localtime
    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: Could not create /etc/localtime."
    else:
        os.chroot(buildroot)
        tzfile = "/usr/share/zoneinfo/" + zone
        # do not hardlink /etc/localtime, has to be copy for system-config-date
#        pyrpm.runScript(script="rm -f /etc/localtime; ln '%s' /etc/localtime 2>/dev/null || cp '%s' /etc/localtime" % (tzfile, tzfile))
        pyrpm.runScript(script="rm -f /etc/localtime; cp '%s' /etc/localtime" % tzfile)
        sys.exit(0)

# /etc/sysconfig/desktop
print "Configuring desktop"
try:
    fd = open(buildroot+"/etc/sysconfig/desktop", "w")
    desktop = "GNOME"
    if ks["xconfig"] and ks["xconfig"].has_key("defaultdesktop"):
        desktop = ks["xconfig"]["defaultdesktop"]
    fd.write('DESKTOP="%s"\n' % desktop)
    fd.close()
except Exception, msg:
    print "ERROR: Configuration of '/etc/sysconfig/desktop' failed:", msg

# /etc/sysconfig/i18n
if ks["langsupport"]:
    print "Configuring languages"
    try:
        fd = open(buildroot+"/etc/sysconfig/i18n", "w")
        if ks["langsupport"].has_key("default"):
            fd.write('LANG="%s"\n' % ks["langsupport"]["default"])
            if ks["langsupport"].has_key("supported") and \
                   len(ks["langsupport"]["supported"]) > 0:
                fd.write('SUPPORTED="%s"\n' % \
                         string.join(ks["langsupport"]["supported"], ":"))
        else:
            fd.write('LANG="%s"\n' % \
                     string.join(ks["langsupport"]["supported"], ":"))
        fd.write('SYSFONT="latarcyrheb-sun16"\n')
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/i18n' failed:", msg

# /etc/sysconfig/installinfo
print "Configuring installinfo"
try:
    fd = open(buildroot+"/etc/sysconfig/installinfo", "w")
    fd.write('INSTALLMETHOD=nfs\n')
    fd.close()
except Exception, msg:
    print "ERROR: Configuration of '/etc/sysconfig/installinfo' failed:", msg

# /etc/sysconfig/iptables
if ks["firewall"] and not ks["firewall"].has_key("disabled"):
    print "Configuring firewall"

    args = [ ]
    if ks["firewall"].has_key("enabled"):
        args.append("--enabled")
    if ks["firewall"].has_key("disabled"):
        args.append("--disabled")
    if ks["firewall"].has_key("trusted"):
        for trusted in ks["firewall"]["trusted"]:
            args.append("--trusted=%s\n" % trusted)
    if ks["firewall"].has_key("ports"):
        for port in ks["firewall"]["ports"]:
            args.append("--port=%s:%s\n" % (port[0], port[1]))

    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: Configuration of firewall failed"
    else:
        os.chroot(buildroot)
        lokkit = "/usr/sbin/lokkit --quiet --nostart -f %s" % string.join(args)
        pyrpm.runScript(script=lokkit)
        sys.exit(0)

    try:
        fd = open(buildroot+"/etc/sysconfig/system-config-securitylevel", "w")
        fd.write('# Configuration file for system-config-securitylevel\n')
        fd.write('\n')
        for arg in args:
            fd.write('%s\n' % arg)
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/system-config-securitylevel' failed:", msg

# /etc/sysconfig/keyboard
if ks["keyboard"]:
    print "Configuring keyboard"
    try:
        fd = open(buildroot+"/etc/sysconfig/keyboard", "w")
        fd.write('KEYBOARDTYPE="pc"\n')
        fd.write('KEYTABLE="%s"\n' % ks["keyboard"])
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/keyboard' failed: ", msg

# /etc/sysconfig/mouse
print "Configuring generic IMPS/2 mouse"
pid = os.fork()
if pid != 0:
    (rpid, status) = os.waitpid(pid, 0)
    if status != 0:
        print "ERROR: mouseconfig failed"
else:
    os.chroot(buildroot)
    pyrpm.runScript(script="/usr/sbin/mouseconfig --noui genericwheelps/2")
    sys.exit(0)

# setup networking
if ks["network"]:
    print "Configuring network"
    try:
        fd = open(buildroot+"/etc/sysconfig/network", "w")
        fd.write('NETWORKING=yes\n')
        if ks["network"].has_key("hostname"):
            fd.write('HOSTNAME=%s\n' % ks["network"]["hostname"])
        else:
            fd.write('HOSTNAME=localhost.localdomain\n')
#        if ks["network"].has_key("gateway"):
#            fd.write('GATEWAY=%s\n' % ks["network"]["gateway"])
        fd.close()
        if not os.path.exists(buildroot+"/etc/sysconfig/network-scripts"):
            os.mkdir(buildroot+"/etc/sysconfig/network-scripts")

        device = "eth0"
        if ks["network"].has_key("device"):
            device = ks["network"]["device"]

        if device[:3] == "ctc":
            type = "CTC"
        elif device[:4] == "iucv":
            type = "IUCV"
        elif device[:2] == "tr":
            type = '"Token Ring"'
        else:
            type = "Ethernet"

        bootproto = "none"
        if ks["network"]["bootproto"] and \
               ks["network"]["bootproto"] != "static":
            bootproto = ks["network"]["bootproto"]

        fd = open(buildroot+"/etc/sysconfig/network-scripts/ifcfg-%s" % \
                      ks["network"]["device"], "w")
        fd.write('DEVICE=%s\n' % device)
        fd.write('BOOTPROTO=%s\n' % bootproto)
        if ks["network"].has_key("gateway"):
            fd.write('GATEWAY=%s\n' % ks["network"]["gateway"])
        if ks["network"].has_key("netmask"):
            fd.write('NETMASK=%s\n' % ks["network"]["netmask"])
        if ks["network"].has_key("ip"):
            fd.write('IPADDR=%s\n' % ks["network"]["ip"])
        if ks["network"].has_key("essid"):
            fd.write('ESSID=%s\n' % ks["network"]["essid"])
        if ks["network"].has_key("ethtool"):
            fd.write('ETHTOOL_OPTS=%s\n' % ks["network"]["ethtool"])
        if ks["network"].has_key("class"):
            fd.write('DHCP_CLASSID=%s\n' % ks["network"]["class"])
        if ks["network"].has_key("onboot"):
            fd.write('ONBOOT=%s\n' % ks["network"]["onboot"])
        else:
            fd.write('ONBOOT=yes\n')
        fd.write('TYPE=%s\n' % type)
        fd.close()

        if ks["network"].has_key("wepkey"):
            fd = open(buildroot+"/etc/sysconfig/network-scripts/keys-%s" % \
                      ks["network"]["device"], "w")
            fd.write('KEY=%s\n' % ks["network"]["wepkey"])
            fd.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/network' failed:", msg

# /etc/X11/xorg.conf
if ks["xconfig"]:
    print "Configuring xorg.conf"

    # default: VGA graphics card, Generic extended super VGA monitor
    card = "Unknown video card"
    card_driver = "vga"
    videoram = 0
    monitor = "Unknown monitor"
    hsync = "31.5 - 37.9"
    vsync = "50 - 61"
    resolution = "800x600"
    depth = 16
    user_hsync = user_vsync = None

    # keyboard
    keyboard_models = keyboard_models.KeyboardModels().get_models()
    (kbd_name, kbd_layout, kbd_model, kbd_variant, kbd_options) = \
               keyboard_models[ks["keyboard"]]

    if ks["xconfig"].has_key("card"):
        fd = open ('/usr/share/hwdata/Cards')
        found = 0
        while 1:
            line = fd.readline()
            if not line:
                break
            line = string.strip(line)
            if len(line) < 1 or line[0] == "#":
                continue
            if not found:
                if line[:4] != "NAME":
                    continue
                name = string.strip(line[4:])
                if name == ks["xconfig"]["card"]:
                    found = 1
            elif string.strip(line[:6]) == "DRIVER":
                card = ks["xconfig"]["card"]
                card_driver = string.strip(line[6:])
                found = 2
                break
        fd.close()
        if found != 2:
            print "ERROR: Card not found in hardware database."
    if ks["xconfig"].has_key("videoram"):
        videoram = ks["xconfig"]["videoram"]
    if ks["xconfig"].has_key("monitor"):
        fd = open ('/usr/share/hwdata/MonitorsDB')
        found = 0
        while 1:
            line = fd.readline()
            if not line:
                break
            line = string.strip(line)
            if len(line) < 1 or line[0] == "#":
                continue
            args = string.split(line, ";")
            if len(args) < 5:
                continue
            if string.strip(args[1]) == ks["xconfig"]["monitor"]:
                monitor = ks["xconfig"]["monitor"]
                hsync = string.strip(args[3])
                vsync = string.strip(args[4])
                found = 1
                break
        fd.close()
        if found != 1:
            print "ERROR: Monitor not found in hardware database."
    if ks["xconfig"].has_key("hsync"): # overwrite with user supplied value
        hsync = ks["xconfig"]["hsync"]
    if ks["xconfig"].has_key("vsync"):
        vsync = ks["xconfig"]["vsync"] # overwrite with user supplied value
    if ks["xconfig"].has_key("resolution"):
        resolution = ks["xconfig"]["resolution"]
    if ks["xconfig"].has_key("depth"):
        depth = ks["xconfig"]["depth"]

    try:
        fd = open(buildroot+"/etc/X11/xorg.conf", "w")
        fd.write('Section "ServerLayout"\n')
        fd.write('        Identifier   "Default Layout"\n')
        fd.write('        Screen       0 "Screen0" 0 0\n')
        fd.write('        InputDevice  "Mouse0" "CorePointer"\n')
        fd.write('        InputDevice  "Keyboard0" "CoreKeyboard"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "Files"\n')
        fd.write('        RgbPath      "/usr/X11R6/lib/X11/rgb"\n')
        fd.write('        FontPath     "unix/:7100"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "Module"\n')
        fd.write('        Load         "dbe"\n')
        fd.write('        Load         "extmod"\n')
        fd.write('        Load         "fbdevhw"\n')
        fd.write('        Load         "record"\n')
        fd.write('        Load         "freetype"\n')
        fd.write('        Load         "type1"\n')
        fd.write('        Load         "glx"\n')
        fd.write('        Load         "dri"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "InputDevice"\n')
        fd.write('        Identifier   "Keyboard0"\n')
        fd.write('        Driver       "kbd"\n')
        fd.write('        Option       "XkbModel" "%s"\n' % kbd_model)
        fd.write('        Option       "XkbLayout" "%s"\n' % kbd_layout)
        if kbd_variant and len(kbd_variant) > 0:
            fd.write('        Option       "XkbVariant" "%s"\n' % kbd_variant)
        if kbd_options and len(kbd_options) > 0:
            fd.write('        Option       "XkbOptions" "%s"\n' % kbd_options)
        fd.write('EndSection\n\n')
        fd.write('Section "InputDevice"\n')
        fd.write('        Identifier   "Mouse0"\n')
        fd.write('        Driver       "mouse"\n')
        fd.write('        Option       "Protocol" "IMPS/2"\n')
        fd.write('        Option       "Device" "/dev/input/mice"\n')
        fd.write('        Option       "ZAxisMapping" "4 5"\n')
        fd.write('        Option       "Emulate3Buttons" "no"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "Monitor"\n')
        fd.write('        Identifier   "Monitor0"\n')
        fd.write('        VendorName   "Monitor Vendor"\n')
        fd.write('        ModelName    "%s"\n' % monitor)
        if hsync:
            fd.write('        HorizSync    %s\n' % hsync)
        if vsync:
            fd.write('        VertRefresh  %s\n' % vsync)
        fd.write('        Option       "dpms"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "Device"\n')
        fd.write('        Identifier   "Videocard0"\n')
        fd.write('        VendorName   "Videocard vendor"\n')
        fd.write('        BoardName    "%s"\n' % card)
        fd.write('        Driver       "%s"\n' % card_driver)
        if videoram:
            fd.write('        VideoRam     %s\n' % videoram)
        fd.write('EndSection\n\n')
        fd.write('Section "Screen"\n')
        fd.write('        Identifier   "Screen0"\n')
        fd.write('        Device       "Videocard0"\n')
        fd.write('        Monitor      "Monitor0"\n')
        fd.write('        DefaultDepth %s\n' % depth)
        fd.write('        SubSection "Display"\n')
        fd.write('                Viewport 0 0\n')
        fd.write('                Depth    %s\n' % depth)
        fd.write('                Modes    "%s"\n' % resolution)
        fd.write('        EndSubSection\n')
        fd.write('EndSection\n\n')
        fd.write('Section "DRI"\n')
        fd.write('        Group        0\n')
        fd.write('        Mode         0666\n')
        fd.write('EndSection\n')
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/X11/xorg.conf' failed:", msg

# /etc/sysconfig/firstboot
print "Configuring firstboot"
if ks["firstboot"]:
    if ks["firstboot"].has_key("reconfig"):
        try:
            fd = open(buildroot+"/etc/reconfigSys", "w")
            fd.close()
        except Exception, msg:
            print "ERROR: Configuration of '/etc/reconfigSys' failed:", msg
    if ks["firstboot"].has_key("disabled"):
        try:
            fd = open(buildroot+"/etc/sysconfig/firstboot", "w")
            fd.write('RUN_FIRSTBOOT=NO\n')
            fd.close()
        except Exception, msg:
            print "ERROR: Configuration of '/etc/syscofig/firstboot' failed:",\
                  msg

# /boot/grub/grub.conf
if ks["bootloader"] and not (ks["bootloader"].has_key("location") and \
                             ks["bootloader"]["location"] == "none"):

    # TODO: password, md5pass, lba32, update
    prefix = "/boot"
    dir = "/"
    have = "have"
    if mountmap.has_key("/boot"):
        dir = "/boot"
        prefix = ""
        have = "do not have"

    append=""
    if ks["bootloader"] and ks["bootloader"].has_key("append"):
        append = " "+ks["bootloader"]["append"]

    hds = diskmap.keys()
    hds.sort()
    # driveorder
    if ks["bootloader"].has_key("driveorder"):
        hds_ = ks["bootloader"]["driveorder"]
        for hd in hds:
            if hd not in hds_:
                hds_.append(hd)
        hds = hds_
    hdmap = { }
    id = 0
    for hd in hds:
        hdmap[hd] = "hd%d" % id
        id += 1
    if verbose:
        print "hdmap=%s" % hdmap

    hd_boot = "%s,%d" % (hdmap[partitionmap[mountmap[dir]]["disk"]],
                         (partitionmap[mountmap[dir]]["id"] - 1))

    kernels = [ ]
    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: Installation failed, aborting."
            exit(1)
    else:
        os.chroot(buildroot)
        # TODO: better
        pyrpm.runScript(script="rpm -qla 'kernel*' | grep /boot/vmlinuz | cut -d- -f2- >/tmp/installed-kernels 2>/dev/null")
        sys.exit(0)


    fd = open(buildroot+"/tmp/installed-kernels")
    kernels = fd.readlines()
    fd.close()
    if len(kernels) < 1:
        print "ERROR: No kernels are installed."
        exit(1)
    kernels.sort()
    kernels.reverse()

    location = "mbr"
    if ks["bootloader"].has_key("location"):
        location = ks["bootloader"]["location"]
    if location == "mbr":
        location = partitionmap[mountmap[dir]]["disk"]
    elif location == "partition":
        location = mountmap[dir]

    if not os.path.exists(buildroot+"/boot/grub/grub.conf") and not \
           ks["bootloader"].has_key("upgrade"):
        print "Configuring grub"

        fd = open(buildroot+"/boot/grub/grub.conf", "w")
        fd.write('# grub.conf generated by pyrpmkickstart\n')
        fd.write('#\n')
        fd.write('# Note that you do not have to rerun grub after making changes to this file\n')
        fd.write('# NOTICE:  You %s a /boot partition.  This means that\n' % have)
        fd.write('#          all kernel and initrd paths are relative to %s/, eg.\n' % prefix)
        fd.write('#          root (%s)\n' % hd_boot)
        fd.write('#          kernel %s/vmlinuz-version ro root=/dev/%s\n' % \
                 (prefix, mountmap["/"]))
        fd.write('#          initrd %s/initrd-version.img\n' % prefix)
        fd.write('#boot=/dev/%s\n' % location)
        fd.write('default=0\n')
        fd.write('timeout=5\n')
        fd.write('splashimage=(%s)%s/grub/splash.xpm.gz\n' % (hd_boot,
                                                              prefix))
        # configure all kernels:
        for kernel in kernels:
            kernel = string.strip(kernel)
            fd.write('title Fedora Core (%s)\n' % kernel)
            fd.write('\troot (%s)\n' % hd_boot)
            fd.write('\tkernel %s/vmlinuz-%s ro root=LABEL=%s%s\n' % \
                     (prefix, kernel, partitionmap[mountmap["/"]]["label"],
                      append))
            fd.write('\tinitrd %s/initrd-%s.img\n' % (prefix, kernel))

        fd.close()

        buildroot_copy("/usr/share/grub/i386-redhat/stage1",
                       "/boot/grub/stage1")
        buildroot_copy("/usr/share/grub/i386-redhat/stage2",
                       "/boot/grub/stage2")
        buildroot_copy("/usr/share/grub/i386-redhat/e2fs_stage1_5",
                       "/boot/grub/e2fs_stage1_5")

        # create temporary devices which are usable by grub (hda, hda1, ..)
        devmap = { } # device mapping
        for disk in diskmap:
            stats = os.stat(diskmap[disk]["device"])
            tmpdev = "/tmp/%s" % disk
            devmap[diskmap[disk]["device"]] = tmpdev
            os.mknod(buildroot+tmpdev, stats.st_mode, stats.st_rdev)
        for part in partitionmap:
            stats = os.stat(partitionmap[part]["device"])
            tmpdev = "/tmp/%s%d" % (partitionmap[part]["disk"],
                                    partitionmap[part]["id"])
            devmap[partitionmap[part]["device"]] = tmpdev
            os.mknod(buildroot+tmpdev, stats.st_mode, stats.st_rdev)

        fd = open(buildroot+"/tmp/grub-setup", "w")
        fd.write('/sbin/grub --batch >/tmp/grub-setup.log <<EOF\n')
        fd.write('device (fd0) /dev/fd0\n')
        for disk in diskmap:
            fd.write('device (%s) %s\n' % (hdmap[disk],
                                           devmap[diskmap[disk]["device"]]))
            if diskmap[disk].has_key("image"):
                fd.write('geometry (%s) %d %d %d\n' % \
                         (hdmap[disk],
                          diskmap[disk]["disk"].dev.cylinders,
                          diskmap[disk]["disk"].dev.heads,
                          diskmap[disk]["disk"].dev.sectors))
        fd.write('root (%s)\n' % hd_boot)
        if hdmap.has_key(location):
            hd = hdmap[location]
        else:
            hd = "%s,%d" % (hdmap[diskName(location)], partitionId(location))
        fd.write('setup (%s)\n' % hd)
        fd.write('quit\n')
        fd.write('EOF\n')
        fd.close()

        pid = os.fork()
        if pid != 0:
            (rpid, status) = os.waitpid(pid, 0)
            if status != 0:
                print "ERROR: grub setup failed"
        else:
            os.chroot(buildroot)
            pyrpm.runScript(script="/bin/sh /tmp/grub-setup")
            sys.exit(0)

        # TODO: remove temporary devices
        for dev in devmap:
            os.unlink(buildroot+devmap[dev])

# run post script
if ks["post"] and len(ks["post"]["script"]) > 0:
    print "Running post script"
    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0 and ks["post"].has_key("erroronfail"):
            print "ERROR: post script failed"
            exit(1)
    else:
        if not ks["post"].has_key("nochroot"):
            os.chroot(buildroot)
        interpreter = "bin/sh"
        if ks["post"].has_key("interpreter"):
            interpreter = ks["post"]["interpreter"]
        pyrpm.runScript(interpreter, ks["post"]["script"])
        sys.exit(0)

if xen:
    print "Writing xen.conf"
    try:
        fd = open("xen.conf", "w")
        fd.write('kernel = "/boot/vmlinuz-VERSION"\n')
        fd.write('ramdisk = "/boot/initrd-VERSION.img"\n')
        fd.write('memory = 128\n')
        fd.write('name = "xen"\n')
        fd.write('nics = 1\n')
        for disk in diskmap:
            if diskmap[disk].has_key("image") and \
                   diskmap[disk].has_key("device"):
                fd.write('disk = [ "file:%s,%s,r" ]\n' % \
                         (diskmap[disk]["image"], disk))
            else:
                fd.write('disk = [ "phy:%s,%s,r" ]\n' % \
                         (diskmap[disk]["device"], disk))
        fd.write('root = "/dev/sda1"\n')
        fd.write('extra = "ro"\n')
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of 'xen.conf' failed:", msg

# cleanup
exit(0)

##############################################################################

"""
########################## TODO ##########################

/etc/modprobe.conf
/boot/grub/grub.conf
"""
