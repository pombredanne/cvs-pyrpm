#!/usr/bin/python
#
# (c) 2005 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published by
# the Free Software Foundation; version 2 only
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2004, 2005 Red Hat, Inc.
#
# AUTHOR: Thomas Woerner <twoerner@redhat.com>
#

import os, sys, md5, stat, tempfile, string, time, stat, getopt, types, parted
import random, crypt
import rhpl.diskutil as diskutil

PYRPMDIR = os.path.abspath("..")
if not PYRPMDIR in sys.path:
    sys.path.append(PYRPMDIR)

import pyrpm

################################### classes ###################################

class KickstartConfig(dict):
    REQUIRED_TAGS = [ "authconfig", "bootloader", "keyboard", "lang",
                      "langsupport", "rootpw", "timezone" ]
    # Currently unsupported tags:
    # driverdisk, logvol, raid, xconfig, volgroup


    def __init__(self, filename):
        dict.__init__(self)
        self.parse(filename)

    def __getitem__(self, item):
        if not self.has_key(item):
            return None
        return dict.__getitem__(self, item)

    def clear(self):
        for key in self.keys():
            del self[key]

    def parse(self, filename):
        self["filename"] = filename
        try:
            _fd = open(filename, "r")
        except:
            raise IOError, "Unable to open '%s'" % args[1]

        in_packages = 0
        in_post = 0
        in_pre = 0
        fd = [ _fd ]
        open_files = [ filename ]
        while 1:
            line = fd[0].readline()

            if not line:
                if len(fd) > 0:
                    _fd = fd.pop(0)
                    _fd.close()
                if len(fd) == 0:
                    break

            line = string.rstrip(line)
            if len(line) < 1: continue
            if line[0] == '#': continue

            args = noquote_split(line)
            opt = args[0]

            if opt == "%packages":
                self.parseSimple(opt[1:], args[1:],
                                 [ "resolvedeps", "ignoredeps",
                                   "ignoremissing" ])
                in_packages = 1
                in_post = 0
                in_pre = 0
                continue
            elif opt == "%post":
                self.parseSimple(opt[1:], args[1:],
                                 [ "nochroot", "interpreter=",
                                   "erroronfail" ])
                in_packages = 0
                in_post = 1
                in_pre = 0
                continue
            elif opt == "%pre":
                self.parseSimple(opt[1:], args[1:],
                                 [ "erroronfail", "interpreter=" ])
                in_packages = 0
                in_post = 0
                in_pre = 1
                continue
            elif opt == "%include":
                if len(args) == 2:
                    try:
                        _fd = open(args[1], "r")
                    except:
                        print "Unable to open '%s', ignoring." % args[1]
                    else:
                        if args[1] in open_files:
                            raise ValueError, \
                                  "Include loop detected for '%s'" % args[1]
                        fd.insert(0, _fd)
                        open_files.append(args[1])
                else:
                    raise ValueError, "Error in line '%s'" % line
                continue

            if not in_packages and not in_post and not in_pre:
                if len(args) == 1:
                    if opt in [ "autopart", "autostep", "cdrom", "cmdline",
                                "install", "interactive", "reboot", "skipx",
                                "text", "upgrade", "mouse" ]:
                        self[opt] = None
                    else:
                        print "'%s' is unsupported" % line
                    continue

                if opt in [ "keyboard", "lang", "zerombr" ]:
                    if len(args) > 2:
                        raise ValueError, "Error in line '%s'" % line
                    self[opt] = args[1]
                    continue

                if opt == "auth" or opt == "authconfig":
                    self.parseSimple("authconfig", args[1:],
                                     [ "enablemd5", "enablenis", "nisdomain=",
                                       "nisserver=", "useshadow",
                                       "enableshadow", "enableldap",
                                       "enableldapauth", "ldapserver=",
                                       "ldapbasedn=", "enableldaptls",
                                       "enablekrb5", "krb5realm=",
                                       "krb5adminserver=", "enablehesiod",
                                       "hesiodlhs=", "hesiodrhs=",
                                       "enablesmbauth", "smbservers=",
                                       "smbworkgroup=", "enablecache" ],
                                     { "useshadow": "enableshadow" })
                elif opt == "bootloader":
                    self.parseSimple(opt, args[1:],
                                     [ "append:", "driveorder:", "location:",
                                       "password:", "md5pass:", "lba32",
                                       "upgrade" ])
                    if self["bootloader"].has_key("driveorder"):
                        order = string.split(self["bootloader"]["driveorder"],
                                             ",")
                        self["bootloader"]["driveorder"] = order
                elif opt == "clearpart":
                    self.parseSimple(opt, args[1:],
                                     [ "all", "drives:", "initlabel", "linux",
                                       "none" ])
                    if self["clearpart"].has_key("drives"):
                        order = string.split(self["bootloader"]["drives"], ",")
                        self["bootloader"]["drives"] = order
                elif opt == "device":
                    (_dict, _args) = self.parseArgs(opt, args[1:], [ "opts:" ])
                    if len(_args) != 2:
                        raise ValueError, "'%s' is unsupported" % line
                    if not self[opt]:
                        self[opt] = { }
                    if not self[opt].has_key(_args[0]):
                        self[opt][_args[0]] = { }
                    self[opt][_args[0]][_args[1]] = _dict
                # TODO: driverdisk
                elif opt == "firewall":
                    # firewall is special, so we have to do it by hand
                    if self[opt]:
                        raise ValueError, "%s already set." % opt

                    (_opts, _args) = getopt(args[1:], "",
                                            [ "enabled", "enable",
                                              "disabled", "disable", "trust:",
                                              "ssh", "telnet", "smtp",
                                              "http", "ftp", "port:" ])
                    replace_tags = { "enable": "enabled",
                                     "disable": "disabled" }
                    self[opt] = { }
                    for (_opt, _val) in _opts:
                        if replace_tags and replace_tags.has_key(_opt):
                            _opt = replace_tags[_opt]
                        if _opt == "--enabled" or _opt == "--enable":
                            self[opt]["enabled"] = None
                        elif _opt == "--disabled" or _opt == "--disable":
                            self[opt]["disabled"] = None
                        elif _opt == "--trust" and _val:
                            if not self[opt].has_key("trust"):
                               self[opt]["trusted"] = [ ]
                            self[opt]["trusted"].append(_val)
                        elif _opt in [ "--ssh", "--telnet", "--smtp", "--http",
                                       "--ftp" ]:
                            if not self[opt].has_key("ports"):
                                self[opt]["ports"] = [ ]
                            if _opt == "--ftp":
                                self[opt]["ports"].append([21,"tcp"])
                            elif _opt == "--ssh":
                                self[opt]["ports"].append([22,"tcp"])
                            elif _opt == "--telnet":
                                self[opt]["ports"].append([23,"tcp"])
                            elif _opt == "--smtp":
                                self[opt]["ports"].append([25,"tcp"])
                            elif _opt == "--http":
                                self[opt]["ports"].append([80,"tcp"])
                        elif _opt == "--port":
                            _vals = noquote_split(val, ",")
                            for v in _vals:
                                if not self[opt].has_key("ports"):
                                    self[opt]["ports"] = [ ]
                                a = v.split(":")
                                if len(a) != 2:
                                    raise ValueError, \
                                          "ERROR: port '%s' invalid" % v
                                self[opt]["ports"].append(a)
                        else:
                            print "'%s': option '%s' not recognized" % (line,
                                                                        _opt)
                    for arg in _args:
                        if not self[opt].has_key("devices"):
                            self[opt]["devices"] = [ ]
                        self[opt]["devices"].append(arg)
                elif opt == "firstboot":
                    self.parseSimple(opt, args[1:],
                                     [ "enable", "enabled", "disable",
                                       "disabled", "reconfig" ],
                                     { "enable": "enabled",
                                       "disable": "disabled" })
                elif opt == "harddrive":
                    self.parseSimple(opt, args[1:],
                                     [ "partition:", "dir:" ])
                    if not self[opt].has_key("partition") or \
                       not self[opt].has_key("dir"):
                        raise ValueError, "Error in line '%s'" % line
                elif opt == "langsupport":
                    (_dict, _args) = self.parseArgs(opt, args[1:],
                                                    [ "default:" ])
                    self[opt] = _dict
                    if len(args) > 0:
                        self[opt]["supported"] = _args
                    if len(self[opt]) == 0:
                        raise ValueError, "Error in line '%s'" % line
                # TODO: logvol
                elif opt == "network":
                    self.parseSimple(opt, args[1:],
                                     [ "bootproto:", "device:", "ip:",
                                       "gateway:", "nameserver:", "nodns",
                                       "netmask:", "hostname:", "ethtool:",
                                       "essid:", "wepkey:", "onboot:",
                                       "class:" ])
                elif opt == "nfs":
                    self.parseSimple(opt, args[1:],
                                     [ "server:", "dir:" ])
                    if not self[opt].has_key("server") or \
                       not self[opt].has_key("dir"):
                        raise ValueError, "Error in line '%s'" % line
                elif opt == "part" or opt == "partition":
                    self.parseSub("partition", args[1:],
                                  [ "size:", "grow", "maxsize:", "noformat",
                                    "onpart:", "usepart:", "ondisk:",
                                    "ondrive:", "asprimary", "fstype:",
                                    "fsoptions:", "label:", "start:", "end:",
                                    "bytes-per-inode:", "recommended",
                                    "onbiosdisk" ],
                                  { "usepart": "onpart", "ondrive": "ondisk" })
                # TODO: raid
                elif opt == "rootpw":
                    self.parseSub(opt, args[1:], [ "iscrypted" ])
                elif opt == "selinux":
                    self.parseSimple(opt, args[1:],
                                     [ "enforcing", "permissive", "disabled" ])
                elif opt == "timezone":
                    self.parseSub(opt, args[1:], [ "utc" ])
                elif opt == "url":
                    self.parseSimple(opt, args[1:], [ "url:" ])
                    if not self[opt].has_key("url"):
                        raise ValueError, "Error in line '%s'" % line
                elif opt == "xconfig":
                    self.parseSimple("xconfig", args[1:],
                                     [ "noprobe", "card:", "videoram:",
                                       "monitor:", "hsync:", "vsync:",
                                       "defaultdesktop:", "startxonboot",
                                       "resolution:", "depth:" ])
                # TODO: volgroup
                else:
                    print "'%s' is unsupported" % line
            elif in_packages:
                if len(args) == 1:
                    # there was no space as delimiter
                    args = [ line[:1], line[1:] ]
                    opt = line

                if not self["packages"]:
                    self["packages"] = { }
                if opt[0] == "@":
                    if not self["packages"].has_key("groups"):
                        self["packages"]["groups"] = [ ]
                    if not args[1] in self["packages"]["groups"]:
                        self["packages"]["groups"].append(args[1])
                elif opt[0] == "-":
                    if not self["packages"].has_key("drop"):
                        self["packages"]["drop"] = [ ]
                    if not line in self["packages"]["drop"]:
                        self["packages"]["drop"].append(args[1])
                else:
                    if not self["packages"].has_key("add"):
                        self["packages"]["add"] = [ ]
                    if not line in self["packages"]["add"]:
                        self["packages"]["add"].append(opt)
            elif in_post:
                if not self["post"].has_key("script"):
                    self["post"]["script"] = ""
                self["post"]["script"] += line+"\n"
            elif in_pre:
                if not self["pre"].has_key("script"):
                    self["pre"]["script"] = ""
                self["pre"]["script"] += line+"\n"

        self.verify()


    def verify(self):
        for tag in self.REQUIRED_TAGS:
            if not self[tag]:
                raise ValueError, "ERROR: %s is required." % tag

        if not self.has_key("install") and self.has_key("update"):
            raise ValueError, "ERROR: No operation defined"

        if self.has_key("install") and not self.has_key("partition"):
            raise ValueError, \
                  "ERROR: Partition has to be set for an installation."

        if self["authconfig"].has_key("enablenis"):
            if not self["authconfig"].has_key("nisdomain"):
                raise ValueError, "nisdomain not set"
            if not self["authconfig"].has_key("nisserver"):
                raise ValueError, "nisserver not set"
        if self["authconfig"].has_key("enableldap"):
            if not self["authconfig"].has_key("ldapserver"):
                raise ValueError, "ldapserver not set"
            if not self["authconfig"].has_key("ldapbasedn"):
                raise ValueError, "ldapbasedn not set"
        if self["authconfig"].has_key("enablekrb5"):
            if not self["authconfig"].has_key("krb5realm"):
                raise ValueError, "krb5realm not set"
            if not self["authconfig"].has_key("krb5kdc"):
                raise ValueError, "krb5kdc not set"
            if not self["authconfig"].has_key("krb5adminserver"):
                raise ValueError, "krb5adminserver not set"
        if self["authconfig"].has_key("enablehesiod"):
            if not self["authconfig"].has_key("hesiodlhs"):
                raise ValueError, "hesiodlhs not set"
            if not self["authconfig"].has_key("hesiodrhs"):
                raise ValueError, "hesiodrhs not set"
        if self["authconfig"].has_key("enablesmbauth"):
            if not self["authconfig"].has_key("smbservers"):
                raise ValueError, "smbservers not set"
            if not self["authconfig"].has_key("smbworkgroup"):
                raise ValueError, "smbworkgroup not set"

        if self["bootloader"].has_key("password") and \
               self["bootloader"].has_key("md5pass"):
            raise ValueError, "bootloader: password and md5pass set"

        if self["clearpart"]:
            if self["clearpart"].has_key("none") and \
                   len(self["clearpart"]) != 1:
                raise ValueError, "clearpart: none mixed with other tags."

        if self["device"] and self["device"].keys() not in [ "scsi", "eth" ]:
            raise ValueError, "device: type not valid."

        if self["firstboot"] and self["firstboot"].has_key("enabled") and \
               self["firstboot"].has_key("disabled"):
            raise ValueError, "firstboot: enabled and disabled."

        if not self["cdrom"] and not self["harddrive"] and \
               not self["nfs"] and not self["url"]:
            raise ValueError, "No installation method specified."

        if self["harddrive"]:
            if not self["harddrive"].has_key("partition"):
                raise ValueError, "harddrive: partition not set."
            if not self["harddrive"].has_key("dir"):
                raise ValueError, "harddrive: dir not set."

        if self["nfs"]:
            if not self["nfs"].has_key("server"):
                raise ValueError, "nfs: server not set."
            if not self["nfs"].has_key("dir"):
                raise ValueError, "nfs: dir not set."

        partitions = [ ]
        disk = { }
        for name in self["partition"]:
            part = self["partition"][name]
            if part.has_key("fstype") and part["fstype"] != "ext2" and \
                   part["fstype"] != "ext3":
                raise ValueError, \
                      "'%s': Filesystem type '%s' is not supported" % \
                      (name, part["fstype"])
            if part.has_key("onpart"):
                if part["onpart"] in partitions:
                    raise ValueError, "Partition '%s' used multiple times" % \
                          part["onpart"]
                partitions.append(part["onpart"])
            ondisk = "default"
            if part.has_key("ondisk"):
                ondisk = part["ondisk"]
            if not disk.has_key(ondisk):
                disk[ondisk] = { }
            if part.has_key("grow"):
                if disk[ondisk].has_key("grow"):
                    raise ValueError, \
                          "More than one grow partition on '%s'" % \
                          disk[ondisk]
                disk[ondisk]["grow"] = name
        del partitions
        del disk

        if self["url"]:
            if not self["url"].has_key("url"):
                raise ValueError, "url not set."

    def parseArgs(self, tag, argv, allowed_args, replace_tags=None):
        dict = { }
        (opts, args) = getopt(argv, "", allowed_args)

        for (opt, val) in opts:
            if replace_tags and replace_tags.has_key(opt[2:]):
                opt = "--"+replace_tags[opt[2:]]
            if val:
                if opt[-1] == "=":
                    o = opt[2:-1]
                else:
                    o = opt[2:]
                dict[o] = self.stripQuotes(val)
            else:
                dict[opt[2:]] = None

        return (dict, args)

    def parseSimple(self, tag, argv, allowed_args, replace_tags=None):
        if self[tag]:
            raise ValueError, "%s already set." % tag

        (dict, args) = self.parseArgs(tag, argv, allowed_args, replace_tags)

        if len(args) != 0:
            raise ValueError, "'%s %s' is unsupported" % (tag,
                                                          string.join(argv))
        self[tag] = dict

    def parseSub(self, tag, argv, allowed_args, replace_tags=None):
        (dict, args) = self.parseArgs(tag, argv, allowed_args, replace_tags)

        if len(args) != 1:
            raise ValueError, "'%s %s' is unsupported" % (tag,
                                                          string.join(argv))
        if not self[tag]:
            self[tag] = { }
        elif self[tag].has_key(args[0]):
                raise ValueError, "%s already set." % tag

        self[tag][args[0]] = dict

    def stripQuotes(self, var):
        if var and len(var) > 2:
            if (var[0] == '"' and var[-1] == '"') or \
                   (var[0] == "'" and var[-1] == "'"):
                var = var[1:-1]
        return var


class Disk:
    def __init__(self, device_name):
        self.device = device_name
        self.dev = parted.PedDevice.get(self.device)
        self.disk = parted.PedDisk.new(self.dev)
        self.read()

    def read(self):
        self.partitions = 0
        self.partition = { }
        self.extended = { }
        self.free = { }
        partition = None
        partition = self.disk.next_partition()
        while partition:
            if partition.num < 0:
                if partition.type & parted.PARTITION_FREESPACE:
                    self.free[len(self.free)+1] = partition
                partition = self.disk.next_partition(partition)
                continue
            if partition.type & parted.PARTITION_EXTENDED:
                self.extended[partition.num] = partition
                self.partitions += 1
            else:
                self.partition[partition.num] = partition
                self.partitions += 1
            partition = self.disk.next_partition(partition)

    def getType(self):
        return self.disk.type

################################## functions ##################################

# To combine option and value in longopts:
#   "opt=" for --opt=val
#   "opt:" for --opt val or --opt=val
def getopt(args, shortopts, longopts=[ ]):
    _shortopts = { }
    _longopts = { }
    _opts = [ ]
    _args = args[:]

    for i in xrange(len(shortopts)):
        opt = shortopts[i]
        if i < len(shortopts) - 1 and shortopts[i+1] == ":":
            _shortopts[opt] = ":"
            i += 1
        else:
            _shortopts[opt] = None

    for opt in longopts:
        if len(opt) < 1:
            raise ValueError, "Invalid options"
        if opt[-1] == "=" or opt[-1] == ":":
            _longopts[opt[0:-1]] = opt[-1]
        else:
            _longopts[opt] = None

    idx = 0
    while len(_args) > idx:
        arg = _args[idx]

        if arg[0:2] == "--": # longopts
            a = arg[2:]
            if a in _longopts:
                if not _longopts[a]:
                    _opts.append((arg, None))
                    _args.pop(idx)
                    continue
                elif _longopts[a] == ":":
                    if len(args) > 1:
                        _args.pop(idx)
                        val = _args.pop(idx)
                        _opts.append((arg, val))
                        continue
                    else:
                        raise ValueError, "Missing value for '%s'" % arg

            i = arg.find("=")
            if i > 0: # found '='
                a = arg[2:i]
                if a in _longopts and \
                       (_longopts[a] == "=" or _longopts[a] == ":"):
                    _opts.append((arg[:i], arg[i+1:]))
                    _args.pop(idx)
                    continue

            raise ValueError, "Invalid option '%s'" % arg
        elif arg[0] == "-": # shortopts
            a = arg[1:]
            for c in a:
                if c in _shortopts:
                    if not _shortopts[c]:
                        _opts.append(("-"+c, None))
                    elif _shortopts[c] == ":":
                        if len(a) > 1:
                            raise ValueError, "Invalid option '%s'" % arg
                        _args.pop(idx)
                        val = _args.pop(idx)
                        _opts.append((arg, val))
                    else:
                        raise ValueError, "Invalid option '%s'" % arg
                    _args.pop(idx)
                else:
                    raise ValueError, "Invalid option '%s'" % arg

        else: # do not stop on no-opt, continue
            idx += 1

    return (_opts,_args)


def noquote_split(s, delimiter=None):
    delimiters = [ " ", "\t", "\r", "\n", "\f", "\v" ]
    tokens = [ ]
    single_quote = 0
    double_quote = 0
    if delimiter:
        if isinstance(delimiter, types.ListType):
            delimiters = delimiter
        else:
            delimiters = [ delimiter ]
    for i in xrange(len(delimiters)):
        if not isinstance(delimiters[i], types.StringType):
            raise ValueError, "delimiter is not of type string"
        if len(delimiters[i]) == 0:
            delimiters.pop(i)

    b = 0;
    for i in xrange(len(s)):
#        print "s[%d]='%s' %x %d %d" % (i, s[i], ord(s[i]), single_quote, double_quote)
        if s[i] == "'":
            if single_quote == 0 or double_quote > 0:
                single_quote += 1
            else:
                single_quote -= 1
        if s[i] =="\"":
            if double_quote == 0 or single_quote > 0:
                double_quote += 1
            else:
                double_quote -= 1
        if single_quote == 0 and double_quote == 0:
            for delim in delimiters:
                l = len(delim)
                if s[i:i+l] == delim:
#                    print "found delim='%s'" % delim
                    if i > 0 and len(s[b:i]) > 0:
                        tokens.append(s[b:i])
                    b = i + l
                    break
    if len(s[b:]) > 0:
        tokens.append(s[b:])

    return tokens


def rm_rf(name):
    if not os.path.exists(name) or not os.path.isdir(name):
        return
    if os.path.ismount(name):
        umount(name)
        return
    list = os.listdir(name)
    for file in list:
        if os.path.isdir(name+"/"+file) and not os.path.islink(name+"/"+file):
            rm_rf(name+"/"+file)
        else:
            os.unlink(name+"/"+file)
    os.rmdir(name)


def mount(what, where, fstype="ext3", options=None):
    print "Mounting '%s' on '%s'" % (what, where)

    opts = ""
    if options:
        opts = "-o '%s'" % options
    stat = os.system("mount %s -t '%s' '%s' '%s'" % \
                     (opts, fstype, what , where))
    if stat != 0:
        raise IOError, "mount of '%s' on '%s' failed" % (what , where)


def umount(what):
    if not os.path.ismount(what):
        return
    print "Umounting '%s'" % what

    i = 0
    failed = 0
    while os.path.ismount(what) and i < 100:
        if i == 1:
            # kill all processes running in dir
            print "Killing all processes running in  '%s'" % what
        if i > 0:
            pid = os.fork()
            if pid != 0:
                (rpid, status) = os.waitpid(pid, 0)
                if status != 0:
                    sys.exit(1)
            else:
                try:
                    pyrpm.runScript(script="/sbin/fuser -k '%s'" % what)
                finally:
                    os._exit(0) # FIXME: really ignore errors?

            print "Trying to umount '%s'" % source_dir
            time.sleep(0.5)
        stat = os.system("umount '%s'" % what)
        if stat != 0:
            failed = 1
        else:
            failed = 0
        i += 1
    if failed == 1:
        print "ERROR: Umount of '%s' failed" % what

    return failed

def umount_all(dir):
    # umount target dir and included mount points
    mounted = [ ]
    fd = open("/proc/mounts", "r")
    while 1:
        line = fd.readline()
        if not line:
            break
        args = string.split(line)
        i = args[1].find(dir)
        if i == 0:
            mounted.append(args[1])
    fd.close()
    # sort reverse
    mounted.sort()
    mounted.reverse()

    failed = 0
    for dir in mounted:
        if umount(dir) == 1:
            failed = 1

    return failed

def check_dir(buildroot, dir):
    if not os.path.exists(buildroot+dir):
        print "ERROR: Directory '%s' does not exist." % dir
        return 0
    return 1

def create_dir(buildroot, dir):
    d = buildroot+dir
    if not os.path.exists(d):
        os.mkdir(d)

def losetup(target, offset=0):
    i = 0
    loop_device = None
    offset_string = ""
    if offset:
        offset_string = "-o%d" % offset
    while not loop_device and i < 100:
        (child_stdin, child_stdout) = os.popen2("/sbin/losetup -f 2>/dev/null")
        loop_device = child_stdout.read()
        loop_device = string.strip(loop_device)
        i += 1
        status = os.system("/sbin/losetup %s '%s' '%s'" % (offset_string,
                                                           loop_device,
                                                           target))
        if status != 0:
            loop_device = None
    if not loop_device:
        print "Unable to get loop device, exiting."
        return None
    return loop_device

def lofree(device):
    return (os.system("/sbin/losetup -d '%s'" % device) == 0)

def diskName(name):
    if len(name) < 2:
        raise ValueError, "'%s' is no partition name" % name
    tmp = name[:]
    while len(tmp) > 0 and tmp[-1] >= '0' and tmp[-1] <= '9':
        tmp = tmp[:-1]
    return tmp

def partitionId(name):
    if len(name) < 2:
        raise ValueError, "'%s' is no partition name" % name
    out = ""
    tmp = name[:]
    while len(tmp) > 0 and tmp[-1] >= '0' and tmp[-1] <= '9':
        out = tmp[-1] + out
        tmp = tmp[:-1]
    return out

def swapon(device):
    swapon = "/sbin/swapon '%s'" % device
    print "Enable swap on '%s'" % device
    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: swapon failed."
            return 1
    else:
        try:
            pyrpm.runScript(script=swapon)
        except (IOError, OSError):
            os._exit(1)
        os._exit(0)
    return 0

def swapoff(device):
    swapoff = "/sbin/swapoff '%s'" % device
    print "Disable swap on '%s'" % device
    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: swapoff failed."
            return 1
    else:
        try:
            pyrpm.runScript(script=swapoff)
        except (IOError, OSError):
            os._exit(1)
        os._exit(0)
    return 0

def exit(code):
    if tempdir:
        if umount_all(tempdir+"/") == 0:
            if not nocleanup:
                rm_rf(tempdir)
    for part in partitionmap:
        if partitionmap[part]["name"] == "swap" and \
               partitionmap[part].has_key("on"):
            swapoff(partitionmap[part]["device"])
            del partitionmap[part]["on"]
        if partitionmap[part].has_key("disk") and \
               partitionmap[part].has_key("device"):
            disk = partitionmap[part]["disk"]
            if diskmap[disk].has_key("image"):
                lofree(partitionmap[part]["device"])
                del partitionmap[part]["device"]
    for disk in diskmap:
        if diskmap[disk].has_key("image") and \
               diskmap[disk].has_key("device"):
            lofree(diskmap[disk]["device"])
            del diskmap[disk]["device"]
    sys.exit(code)

#################################### main ####################################

verbose = 0
buildroot = ""
xen = 0
nocleanup = 0
confirm = 1
tempdir = None
diskmap = None
partitionmap = None

def usage():
    print """
Usage: pyrpmkickstart <options> <kickstartfile>
                      [<disk name:disk image> | <device name:device>]*

OPTIONS
  -h  | --help       Print help.
  -v  | --verbose    Be verbose, and more, ..
  -y                 So not ask questions, assume yes.

  -x  | --xen        Write a simple xen config file.
  -n  | --nocleanup  Do not cleanup temporary files.
"""


if os.geteuid() != 0:
    print "ERROR: You have to be root to perform an installation."
    exit(1)

try:
    (opts, args) = getopt(sys.argv[1:], "hvyxn", [ "help", "verbose", "xen",
                                                   "nocleanup" ])
except:
    usage()
    exit(1)

for (opt, val) in opts:
    if opt in ["-h", "--help"]:
        usage()
        exit(1)
    elif opt in ["-v", "--verbose"]:
        verbose += 1
        pyrpm.rpmconfig.verbose += 1
    elif opt == "-y":
        confirm = 0
    elif opt in ["-x", "--xen"]:
        xen = 1
    elif opt in ["-n", "--nocleanup"]:
        nocleanup = 1
    else:
        print "Unknown option '%s'" % opt
        usage()
        exit(1)

if len(args) < 1:
    usage()
    exit(1)

# kickstart file
ks_file = args[0]
if not os.path.exists(ks_file):
    print "ERROR: '%s' does not exist." % ks_file
    exit(1)

### create user supplied diskmap ###

diskmap = { }
if len(args) > 1:
    for arg in args[1:]:
        splits = string.split(arg, ":")
        if len(splits) != 2:
            usage()
            exit(1)
        key = string.strip(splits[0])
        val = string.strip(splits[1])
        if not os.path.exists(val):
            print "ERROR: '%s' does not exist." % val
            exit(1)
        diskmap[key] = { }
        mode = os.stat(val).st_mode
        if stat.S_ISREG(mode):
            diskmap[key]["image"] = val
        elif stat.S_ISBLK(mode):
            diskmap[key]["device"] = val
        else:
            print "ERROR: Unsupported type of '%s'." % val
            exit(1)

### load kickstart file ###

ks = KickstartConfig(ks_file)

# TODO: start network in standalone mode for pre script

# run pre script
if ks["pre"] and len(ks["pre"]["script"]) > 0:
    print "Running pre script"
    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0 and ks["pre"].has_key("erroronfail"):
            print "ERROR: Pre script failed, aborting."
            exit(1)
    else:
        interpreter = "bin/sh"
        if ks["pre"].has_key("interpreter"):
            interpreter = ks["pre"]["interpreter"]
        try:
            pyrpm.runScript(interpreter, ks["pre"]["script"])
        except (IOError, OSError):
            os._exit(1)
        os._exit(0)

# parse file again
ks.clear()
ks.parse(ks_file)

# sanity checks
if ks.has_key("install"):
    if not ks["partition"].has_key("/"):
        print "ERROR: root partition not defined"
        exit(1)
else:
    print "ERROR: Only installation is supported, aborting."
    exit(1)

if not ks["nfs"]:
    print "ERROR: Only nfs install is supported, exiting."
    exit(1)

### create system diskmap ###

if len(diskmap) == 0:
    print "WARNING: No device maps defined, using system harddisks!"
    if confirm:
        choice = raw_input("Is this ok [y/N]: ")
        if len(choice) == 0 or choice[0] != "y" and choice[0] != "Y":
            exit(1)
    fd = open("/proc/partitions") # get all disks
    while 1:
        line = fd.readline()
        if not line:
            break
        if line[:5] == "major":
            continue
        line = string.strip(line)
        if len(line) < 1:
            continue
        if line[0] == '#':
            continue
        splits = line.split() # major, minor, blocks, name
        if len(splits) < 4:
            print "ERROR: '/proc/partitions' malformed."
            exit(1)
        if int(splits[1], 16) % 16 == 0: # minor%16=0 for harddisk devices
            diskmap[splits[3]] = { }
            diskmap[splits[3]]["device"] = "/dev/"+splits[3]
    fd.close()

    if len(diskmap) == 0:
        print "ERROR: No harddisks found."
        exit(1)

### disk / partition selection ###

# create partitionmap
partitionmap = { }
for name in ks["partition"]:
    part = ks["partition"][name]

    if part.has_key("onpart"):
        onpart = part["onpart"]
        if onpart[:5] != "/dev/":
            print "ERROR: '%s' is not a valid partition name." % onpart
            exit(1)
        onpart = part["onpart"][5:]
        if onpart in partitionmap:
            print "ERROR: '%s' is used more than once." % part["onpart"]
            exit(1)
        partitionmap[onpart] = { }
        partitionmap[onpart]["name"] = name
        partitionmap[onpart]["disk"] = diskName(onpart)
        partitionmap[onpart]["id"] = partitionId(onpart)
    else:
        print "ERROR: no partition gived for '%s'" % name
        exit(1)

needed = [ ]
# check partitionmap with diskmap
for part in partitionmap:
    disk_name = partitionmap[part]["disk"]
    if not diskmap.has_key(disk_name):
        print "ERROR: disk '%s' is not defined." % disk_name
        exit(1)
    if disk_name not in needed:
        needed.append(disk_name)

# remove unneeded disks
for disk in diskmap:
    if not disk in needed:
        print "INFO: Dropping unneded disk '%s'" % disk
        del diskmap[disk]
del needed

# get loop devices for disks, get parted structure
for disk in diskmap:
    if diskmap[disk].has_key("image"):
        # losetup
        device = losetup(diskmap[disk]["image"])
        if not device:
            print "Unable to get loop device, exiting."
            exit(1)
        diskmap[disk]["device"] = device
        diskmap[disk]["disk"] = Disk(device)
        d = diskmap[disk]["disk"]

        if verbose:
            for i in d.partition:
                if d.partition[i].type == parted.PARTITION_PRIMARY:
                    type = "primary"
                elif d.partition[i].type & parted.PARTITION_LOGICAL:
                    type = "logical"

                print "%s %d:" % (type, i)

                print "\t%d-%d size=%d bs=%d" % \
                      (d.partition[i].geom.start, d.partition[i].geom.end,
                       d.partition[i].geom.length,
                       d.partition[i].geom.dev.sector_size)
                if d.partition[i].fs_type and d.partition[i].fs_type.name:
                    print "\t%s" % d.partition[i].fs_type.name
    else:
        diskmap[disk]["device"] = "/dev/" + disk

# are all needed partitions there?
error = 0
for part in partitionmap:
    disk = partitionmap[part]["disk"]
    id = int(partitionmap[part]["id"])
    d = diskmap[disk]["disk"]
    if not id in d.partition:
        print "ERROR: partition '%s' does not exist." % part
        error = 1
    if error:
        continue
    if diskmap[disk].has_key("image"):
        partitionmap[part]["blocksize"] = d.partition[id].geom.dev.sector_size
        partitionmap[part]["start"] = d.partition[id].geom.start * \
                                      partitionmap[part]["blocksize"]
        partitionmap[part]["end"] = d.partition[id].geom.end * \
                                    partitionmap[part]["blocksize"]
        partitionmap[part]["length"] = d.partition[id].geom.length
        partitionmap[part]["size"] = d.partition[id].geom.length * \
                                     partitionmap[part]["blocksize"]
        device = losetup(diskmap[disk]["image"], partitionmap[part]["start"])
        partitionmap[part]["device"] = device
if error:
    exit(1)

if verbose:
    print "diskmap=%s" % diskmap
    print "partitionmap=%s" % partitionmap

### format partitions ###

# prepare to format partitions
to_format = [ ]
for part in partitionmap:
    name = partitionmap[part]["name"]
    if not ks["partition"][name].has_key("noformat"):
        to_format.append(part)
to_format.sort()
to_format.reverse()

if confirm == 1 and len(to_format) > 0:
    print "About to format these partitions:"
    for part in to_format:
        name = partitionmap[part]["name"]
        if diskmap[partitionmap[part]["disk"]].has_key("image"):
            disk = "%s:%s" % (partitionmap[part]["disk"],
                              diskmap[partitionmap[part]["disk"]]["image"])
        else:
            disk = partitionmap[part]["disk"]
        print "\t'%s' [%s] on '%s'" % (part, name, disk)
    choice = raw_input("Is this ok [y/N]: ")
    if len(choice) == 0 or choice[0] != "y" and choice[0] != "Y":
        exit(1)

# format
for part in to_format:
    name = partitionmap[part]["name"]
    disk = partitionmap[part]["disk"]
    partition = ks["partition"][name]

    if partition.has_key("fstype") and \
           (partition["fstype"] == "ext2" or partition["fstype"] == "ext3"):
        mke2fs = "/sbin/mke2fs -q -L '%s'" % name
        if partition["fstype"] == "ext3":
            mke2fs += " -j"
        if diskmap[disk].has_key("image"):
            mke2fs += " -F"
            blocksize = 4096
            mke2fs += " -b %d" % blocksize
        mke2fs += " %s" % partitionmap[part]["device"]
        if diskmap[disk].has_key("image"):
            mke2fs += " %d" % (partitionmap[part]["size"] / blocksize)

        print "Formatting '%s' on '%s' (%s)" % \
              (part, partitionmap[part]["disk"], name)

        pid = os.fork()
        if pid != 0:
            (rpid, status) = os.waitpid(pid, 0)
            if status != 0:
                print "ERROR: mke2fs failed."
                exit(1)
        else:
            try:
                pyrpm.runScript(script=mke2fs)
            except (IOError, OSError):
                os._exit(1)
            os._exit(0)

    elif name == "swap":
        mkswap = "/sbin/mkswap -L 'swap-%s' '%s' %d >/dev/null" % \
                 (part, partitionmap[part]["device"],
                  (partitionmap[part]["size"] / 1024))

        print mkswap
        print "Formatting swap on '%s' (%s)" % (partitionmap[part]["disk"],
                                                name)
        pid = os.fork()
        if pid != 0:
            (rpid, status) = os.waitpid(pid, 0)
            if status != 0:
                print "ERROR: mkswap failed."
                exit(1)
        else:
            try:
                pyrpm.runScript(script=mkswap)
            except (IOError, OSError):
                os._exit(1)
            os._exit(0)
    else:
        print "ERROR: Unknown filesystem for '%s' (%s)" % \
              (partitionmap[part]["disk"], name)
        exit(1)

del to_format

### create temp dir ###

try:
    tempdir = tempfile.mkdtemp(prefix="pyrpmkickstart_")
except Exception, msg:
    print msg
    exit(1)
source_dir = tempdir+"/source"
target_dir = tempdir+"/target"

### mount target ###

os.mkdir(target_dir)

# prepare to format partitions
to_mount = [ ]
mountmap = { }
for part in partitionmap:
    name = partitionmap[part]["name"]
    to_mount.append(name)
    mountmap[name] = part
to_mount.sort()

for mntpnt in to_mount:
    if mntpnt == "swap":
        if swapon(partitionmap[mountmap[mntpnt]]["device"]) == 1:
            exit(1)
        partitionmap[mountmap[mntpnt]]["on"] = None
    else:
        if mntpnt == "/":
            dir = target_dir
        else:
            dir = target_dir+mntpnt
            if not os.path.exists(dir):
                try:
                    os.mkdir(dir)
                except Exception, msg:
                    print "ERROR: Could not create '%s': %s" % (dir, msg)
                    exit(1)

        print "Mounting '%s':" % mntpnt
        try:
            mount(partitionmap[mountmap[mntpnt]]["device"], dir,
                  fstype=ks["partition"][mntpnt]["fstype"])
        except Exception, msg:
            print msg
            exit(1)

buildroot = target_dir
pyrpm.rpmconfig.buildroot = buildroot

### mount source ###

# create source mount point and mount source (nfs)
os.mkdir(source_dir)
source = "%s:%s" % (ks["nfs"]["server"], ks["nfs"]["dir"])
try:
    mount(source, source_dir, fstype="nfs")
except Exception, msg:
    print msg
    exit(1)

### package selection ###

# set default group "base" if no groups are specified
if not ks["packages"]:
    ks["packages"] = { }
if not ks["packages"].has_key("groups"):
    ks["packages"]["groups"] = [ ]

if len(ks["packages"]["groups"]) == 0:
    ks["packages"]["groups"].append("base")

# load comps file for groups and default packages
comps = pyrpm.RpmCompsXML(pyrpm.rpmconfig,
                          "%s/repodata/comps.xml" % source_dir)
comps.read() # Ignore errors
pkgs = [ ]
for group in ks["packages"]["groups"]:
    pkgs.extend(comps.getPackageNames(group))

if ks["langsupport"]:
    languages = [ ]
    if ks["langsupport"].has_key("default"):
        languages.append(ks["langsupport"]["default"][:2])
    for lang in ks["langsupport"]["supported"]:
        languages.append(lang[:2])
    print "languages=%s" % languages

    for group in comps.grouphash.keys():
        if comps.grouphash[group].has_key("langonly") and \
               comps.grouphash[group]["langonly"] in languages:
            optional_list = comps.getOptionalPackageNames(group)
            for (name, requires) in optional_list:
                for req in requires:
                    if req in pkgs:
                        print "Adding '%s' for langsupport" % name
                        pkgs.append(name)
                        break

# everything install
if "everything" in ks["packages"]["groups"]:
    for group in comps.grouphash.values():
        if group.has_key("packagelist"):
            pkgs.extend(group["packagelist"])

del comps

# add and remove packages from default list
if ks["packages"].has_key("drop"):
    for pkg in ks["packages"]["drop"]:
        if pkg in pkgs:
            pkgs.remove(pkg)
if ks["packages"].has_key("add"):
    for pkg in ks["packages"]["add"]:
        if not pkg in pkgs:
            pkgs.append(pkg)

# add comps package (FC-4)
if not "comps" in pkgs:
    pkgs.append("comps")

# append authconfig, if we want to configure it
if ks["authconfig"] and not "authconfig" in pkgs:
    print "Adding package authconfig"
    pkgs.append("authconfig")

# append iptables, if we want to configure it
if ks["firewall"] and not ks["firewall"].has_key("disabled") and \
       not "iptables" in pkgs:
    print "Adding package iptables"
    pkgs.append("iptables")
    pkgs.append("system-config-securitylevel-tui")

if ks["selinux"]:
    pkgs.append("system-config-securitylevel-tui")

# append xorg-x11, if we want to configure it
if ks["xconfig"] and not "xorg-x11" in pkgs:
    print "Adding package xorg-x11"
    pkgs.append("xorg-x11")

pyrpm.normalizeList(pkgs)

# no packages?
if len(pkgs) < 1:
    print "Nothing to do."
    exit(1)

# create essential directories and files
os.umask(000)

create_dir(buildroot, "/dev")
create_dir(buildroot, "/etc")
create_dir(buildroot, "/etc/rpm")
create_dir(buildroot, "/var")
create_dir(buildroot, "/var/log")

# /dev
if not os.path.exists(buildroot+"/dev/console"):
    os.mknod(buildroot+"/dev/console", 0666 | stat.S_IFCHR, os.makedev(5, 1))
if not os.path.exists(buildroot+"/dev/null"):
    os.mknod(buildroot+"/dev/null", 0666 | stat.S_IFCHR, os.makedev(1, 3))
if not os.path.exists(buildroot+"/dev/zero"):
    os.mknod(buildroot+"/dev/zero", 0666 | stat.S_IFCHR, os.makedev(1, 5))

# /etc/fstab
if not os.path.exists(buildroot+"/etc/fstab"):
    fd = open(buildroot+"/etc/fstab", "w")
    for part in partitionmap:
        name = partitionmap[part]["name"]

        if ks["partition"][name].has_key("fstype"):
            fs = ks["partition"][name]["fstype"]
        elif name == "swap":
            fs = name
        else:
            print "ERROR: Unknown filesystem for '%s' (%s)" % \
                  (partitionmap[part]["disk"], name)
            continue
        fd.write("/dev/%s\t\t%s\t\t%s\tdefaults\t1 1\n" % (part, name, fs))
    fd.write("/dev/devpts\t\t/dev/pts\t\tdevpts\tgid=5,mode=620\t0 0\n")
    fd.write("/dev/shm\t\t/dev/shm\t\ttmpfs\tdefaults\t0 0\n")
    fd.write("/dev/proc\t\t/proc\t\tproc\tdefaults\t0 0\n")
    fd.write("/dev/sys\t\t/sys\t\tsysfs\tdefaults\t0 0\n")
    fd.close()

# /etc/hosts
if not os.path.exists(buildroot+"/etc/hosts"):
    fd = open(buildroot+"/etc/hosts", "w")
    fd.write("# Do not remove the following line, or various programs\n")
    fd.write("# that require network functionality will fail.\n")
    fd.write("127.0.0.1\t\tlocalhost.localdomain\tlocalhost\n")
    fd.close()

# /etc/modprobe.conf
if not os.path.exists(buildroot+"/etc/modprobe.conf"):
    fd = open(buildroot+"/etc/modprobe.conf", "w")
    fd.close()

# /etc/rpm/platform
(sysname, nodename, release, version, machine) = os.uname()
if not os.path.exists(buildroot+"/etc/rpm/platform"):
    fd = open(buildroot+"/etc/rpm/platform", "w")
    fd.write("%s-redhat-linux" % machine)
    fd.close()

# /var/log/lastlog
if not os.path.exists(buildroot+"/var/log/lastlog"):
    fd = open(buildroot+"/var/log/lastlog", "w")
    fd.close()

# /var/log/messages
if not os.path.exists(buildroot+"/var/log/messages"):
    fd = open(buildroot+"/var/log/messages", "w")
    fd.close()

### installation ###

print "Preparing installation"

# configure yum
os.mkdir("%s/yum.cache" % tempdir)
os.mkdir("%s/yum.repos.d" % tempdir)
yum_conf = tempdir+"/yum.conf"
fd = open(yum_conf, "w")
fd.write("[main]\n")
fd.write("cachedir=%s/yum.cache\n" % tempdir)
fd.write("debuglevel=0\n")
fd.write("errorlevel=0\n")
fd.write("pkgpolicy=newest\n")
fd.write("distroverpkg=redhat-release\n")
fd.write("tolerant=1\n")
fd.write("exactarch=1\n")
fd.write("retries=20\n")
fd.write("obsoletes=1\n")
fd.write("reposdir=%s/yum.repos.d\n" % tempdir)
fd.write("\n")
fd.write("[dist]\n")
fd.write("name=dist\n")
fd.write("baseurl=file:%s/source\n" % tempdir)
fd.close()

# yum
yum = "PYTHONPATH=%s %s/scripts/pyrpmyum --servicehack -y -c '%s' -r '%s'" % \
      (PYRPMDIR, PYRPMDIR, yum_conf, buildroot)
if ks["packages"].has_key("ignoredeps") and \
       ks["packages"].has_key("ignoremissing"):
    yum += " --nodeps"
if ks.has_key("install"):
    yum += " install "
elif ks.has_key("update"):
#    if ks["packages"].has_key("resolvedeps"):
#        yum += " --autoerase "
    yum += " update "
yum += string.join(pkgs)
#print yum
pid = os.fork()
if pid != 0:
    (rpid, status) = os.waitpid(pid, 0)
    if status != 0:
        print "ERROR: Installation failed, aborting."
        exit(1)
else:
    os.system(yum)
    os._exit(0)

### configuration ###

# check system dirs
if not check_dir(buildroot, "/etc") or \
       not check_dir(buildroot, "/etc/sysconfig"):
    print "Aborting."
    exit(1)

# run kudzu
print "Running kudzu"
pid = os.fork()
if pid != 0:
    (rpid, status) = os.waitpid(pid, 0)
    if status != 0:
        print "ERROR: kudzu failed."
else:
    os.chroot(buildroot)
    try:
        pyrpm.runScript(script="/usr/sbin/kudzu -s")
    except (IOError, OSError):
        os._exit(1)
    os._exit(0)

# run authconfig if set
if ks["authconfig"]:
    print "Configuring authentication"

    # Create /etc/samba for authconfig
    if not os.path.exists(buildroot+"/etc/samba"):
        os.mkdir(buildroot+"/etc/samba")

    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: authconfig failed"
    else:
        os.chroot(buildroot)
        authconfig = "/usr/bin/authconfig --nostart --kickstart"
        for tag in ks["authconfig"]:
            if ks["authconfig"][tag]:
                authconfig += " --%s=%s" % (tag, ks["authconfig"][tag])
            else:
                authconfig += " --%s" % tag
        try:
            pyrpm.runScript(script=authconfig)
        except (IOError, OSError):
            os._exit(1)
        os._exit(0)

# setting root password
if ks["rootpw"]:
    print "Setting root password"

    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: Setting root password failed"
    else:
        os.chroot(buildroot)
        password = ks["rootpw"].keys()[0]
        if not ks["rootpw"][password].has_key("iscrypted"):
            salt = ""
            salt_len = 2
            if ks["authconfig"].has_key("enablemd5"):
                salt = "$1$"
                salt_len = 8
            for i in range(salt_len):
                salt += random.choice(string.letters+string.digits+"./")
            password = crypt.crypt(password, salt)
        try:
            pyrpm.runScript(script="/usr/sbin/usermod -p '%s' root" % password)
        except (IOError, OSError):
            os._exit(1)
        os._exit(0)

# /etc/inittab
if ks["xconfig"] and ks["xconfig"].has_key("startxonboot"):
    print "Configuring runlevel"

    try:
        fd_in = open(buildroot+"/etc/inittab", "r")
        fd_out = open(buildroot+"/etc/inittab.pyrpmkickstart", "w")
        while 1:
            line = fd_in.readline()
            if not line:
                break
            if len(line) > 3 and line[:3] == "id:":
                id = string.split(line, ":")
                if len(id) > 1:
                    id[1] = "5"
                    line = string.join(id, ":")
                else:
                    print "ERROR: Malformed '/etc/inittab'"
            fd_out.write(line)
        fd_in.close()
        fd_out.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/inittab' failed:", msg
    else:
        os.unlink(buildroot+"/etc/inittab")
        os.rename(buildroot+"/etc/inittab.pyrpmkickstart",
                  buildroot+"/etc/inittab")

# /etc/sysconfig/selinux
if ks["selinux"]:
    print "Configuring selinux"

    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: Setting root password failed"
    else:
        os.chroot(buildroot)
        lokkit = "/usr/sbin/lokkit --quiet --nostart --selinux='%s'" % \
                 ks["selinux"].keys()[0]
        try:
            pyrpm.runScript(script=lokkit)
        except (IOError, OSError):
            os._exit(1)
        os._exit(0)


# /etc/sysconfig/clock
if ks["timezone"]:
    print "Configuring timezone"
    zone = ks["timezone"].keys()[0]
    try:
        fd = open(buildroot+"/etc/sysconfig/clock", "w")
        fd.write('ZONE="%s"\n' % zone)
        if ks["timezone"][zone].has_key("utc"):
            fd.write('UTC=true\n')
        else:
            fd.write('UTC=false\n')
        fd.write('ARC=false\n')
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/clock' failed:", msg

    # Create /etc/localtime
    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: Could not create /etc/localtime."
    else:
        os.chroot(buildroot)
        tzfile = "/usr/share/zoneinfo/" + zone
        try:
            pyrpm.runScript(script="rm -f /etc/localtime; ln '%s' /etc/localtime 2>/dev/null || cp '%s' /etc/localtime" % (tzfile, tzfile))
        except (IOError, OSError):
            os._exit(1)
        os._exit(0)

# /etc/sysconfig/desktop
print "Configuring desktop"
try:
    fd = open(buildroot+"/etc/sysconfig/desktop", "w")
    desktop = "GNOME"
    if ks["xconfig"] and ks["xconfig"].has_key("defaultdesktop"):
        desktop = ks["xconfig"]["defaultdesktop"]
    fd.write('DESKTOP="%s"\n' % desktop)
    fd.close()
except Exception, msg:
    print "ERROR: Configuration of '/etc/sysconfig/desktop' failed:", msg

# /etc/sysconfig/i18n
if ks["langsupport"]:
    print "Configuring languages"
    try:
        fd = open(buildroot+"/etc/sysconfig/i18n", "w")
        if ks["langsupport"].has_key("default"):
            fd.write('LANG="%s"\n' % ks["langsupport"]["default"])
            if ks["langsupport"].has_key("supported") and \
                   len(ks["langsupport"]["supported"]) > 0:
                fd.write('SUPPORTED="%s"\n' % \
                         string.join(ks["langsupport"]["supported"], ":"))
        else:
            fd.write('LANG="%s"\n' % \
                     string.join(ks["langsupport"]["supported"], ":"))
        fd.write('SYSFONT="latarcyrheb-sun16"\n')
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/i18n' failed:", msg

# /etc/sysconfig/installinfo
print "Configuring installinfo"
try:
    fd = open(buildroot+"/etc/sysconfig/installinfo", "w")
    fd.write('INSTALLMETHOD=nfs\n')
    fd.close()
except Exception, msg:
    print "ERROR: Configuration of '/etc/sysconfig/installinfo' failed:", msg

# /etc/sysconfig/iptables
if ks["firewall"] and not ks["firewall"].has_key("disabled"):
    print "Configuring firewall"

    args = [ ]
    if ks["firewall"].has_key("enabled"):
        args.append("--enabled")
    if ks["firewall"].has_key("disabled"):
        args.append("--disabled")
    if ks["firewall"].has_key("trusted"):
        for trusted in ks["firewall"]["trusted"]:
            args.append("--trusted=%s\n" % trusted)
    if ks["firewall"].has_key("ports"):
        for port in ks["firewall"]["ports"]:
            args.append("--port=%s:%s\n" % (port[0], port[1]))

    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0:
            print "ERROR: Configuration of firewall failed"
    else:
        os.chroot(buildroot)
        lokkit = "/usr/sbin/lokkit --quiet --nostart -f %s" % string.join(args)
        try:
            pyrpm.runScript(script=lokkit)
        except (IOError, OSError):
            os._exit(1)
        os._exit(0)

    try:
        fd = open(buildroot+"/etc/sysconfig/system-config-securitylevel", "w")
        fd.write('# Configuration file for system-config-securitylevel\n')
        fd.write('\n')
        for arg in args:
            fd.write('%s\n' % arg)
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/system-config-securitylevel' failed:", msg

# /etc/sysconfig/kernel
print "Configuring kernel"
try:
    fd = open(buildroot+"/etc/sysconfig/kernel", "w")
    fd.write('# UPDATEDEFAULT specifies if new-kernel-pkg should make\n')
    fd.write('# new kernels the default\n')
    fd.write('UPDATEDEFAULT=yes\n')
    fd.write('\n')
    fd.write('# DEFAULTKERNEL specifies the default kernel package type\n')
    fd.write('DEFAULTKERNEL=kernel\n')
    fd.close()
except Exception, msg:
    print "ERROR: Configuration of '/etc/sysconfig/kernel' failed:", msg

# /etc/sysconfig/keyboard
if ks["keyboard"]:
    print "Configuring keyboard"
    try:
        fd = open(buildroot+"/etc/sysconfig/keyboard", "w")
        fd.write('KEYBOARDTYPE="pc"\n')
        fd.write('KEYTABLE="%s"\n' % ks["keyboard"])
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/keyboard' failed: ", msg

# /etc/sysconfig/mouse
print "Configuring generic IMPS/2 mouse"
pid = os.fork()
if pid != 0:
    (rpid, status) = os.waitpid(pid, 0)
    if status != 0:
        print "ERROR: mouseconfig failed"
else:
    os.chroot(buildroot)
    try:
        pyrpm.runScript(script="/usr/sbin/mouseconfig --noui genericwheelps/2")
    except (IOError, OSError):
        os._exit(1)
    os._exit(0)

# setup networking
if ks["network"]:
    print "Configuring network"
    try:
        fd = open(buildroot+"/etc/sysconfig/network", "w")
        fd.write("NETWORKING=yes\nHOSTNAME=localhost.localdomain\n")
        fd.close()
        if not os.path.exists(buildroot+"/etc/sysconfig/network-scripts"):
            os.mkdir(buildroot+"/etc/sysconfig/network-scripts")
        if ks["network"].has_key("device") and \
               ks["network"].has_key("bootproto"):
            fd = open(buildroot+"/etc/sysconfig/network-scripts/ifcfg-%s" % \
                      ks["network"]["device"], "w")
            fd.write("DEVICE=%s\n" % ks["network"]["device"])
            fd.write("BOOTPROTO=%s\n" % ks["network"]["bootproto"])
            fd.write("ONBOOT=yes\n")
            fd.write("TYPE=Ethernet\n")
            fd.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/sysconfig/network' failed:", msg

# /etc/X11/xorg.conf
if ks["xconfig"]:
    print "Configuring xorg.conf"

    # default: VGA graphics card, Generic extended super VGA monitor
    card = "Unknown video card"
    card_driver = "vga"
    videoram = 0
    monitor = "Unknown monitor"
    hsync = "31.5 - 37.9"
    vsync = "50 - 61"
    resolution = "800x600"
    depth = 16
    user_hsync = user_vsync = None

    if ks["xconfig"].has_key("card"):
        fd = open ('/usr/share/hwdata/Cards')
        found = 0
        while 1:
            line = fd.readline()
            if not line:
                break
            line = string.strip(line)
            if len(line) < 1 or line[0] == "#":
                continue
            if not found:
                if line[:4] != "NAME":
                    continue
                name = string.strip(line[4:])
                if name == ks["xconfig"]["card"]:
                    found = 1
            elif string.strip(line[:6]) == "DRIVER":
                card = ks["xconfig"]["card"]
                card_driver = string.strip(line[6:])
                found = 2
                break
        fd.close()
        if found != 2:
            print "ERROR: Card not found in hardware database."
    if ks["xconfig"].has_key("videoram"):
        videoram = ks["xconfig"]["videoram"]
    if ks["xconfig"].has_key("monitor"):
        fd = open ('/usr/share/hwdata/MonitorsDB')
        found = 0
        while 1:
            line = fd.readline()
            if not line:
                break
            line = string.strip(line)
            if len(line) < 1 or line[0] == "#":
                continue
            args = string.split(line, ";")
            if len(args) < 5:
                continue
            if string.strip(args[1]) == ks["xconfig"]["monitor"]:
                monitor = ks["xconfig"]["monitor"]
                hsync = string.strip(args[3])
                vsync = string.strip(args[4])
                found = 1
                break
        fd.close()
        if found != 1:
            print "ERROR: Monitor not found in hardware database."
    if ks["xconfig"].has_key("hsync"): # overwrite with user supplied value
        hsync = ks["xconfig"]["hsync"]
    if ks["xconfig"].has_key("vsync"):
        vsync = ks["xconfig"]["vsync"] # overwrite with user supplied value
    if ks["xconfig"].has_key("resolution"):
        resolution = ks["xconfig"]["resolution"]
    if ks["xconfig"].has_key("depth"):
        depth = ks["xconfig"]["depth"]

    try:
        fd = open(buildroot+"/etc/X11/xorg.conf", "w")
        fd.write('Section "ServerLayout"\n')
        fd.write('        Identifier   "Default Layout"\n')
        fd.write('        Screen       0 "Screen0" 0 0\n')
        fd.write('        InputDevice  "Mouse0" "CorePointer"\n')
        fd.write('        InputDevice  "Keyboard0" "CoreKeyboard"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "Files"\n')
        fd.write('        RgbPath      "/usr/X11R6/lib/X11/rgb"\n')
        fd.write('        FontPath     "unix/:7100"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "Module"\n')
        fd.write('        Load         "dbe"\n')
        fd.write('        Load         "extmod"\n')
        fd.write('        Load         "fbdevhw"\n')
        fd.write('        Load         "record"\n')
        fd.write('        Load         "freetype"\n')
        fd.write('        Load         "type1"\n')
        fd.write('        Load         "glx"\n')
        fd.write('        Load         "dri"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "InputDevice"\n')
        fd.write('        Identifier   "Keyboard0"\n')
        fd.write('        Driver       "kbd"\n')
        fd.write('        Option       "XkbModel" "pc105"\n')
        fd.write('        Option       "XkbLayout" "de"\n')
        fd.write('        Option       "XkbVariant" "nodeadkeys"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "InputDevice"\n')
        fd.write('        Identifier   "Mouse0"\n')
        fd.write('        Driver       "mouse"\n')
        fd.write('        Option       "Protocol" "IMPS/2"\n')
        fd.write('        Option       "Device" "/dev/input/mice"\n')
        fd.write('        Option       "ZAxisMapping" "4 5"\n')
        fd.write('        Option       "Emulate3Buttons" "no"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "Monitor"\n')
        fd.write('        Identifier   "Monitor0"\n')
        fd.write('        VendorName   "Monitor Vendor"\n')
        fd.write('        ModelName    "%s"\n' % monitor)
        if hsync:
            fd.write('        HorizSync    %s\n' % hsync)
        if vsync:
            fd.write('        VertRefresh  %s\n' % vsync)
        fd.write('        Option       "dpms"\n')
        fd.write('EndSection\n\n')
        fd.write('Section "Device"\n')
        fd.write('        Identifier   "Videocard0"\n')
        fd.write('        VendorName   "Videocard vendor"\n')
        fd.write('        BoardName    "%s"\n' % card)
        fd.write('        Driver       "%s"\n' % card_driver)
        if videoram:
            fd.write('        VideoRam     %s\n' % videoram)
        fd.write('EndSection\n\n')
        fd.write('Section "Screen"\n')
        fd.write('        Identifier   "Screen0"\n')
        fd.write('        Device       "Videocard0"\n')
        fd.write('        Monitor      "Monitor0"\n')
        fd.write('        DefaultDepth %s\n' % depth)
        fd.write('        SubSection "Display"\n')
        fd.write('                Viewport 0 0\n')
        fd.write('                Depth    %s\n' % depth)
        fd.write('                Modes    "%s"\n' % resolution)
        fd.write('        EndSubSection\n')
        fd.write('EndSection\n\n')
        fd.write('Section "DRI"\n')
        fd.write('        Group        0\n')
        fd.write('        Mode         0666\n')
        fd.write('EndSection\n')
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of '/etc/X11/xorg.conf' failed:", msg


# run post script
if ks["post"] and len(ks["post"]["script"]) > 0:
    print "Running post script"
    pid = os.fork()
    if pid != 0:
        (rpid, status) = os.waitpid(pid, 0)
        if status != 0 and ks["post"].has_key("erroronfail"):
            print "ERROR: post script failed"
            exit(1)
    else:
        if not ks["post"].has_key("nochroot"):
            os.chroot(buildroot)
        interpreter = "bin/sh"
        if ks["post"].has_key("interpreter"):
            interpreter = ks["post"]["interpreter"]
        try:
            pyrpm.runScript(interpreter, ks["post"]["script"])
        except (IOError, OSError):
            os._exit(1)
        os._exit(0)

if xen:
    print "Writing xen.conf"
    try:
        fd = open("xen.conf", "w")
        fd.write('kernel = "/boot/vmlinuz-VERSION"\n')
        fd.write('ramdisk = "/boot/initrd-VERSION.img"\n')
        fd.write('memory = 128\n')
        fd.write('name = "xen"\n')
        fd.write('nics = 1\n')
        for disk in diskmap:
            if diskmap[disk].has_key("image") and \
                   diskmap[disk].has_key("device"):
                fd.write('disk = [ "file:%s,%s,r" ]\n' % \
                         (diskmap[disk]["image"], disk))
            else:
                fd.write('disk = [ "phy:%s,%s,r" ]\n' % \
                         (diskmap[disk]["device"], disk))
        fd.write('root = "/dev/sda1"\n')
        fd.write('extra = "ro"\n')
        fd.close()
    except Exception, msg:
        print "ERROR: Configuration of 'xen.conf' failed:", msg

# cleanup
exit(0)

##############################################################################

"""
########################## TODO ##########################

/etc/modprobe.conf
/boot/grub/grub.conf
"""
